{"pages":[{"title":"About Me","text":"","link":"/aboutme/index.html"},{"title":"My Friends","text":"","link":"/friendlinks/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"'tag'","text":"","link":"/tag/index.html"}],"posts":[{"title":"AEM","text":"AEM - Adobe Experience Manager","link":"/posts/AEM/"},{"title":"CSS只显示两行","text":"-webkit-line-clamp CSS 属性可以把块容器中的内容限制为指定的行数。 它只有在 display 属性设置成 -webkit-box 或者 -webkit-inline-box 并且 box-orient 属性设置成 vertical时才有效果。 在大部分情况下，也需要设置 overflow 属性为 hidden，否则，里面的内容不会被裁减，并且在内容显示为指定行数后还会显示省略号。 12345678{ overflow: hidden; display: -webkit-box; text-overflow: ellipsis; -webkit-line-clamp: 2; /* 两行 */ -webkit-box-orient: vertical; word-break: break-all;} 效果 💡 其中， word-break 指定了怎样在单词内断行， 这里 break-all 将单词截断换行，由于这里只能显示 2 行，所以出现图中效果","link":"/posts/CSS%E5%8F%AA%E6%98%BE%E7%A4%BA%E4%B8%A4%E8%A1%8C/"},{"title":"Cookie & Session","text":"HTTP无状态（一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接），引入cookie 、session维持和跟踪用户状态。 Session ​ 用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId ​ cookie每次请求都把SessionId自动带到服务器 ​ 当一个用户提交了表单时，浏览器会将用户的SessionId自动附加在HTTP头信息中，（这是浏览器的自动功能，用户不会察觉到），当服务器处理完这个表单后，将结果返回给SessionId所对应的用户。 存储位置不同: Cookie数据存放在客户的浏览器上 Session数据放在服务器上 安全性不同: Cookie不是很安全,别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 Session存放在服务器上,比较安全 大小限制不同: Cookie大小有限制,最大4K左右 Session大小一般可设置1M到几十M,根据服务器的内存大小而定 有效期不同: Cookie的有效期需要程序员自己设置 Session的有效期默认到浏览器关闭时失效 作用范围不同: Cookie被客户端记录,每次请求时都会携带,对于服务器请求数量多的情况下会增加请求数据量 Session只保存在服务器端,不会增加请求数据量 实现机制不同: Cookie通过检查客户浏览器的cookie来确定客户身份 Session通过给客户浏览器分配一个特定的ID来识别客户身份。服务器通过匹配session ID来管理session graph TD A[客户端发起请求] --> B{请求是否包含sessionId?} B -- 包含 --> C[使用已存在的Session] B -- 不包含 --> D[创建一个新的Session] D --> E[生成一个唯一的sessionId] D --> F[为Session分配资源] E --> G[将sessionId返回给客户端] G --> H[客户端保存sessionId] C --> I[使用已存在的Session资源] I --> J[处理请求] J --> K[响应请求] K --> L[结束] F --> L[结束]","link":"/posts/CookieSession/"},{"title":"Create-React-App项目Template","text":"💡项目地址 123456789101112├── .husky├── .vscode├── public├── src│ ├── App.tsx│ ├── index.tsx│ └── react-app-env.d.ts├── prettier.config.js├── tsconfig.json├── package.json└── yarn.lock├── README.md 初始化项目 ​ yarn add create-react-app [app-name] --template typescript prettier ​ yarn add -D prettier 12345678910111213//prettier.config.jsmodule.exports = { semi: false, // 在每条语句的末尾不使用分号 trailingComma: 'es5', // 允许在ES5中有效的尾随逗号 singleQuote: true, // 使用单引号而不是双引号 printWidth: 80, // 指定打印行的最大长度 tabWidth: 3, // 设置每个缩进级别的空格数 useTabs: false, // 使用空格而不是制表符进行缩进 bracketSpacing: true, // 在对象字面量中添加空格 jsxBracketSameLine: false, // 在JSX中把'&gt;'放在最后一行的末尾 arrowParens: 'avoid', // 当箭头函数只有一个参数时不使用圆括号 endOfLine: 'lf', // 行尾序列使用LF（\\n）} husky ​ yarn add -D husky 1234//package.json&quot;scripts&quot;: { &quot;prettier&quot;: &quot;prettier --write \\&quot;src/**/*.{js,jsx,ts,tsx,json,css,scss,md}\\&quot;&quot;} ​ 启用 Git 钩子： npx husky install ​ 添加 pre-commit 钩子：npx husky add .husky/pre-commit &quot;yarn prettier&quot; 路径别名 1234567&quot;compilerOptions&quot;: { // ...其他配置... &quot;baseUrl&quot;: &quot;src&quot;, &quot;paths&quot;: { &quot;@/*&quot;: [&quot;*&quot;] }} 静候补充...","link":"/posts/Create-React-App%E9%A1%B9%E7%9B%AETemplate/"},{"title":"Event Loop","text":"JS单线程，为了不阻塞线程，很多代码通过回调的方式异步执行 JS代码执行顺序被打乱，就需要一种机制–事件循环，协调各个事件的执行顺序 浏览器 同步代码，一行一行在Call Stack中执行（压栈弹栈） 遇到异步代码，记录下代码，等时机到了将代码入队Callback Queue中 当同步代码执行为空，Call Stack为空，Event Loop开始工作 Event Loop轮询查找Callback Queue中是否有可执行代码 有，将代码送入Call Stack执行 没有，将继续轮询查找 调用栈为空触发Event Loop执行先后顺序：微任务、DOM渲染、宏任务 微任务： Promise, async/await 宏任务： 定时器、Ajax、DOM事件 Node Node异步API 定时器 I/O操作 node独有 setTimeoutsetInterval 文件读写数据库操作网络请求… process.nextTicksetImmediate 设计上，事件循环优先处理执行I/O事件 process.nextTick不属于事件循环一部分，优先于事件循环执行 从Timer到Check为一个Tick setImediate(()=&gt;{})、与setTimeout(()=&gt;{}, 0) 中执行时机不确定？ setTimeout(, 0) —&gt; 浏览器 4ms, node 1ms 解决： 将两者放在I/O操作回调中，能保证setImmediate回调先执行","link":"/posts/EventLoop/"},{"title":"GPTPlus速通","text":"","link":"/posts/GPTPlus%E9%80%9F%E9%80%9A/"},{"title":"TCP","text":"在不可靠的网络链路中，进行可靠的链接/断开 全双工（Full Duplex） 双向传输:TCP连接的两端都可以同时发送和接收数据包。 双向流量控制:发送方和接收方都可以通过滑动窗口机制控制数据流量,防止对方缓冲区溢出。 双向确认:发送的数据包可以得到对方的确认应答ACK。接收方也可以通过ACK告知发送方自己已经正确接收了数据。 双向重传:如果任意一方没有收到确认或数据包丢失,都可以触发重传机制,直到数据正确发送。 全双工通信:TCP的全双工特性使得双方可以同时进行发言而不会相互干扰,就像电话通话一样。 ACK 和FIN 是 TCP 协议中两个重要的控制标志(control flag) ACK(Acknowledgement) 确认号，表示确认号,确认接收端已正确接收到前面的数据 FIN (Finish) 结束标志，表示发送端已经发送完数据,可以关闭连接了。 三次握手🤝 传输 一包数据可能被拆为多包数据发送 丢包问题？乱序问题？ TCP为每个链接建立了一个发送缓冲区 一问一答的方式发送接收（发送端一次也可以发送多包数据，接收端只用回复一次ACK） 发送端可以切割发送，接收端利用序列号和长度重组出完整的数据 丢失了某个数据包，接收端可以要求发送端重传。 接收端向发送端发送ACK=xxx，发送端重传，接收端收到再补齐数据 四次挥手👋🏻 这里以客户端取消l为例 Client等待一段时间，目的为了确保ACK成功发送给Server，否则Server重新发送FIN给client，再重新执行","link":"/posts/TCP/"},{"title":"JS类型转换","text":"JS是动态类型语言，我们在定义一个变量其实并没有指定这个变量到底属于那种类型，只有到程序执行阶段才确定当前数据类型。 而各种运算符对数据类型是有要求的，所以就会触发类型转换机制（no matter 人为 or 隐式触发） 显示转换： ​ 通过JS内置的函数明确转换的数据类型 Number parseInt(string, ?进制) 比Number宽松，一位一位解析遇到不能解析的停止 String Boolean 隐式转换： ​ 运算操作符两边数据类型不一致（比较运算符、算术运算符） 转为Boolean (需要布尔值的地方，借助的Boolean()函数) falsely变量：undefined、null、false、+/-0、NAN、&quot;&quot; 转为String （复合类型—&gt;原始类型----&gt;字符串） 常发生在，如 &quot;5&quot; + xxx 的加法运算中 转为Number 除了加法运算符号，其他都有可能 other === 在不进行类型转换情况下，双方的类型与值都相等","link":"/posts/JS%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"title":"btoa-atob","text":"今天在找登录token发先存于Cookie的access_token被加密成ASCII字符串，遂找到了两个window下的api 123456789// base64Encryptionexport function encryptToken(token) { const encryptedToken = btoa(token) return encryptedToken}export function decryptToken(encryptedToken) { const decryptedToken = atob(encryptedToken) return decryptedToken} Binary To ASCII btoa() 方法可以将一个二进制字符串（例如，将字符串中的每一个字节都视为一个二进制数据字节）编码为 Base64 编码的 ASCII 字符串。 **ASCII To Binary ** atob() 对经过 base-64 编码的字符串进行解码","link":"/posts/btoa-atob/"},{"title":"computed与watch","text":"计算属性computed ​ 适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来 支持缓存，只有依赖数据发生改变，才会重新进行计算 不支持异步，当computed内有异步操作时无效，无法监听数据的变化 computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed 如果computed属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;p&gt;计算属性示例&lt;/p&gt; &lt;p&gt;原始数据: {{ originalData }}&lt;/p&gt; &lt;p&gt;计算属性: {{ computedProperty }}&lt;/p&gt; &lt;button @click=&quot;updateData&quot;&gt;更新数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { originalData: 5 }; }, computed: { computedProperty() { // 计算属性，依赖于原始数据 return this.originalData * 2; } }, methods: { updateData() { // 更新原始数据，会触发计算属性重新计算 this.originalData += 1; } }};&lt;/script&gt; 侦听属性watch ​ 适用于观测某个值的变化去完成一段复杂的业务逻辑（例如执行异步或开销较大的操作） 不支持缓存，数据变，直接会触发相应的操作； watch支持异步； 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值； 当一个属性发生变化时，需要执行对应的操作；一对多； 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：新值和旧值 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;p&gt;监听的数据: {{ watchedData }}&lt;/p&gt; &lt;button @click=&quot;changeData&quot;&gt;改变数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { watchedData: '初始值' }; }, methods: { changeData() { this.watchedData = '新值'; } }, watch: { watchedData(newVal, oldVal) { // 在数据变化时触发的操作 console.log('新值：', newVal); console.log('旧值：', oldVal); // 这里可以执行您想要的其他操作 } }};&lt;/script&gt;","link":"/posts/computed%E4%B8%8Ewatch/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/posts/hello-world/"},{"title":"HTTP summary","text":"HTTP Hyper Text Transfer Protocol Stateless : every Request is INDEPENDENT regard each request as a single transaction use cookie session localStorage … to enhance user experience( memorize the state from the user ) HTTPS Hyper Text Transfer Protocol Secure Data sent is encrypt SSL – Secure Sockets Layer TLS – Transfer Layer Security install certificate on web host to use HTTPs Message Headers General Request URL、Request Method、Status Code、Remote Address、Referrer Policy Request Cookies、Accept-xxx、Content-Type、Content-Length、Auhurization、User-Agent、Referrer Response Server、Set-Cookie、Content-Type、Content-Length、Date Status Code Status Code Means 1xx request received / processing 2xx Success received, understood, accepted 3xx Further action must be taken / redirect 4xx Client error 5xx Server error 200 - OK 201 - OK created 301 - Move to new URL 304 - Not Modified (Cached version) 400 - Bad Request （❌ not sending correct data） 401 - Unauthorized （missing token） 404 - Not Found (resources do not exsist) 500 - Internal Server Error HTTP2 multiplexing","link":"/posts/http/"},{"title":"js红宝书","text":"&lt;script&gt;标签 一些属性 defer 推迟 async 异步 期间不要动DOM intergrity 检查安全 src GET 跨域 引入外部文件文件，行内代码写了没用 MIME 代码块中的脚本语言内容类型 &lt;noscript&gt;&lt;/noscript&gt; 严格模式（ES5增加） 遵守的是es3的语法 开启严格模式，脚本开头写上&quot;use strict&quot;; ，也可写在函数内部开头，单独开启严格模式 变量 ​ var变量提升hoist ，函数作用域,全局声明成为window对象属性 ​ let，块级作用域，暂存性死区（temporal dead zone) ​ let和var 只是指出变量在相关作用域如何让存在 ​ const 适用于for-in(对象属性名)、for-of（数组） 声明风格 ​ 不使用var， const优先，let次之 3.4 数据类型 ​ Undefined、Null、Boolean、Number、String、Symbol、Object ​ typeof 操作符 ​ typeof null =&gt; onject (null被认为是空对象的引用) ​ Number ​ 八进制: 0111 在严格模式下报错、0o111可以 ​ 1. 和 1.0 为整数，1.1、1.2浮点数 ​ ES会将小数点后至少包括6个0的浮点值转换成科学计数法 ​ String ​ ECMAScript中的字符串是不可变的immutable ​ toString 返回自身的一个副本 ​ 除了null 和 undefined都有toString方法。对于数值类型可以传参(转换进制数) ​ 对于变量未知类型的，转为字符串，利用**String()转型函数** ​ 模板字面量 `` ​ 保留换行字符，跨行定义字符串 ​ 字符串插值 ``${js表达式}` ，调用了toString方法强制转换为字符串 ​ 标签函数(模板字面量隔开形成的字符串数组，...模板字面量的值) ​ 原始字符串String.raw 12console.log(`\\u00A9`) //© (输出转义后的符号console.log(String.raw`\\u00A9`) //\\u00A9 (输出原始的字符串 ​ Symbol ​ 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同 ​ 全局符号： ​ symbol.for()执行幂等操作，第一次操作会检查全局运行时注册表，是否存在对应的symbol.for() ​ 查询全局注册表Symbol.keyFor(参数) (参数必须为symbol类型，否则抛出typeError) ​ 查询成功返回symbol值，否则返回undefined ​ 作为对象[属性]使用 ​ defineProperty添加symbol类的值作为属性（在node下不能） ​ 内置符号（不可写，不可枚举，不可配置） ​ Symbol.iterator for-of循环会使用这个属性 ​ Symbol.asyncIterator for-await-of使用，异步迭代器 ​ Symbol.hasInstance定义在Function的原型身上 ​ Symbol.isConcatSpreadable（默认值undefined） 控制Array.prorotype.concat是否“打平”连接 ​ 对于数组对象(默认打平），设置为falsely变量，不会打平连接，会让整个对象追加到数组末尾 ​ 对于类数组对象（默认不打平），设置为truely变变量，会打平连接，到数组实例 ​ Object ​ ECMAScript只要求给构造函数提供参数时使用括号 1const obj = new Object //合法，但不推荐 ​ hasOwnProperty ​ valueof() 定义在对象里的方法。 return的值， ​ 显示获取：obj.valueOf() ​ 隐式获取：++obj 对obj进行数学运算，直接调用的valueOf()方法 3.5 操作符 ​ 一元操作符 ​ 自增、自减、+、- ​ + 拼接字符串，- 先Number()转换，在减法操作 ​ 位操作符 ​ ECMAScript 数值 以IEEE 745 64位格式存储 ​ 位操作，将值转为32位整数，再进行操作，最后再把结果转为64位 ········ 3.6 语句 ​ for-in 严格迭代语句，遍历对象的可枚举非symbol类型属性 ​ for-of 严格迭代语句，遍历可迭代对象 ​ 标签语句 配合continue和break使用 ​ with语句，将代码的作用域设定为特殊的对象 123456789const a = process.pidconst b = process.ppidconst c = process.titleconsole.log(a, b, c)with(process){ console.log(pid, ppid, title)}//严格模式不支持with，影响性能，难于调试，不推荐使用 ​ switch 全等操作符，不会强制转换类型 第四章 变量、作用域与内存 4.1 原始值与引用值 ​ 原始值（基础数据类型值） ​ 引用值，保存在内存中的对象 ​ ECMAScript函数参数传递是按值传递，（传递的是值的副本而非值本身） ​ 确定类型： ​ instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 ​ typeof…etc 4.2 执行上下文与作用域 ​ var的函数作用域声明：变量会添加到最近的上下文，作用域提升 ​ with语句中var声明的变量为在全局作用域中 ​ let、const {}块级作用域 使用const变量有助于JS引擎(谷歌V8引擎)优化，编译时就将所有实例替换成实际的值，而不会通过查询表进行变量查找 ​ 标识符查找：沿作用域链查找 4.3 垃圾回收♻️ ​ 基本思路：确定那个变量不会再使用，然后释放他占用的空间。（周期性自动运行） ​ 主要标记策略 ​ 标记清理： ​ 标记内存中的所有变量 ➡️ 去掉上下文或者上下文引用的变量的标记 ➡️ （这时候再被加上标记的变量就是待删除的了，任何上下文的变量都访问不到它们了）回收 **引用计数**(❗️导致循环引用) ​ 变量声明并赋引用值，引用数为1； ​ 如果同一个值又被赋值给另一个，引用数+1； ​ 该引用值被其他值覆盖，则引用数-1。 ​ 当引用值为0时，就会被垃圾回收 ​ 将变量设为null，切断变量与其之前引用值之间的关系。 ​ 性能： ​ 现代垃圾回收程序根据运行时的环境来决定何时运行（以前IE是达到设定的阈值，就执行回收） ​ 也有浏览器提供方法可以主动触发垃圾回收（❌） ​ 提升性能： ​ 使用const let声明变量：相对于函数作用域的var，块级作用域可能会更早终止，会让垃圾回收程序接介入，尽早回收内存 ​ 隐藏类和删除操作delete ​ V8引擎将JS代码编译成实际的机器码会利用”隐藏类”，能够共享隐藏类的对象性能更高 ​ 动态添加、删除属性导致不共享一个隐藏类 123456789function Foo(){ this.name = 'iam foo'}// 两个实例共用一个相同的隐藏类，因为两个实例共享一个共同的构造函数let f1 = new Foo()let f2 = new Foo()//‼️但是如此修改（这种操作的频率和隐藏类的大小对性能产生明显影响f2.name = 'iamf2'//Foo实例对应两个 不同 的隐藏类。 12345678910111213//✅解决方案： 先创建再补充function Foo(name){ this.name = name}//这样对应相同的隐藏类let f1 = new Foo('iamf1')let f2 = new Foo()//‼️但是，使用delete关键字动态删除属性导致，不再共享一个隐藏类delete f1.name//✅解决方案 把不想要的属性设置为nullf1.name = null ​ 内存泄漏 ​ 意外声明全局变量 ​ 定时器回调引用外部变量 ​ 使用闭包 ​ 静态分配与对象池 第五章 基本引用类型 5.1 Date UTC 协调世界时 GMT格林威治平时 ​ ​ Date.parse(创建的是本地日期) Date.UTC(创建的是GMT日期) 将一个表示日期的字符串解析为对应的时间戳（毫秒数） ​ new Date(传入时间字符串) ，根据字符串格式隐式调用上面两个构造函数 ​ Date类重写了toLocaleString toString valueOf(返回时间戳) ❓5.2 正则 5.3 原始值包装类型 ECMAScript提供了3种特殊的引用类型，Boolean String Number ​ 正常来说原始值本身不是对象，按逻辑上不应该有方法 12let s1 = 'some text'console.log(s1.substring(2)) //me text 包装类型让原始值拥有对象行为 ​ 创建一个String类型实例 ​ 调用实例上的方法 ​ 销毁实例 123456789// 显示创建原始值包装类型(不推荐)const s = new String('i am a string')//构造函数console.log(typeof s) //objectconst s = 'i am a string' console.log(typeof s) //stringconst s = String('i am a string') //转型函数console.log(typeof s) //string 12345// object工厂方法创建const os = new Object('i am a string')// 创建的是一个String实例console.log(typeof os, os instanceof String)// object true number ​ toFixed方法，返回的字符串保留几位小数（0~20位+，超过，四舍五入） 1234const num = 10console.log(num.toFixed(2))//10.00console.log(Number(10.005).toFixed(2))//10.01 ​ toPrecision返回最合理的数值(1-21小数位) String ​ JS 一个字符16位 ​ 与模式匹配相关的方法: match search replace split 5.4 单例内置对象 Global ​ eval函数（⛔️XSS攻击） ​ 这个函数就是个完整的ECMAScript解释器 ​ 定义在eval函数中的变量和函数，不存在函数提升 ​ 开启严格模式够，外部访问不到eval函数里的数据 Math 第六章 集合引用类型 6.1 Object ​ 字面量{}形式创建一个对象，并不会new Object() 6.2 Array ​ 字面量[]形式创建一个数组，也不会new Array() 1const arr = new Array(20) //定义数组长度为20 Array.from() 将伪数组转为真数组 Array.of() 将一系列参数转为数组 Array.of( 1, 2, 3) ➡️ [1, 2, 3] 数组空位 ​ 字面量一串逗号形式创建空位 ​ ​ ES6新增的方法和迭代器，将空位当成存在的元素，值为undefined ​ ​ ES6之前的方法， 忽略空位（具体的行为因方法而异） ​ map跳过空位，join将空位视为空字符串 ​ 数组索引 ​ 数组的length不是只读的，利用这个特性删除数组末尾元素（当然也可添加数组空位） ​ 检测数组 ​ 在一个全局上下文中，使用instanceof。 多个 iframe多个全局上下文。然后每个里面都有 Array 这个对象。他们并不相等。 本质来讲 instanceof 是去找 prototype 之类的，看看是否有继承。 ​ Array.isArray() 迭代器方法 ​ arr.keys() 返回数组索引的迭代器 ​ values() 返回数组元素的迭代器 ​ entries() 返回 索引/值 对的迭代器 ​ alert期待字符串 排序方法 ​ sort ，事先对数组中的没项元素都使用的String转型函数 ​ 升序：compare(val1, val2) val1 &gt; val2 return 1 ​ 降序：compare(val1, val2) val1 &gt; val2 return -1 操作方法 ​ concat splice 搜索方法 ​ indexof lastIndexOf includes ​ find findIndex 迭代方法 ​ every some ​ filter map forEach 归并方法 reduce reduceRight 6.3 定型数组 6.4 Map Set ​ 定义时都接受一个可迭代对象初始化映射 ​ 使用forEach，for-of迭代值 6.5 weakMap weakSet ​ weakMap存储键值对的键必须为引用类型数据 如果键的指向为空，自动称为垃圾回收的目标 weakMap实现真正的私有变量 都不可迭代值 6.8 迭代与扩展操作 ​ 定义的默认迭代器（Array 定型数组 Map Set） ​ 支持for-of顺序迭代、兼容扩展操作符 浅复制：只会复制对象的引用 第七章 迭代器与生成器 ​ 迭代：按顺序反复执行一段程序 ​ 循环是迭代的基础 迭代器模式 ​ 开发者无需知道如何迭代就能实现迭代操作 ​ 实现可迭代iterable接口的对象，都能被事件iterator接口的结构消费 ​ 内置iterable接口的类型：Stirng Array Map Set arguments对象 NodeList等DOM集合类型 ​ 接受可迭代对象的原生语言特性 ​ for-of 数组解构 扩展操作符 ​ Array.from new Set/Map ​ Promise.all / race yeild*操作符 给对象添加可迭代的iterable接口， 1234567891011121314151617let obj = { list: [1, 2, 3, 4], [Symbol.iterator]() { let count = 0 const { length } = this.list return { next: () =&gt; { return { done: count === length ? true : false, value: this.list[count++] } }, //提前终止，调用return方法 return() { console.log('Exiting Early!') return { done: true } } } }} 接收迭代器实例 123const iter = obj[Symbol.iterator]()console.log(iter.next()) //调用next方法console.log(iter.next()) 不同迭代器实例之间没有联系 迭代器不与对象某时刻的快照绑定，也可根据实际情况动态变化 迭代器维护一个指向可迭代对象的引用，⛔️阻止垃圾回收可迭代对象 提前终止迭代器 ​ 如上return方法指定迭代器提前关闭时执行的逻辑 ​ for-of 循环 在 break continue return throw时，触发提前终止逻辑 123456789for (let val of obj){ if(val === 3){ break } console.log(val)}// 1// 2// Exiting Early! ​ 解构操作并未消费所有的值时 1234const [item1, item2] = objconsole.log(item1, item2)// Exiting Early!// 1 2 如果迭代器没有关闭，可以从上次离开的地方继续迭代（数组的迭代器不能关闭） return() 方法是可选的 仅仅给一个不可关闭的迭代器器增加一个return方法并不能让他关闭。调用return方法并不会强制迭代器进入关闭状态。 生成器模式 临时的可迭代对象称为生成器 ​ 生成器拥有在函数块内暂停和恢复代码执行的能力 可以用于自定义迭代器和实现协程 💬定义生成器 ​ 函数名前加『 *』，箭头函数不可用于定义生成器函数 12function * generatorFn(){}//函数表达式方式 对象方法 类方法 类静态方法。。。 ​ 调用生成器函数产生生成器对象 12const g = generatorFn()console.log(g)// 开始暂时处于暂停执行状态，生成器对象也实现了iterator接口，具有next方法 初次调用next()方法指明开始调用生成器 value属性是生成器返回值，默认undefined 🛑yeild中断执行 yeild关键字只能在生成器函数中使用 作为可迭代对象使用 生成器显示调用next方法用处不大。 将生成器对象作为可迭代对象使用 12345678function *genneratorFn(){ yield 1 yield 2 yield 3}for(let val of genneratorFn()){ console.log(val)} yeild实现输入输出 yeild产出的值传给g.next() g.next()传入的参数，作为是yeild的返回值 产生可迭代对象 123// ...yeild *[1, 2, 3]// ... yeild* 其实也就是将可迭代对象序列化为一串可以单独产出的值 123456789function* genneratorFnA(){ for (const val of [1, 2, 3]){ yield val }}// 等价！！！function* genneratorFnB(){ yield* [1, 2, 3]} ✅作为默认迭代器使用 123456789101112class Foo { constructor(){ this.list = [1, 2, 3, 4] } * [Symbol.iterator](){ yield* this.list }}const f = new Foo()for(const val of f){ console.log(val)} 提前终止生成器 return() 强制生成器进入关闭状态 throw() 将一个错误注入到生成器中 如果生成器没处理这个错误，生成器会closed 生成器内部处理了这个错误生成器就不会关闭，而且会恢复执行（只是跳过了这个值） 第八章 对象、类与面向对象编程 8.1 对象 定义 ​ 构造函数、字面量形式 对象属性 数据属性（默认都为true) Configurable 属性可由delete删除 Enumerable 是否可由for-in枚举 Writable 是否可被修改 Value 包含实际值，默认undefined ​ 使用Object.defineProperty对对象属性属性修改（不配置值，默认为fasle） (严格模式下： 尝试对configurable: false; witable: false；的值修改，会抛出错误。) 不能对同一个属性，定义多次Object.defineProperty() 访问器属性 getter setter 12345678910111213141516171819202122232425const obj = { _name: 'levy_init' } Object.defineProperty(obj, 'name', { get() { return this._name }, set(newVal) { console.log('尝试修改name') this._name = newVal console.log('修改成功') } }) const obj2 = { _name: 'levyy', get name() { return this._name }, set name(newVal) { console.log('尝试修改name') this._name = newVal console.log('修改成功') } } Object.defineProperties 对一个对象的多个属性一次性进行描述符规定 12345678910111213const obj = { _name: 'levy'}Object.defineProperties(obj, { name: { get(){ return this._name } }, age: { value: 21 }}) 读取属性特性 ​ 读取对象某一个： Object.getOwnProperty(obj, 'aProperty') ​ 读取对象全部属性的特性：Object.getOwnProperties(obj) //其实也是对每个属性调用了上面的方法，在一个新对象返回 合并对象（混入） Object.assign()浅复制，只复制可枚举(PropertyIsEnumerable)、自身(hasOwnPropery)属性 不复制属性的getter setter 没有回滚之前赋值的状态，尽力赋值 相等判断 Object.is() 增强语法 属性值简写、可计算属性、方法简写、对象解构 8.2 创建对象 ES6 Class Extends也是基于ES5原型链继承的语法糖 工厂模式 12345678910function createPerson(name, age){ const o = new Object() //显式创建对象 o.name = name o.age = age o.sayName = () =&gt; { return o.name } return o //return 对象}const p1 = createPerson('小明', 10) 构造函数模式 12345678function Person(name, age){ this.name = name this.age = age this.sayName = () =&gt; { return this.name }}const p2 = new Person('小红', 10) new操作符 内存中创建一个新对象 这个新对象的内部的[[Prototype]]属性赋值为构造函数的prototype属性 构造函数内部的this被赋值为这个新对象（this指向新对象） 执行构造函数内部代码（给新对象添加属性） 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的对象 123456const myNew = (constructor, ...args) =&gt; { const o = new Object() o.__proto__ = constructor.prototype const res = constructor.apply(o, args) return res instanceof Object ? res : o} ​ 构造函数如果不传参可以不用写括号 问题 ​ 不同实例上的方法不是同一个，方法都是做同样的事，没必要定义两个不同的Function实例。 ​ 解决可以把方法定义在构造函数外部，构造函数内部方法直接引用 原型模式 在构造函数原型定义的属性方法可以被实例共享 1234567891011121314151617181920212223function Person(){ Person.prototype.name = '小小' Person.prototype.sayName = () =&gt; { return this.name }}const p = new Person()console.log(p.name, p.sayName)// 简化写法：function Person(){ Person.prototype = { name: '小小', sayName(){ return this.name } }}Object.defineProperty(Person.prototype, 'constructor', { value: Person, enumerable: false //原生constructor不可枚举，用这种方式定义}) isPrototypeOf 检查原型 原型链 1Person.prototype.isPrototypeOf(p) //true Object.getPrototypeOf() 获取原型对象 1Object.getPrototypeOf(p) === Person.prototype //true 更改原型对象 ​ Object.setPrototypeOf() 影响性能 ​ Object.create 1234567891011121314let a = { name: 'a'}let b = { age: 18}console.log(b)Object.setPrototypeOf(a, b)console.log(Object.getPrototypeOf(a) === b) //trueconsole.log(a.__proto__ === b) //truelet c = Object.create(a)console.log(Object.getPrototypeOf(c) === a)//trueconsole.log(c.__proto__ === a)//true 实例可以通过原型链查找属性 确定属性在自身还是是原型链上的 hasOwnProperty() in 操作符是在自身以及原型链上查找 Object.keys() 遍历实例可枚举属性 Object.getOwnPropertyNames() 遍历实例无论是否可枚举属性（除了Symbol ） Object.getOwnPropertySymbols() 遍历顺序 for-in Object.keys() 无序 对象迭代 Object.values() Object.entries() 浅复制对象、不迭代Symbol 8.3 继承 参考掘金 原型链继承 每个构造函数有一个原型对象prototype， 这个原型对象有个属性constructor指向构造函数本身。 而这个构造函数实例有一个内部指针__proto__，指向这个原型 那如果这个原型是另一个类型的实例，就意味着这和原型本身有个指针指向另一个原型，相应另一个原型也有个指针指向另一个构造函数。 这样形成了实例与原型之前的原型链 盗用构造函数 组合继承 原型式继承 寄生式继承 寄生组合继承 寄生式继承父类原型，然后将返回的对象赋值给子类原型 混入式继承 Class 继承 8.4 类 定义方式： 123456789// 类声明 class Foo{}// 类表达式 const Foo1 = class FooName{ //表达式类名FooName可选 identify(){ console.log(Foo1.name ,Foo2.name) //name字段获取类名 // class后定义了类名就是指定类名FooName，否则类名就是Foo1 } } 类是一种特殊的函数typeof，但是并不会有作用域提升 类声明受块级作用域影响，而函数生命则受函数作用域影响 constructor构造函数 构造函数默认返回this，构造函数返回的对象用作实例化的对象 如果这个构造函数返回的不是this对象，而是其他对象，那么通过instanceof操作符不会检测出这个对象与这个类有关。 因为在new操作时，会自动绑定this，如果 123456789101112class Foo { constructor(override) { this.foo = 'foo' if (override) { return {} } }}const foo1 = new Foo()console.log(foo1 instanceof Foo) // trueconst foo2 = new Foo(true)console.log(foo2 instanceof Foo)// false 类中定义的方法成为原型方法 类块中定义的方法都会定义在类的原型上 静态类方法 迭代器、生成器 继承 extends 继承一个类或者一个普通的构造函数 super只能在派生类构造函数和静态方法中使用 调用super()函数会调用父类构造函数，并将返回的实例赋值给this 给父类传参，super()手动传参 在类构造函数中不能在super()之前调用this 在派生类中显示定义了构造函数，必须要调用super或者返回一个对象 抽象基类 供其它类继承，却不被实例化 利用new.target实现 123456789class Foo{ constructor(){ console.log(new.target) //返回Foo类 if(new.target === Foo){ throw new Error('Foo 不能直接被实例化') } }}let f = new Foo() //报错 第九章 代理与反射 9.1 代理 用作目标对象的替身，但独立于对象 1new Proxy(target, handlerObj) //参数两者缺一不可 Proxy.proptotype 为undefined，所以不能使用instanceof操作符 ===严格相等可以用来区分代理和目标 捕获器 get ​ 接受参数（目标对象，要查询的属性，代理对象) 重建被捕获的原始行为： 使用捕获器，被代理的属性如果同时not Configurable and not Writable，则TypeError报错 反射API Reflect delete函数属性—&gt;Refelect.deleteProperty name in obj —&gt; Reflect.has(obj, ‘name’) 可撤销代理 撤销函数和代理对象是同时在实例化时生成的 123456789101112131415const obj = { foo: 'bar'}// 解构 代理对象和撤回函数const { proxy, revoke } =Proxy.revocable(obj, { get(){ return '1234' }})console.log(proxy.foo)//1234revoke() //撤销代理console.log(obj)console.log(proxy)//error 实用反射Reflect API 反射API不局限于捕获程序处理 代替Object上的方法（错误必须try catch捕获 到 反射API返回布尔值） 反射方法return 的值称为“状态标记”的布尔值 代替一些操作符 Reflect. get in set = 赋值操作符 has in 或者 with() deleteProperty delete Construct new 使用Reflect.apply调用函数(被调用函数，this指向，[实参…]) 构建多层拦截网 ​ 代理另一个代理 代理模式 一种编程模式 跟踪属性访问 隐藏属性 12345678910111213141516171819202122232425262728const hiddenProperties = ['age', 'sex']const person = { age: 18, sex: '男', name: '小明'}const proxy = new Proxy(person, { get(TrapTarget, property){ if(hiddenProperties.includes(property)){ return undefined } else { return Reflect.get(...arguments) } }, has(target, property){ if(hiddenProperties.includes(property)){ return false } else { return true } }})console.log(proxy.name)console.log(proxy.age) //undefinedconsole.log('name' in proxy) //trueconsole.log('sex' in proxy)//false 属性验证 ​ 赋值操作触发set，根据情况决定赋值 函数与构造函数参数验证 数据绑定和可观察对象","link":"/posts/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/"},{"title":"nodejs","text":"pre 运行时（Runtime) &quot;运行时&quot;就是程序运行的时候，也就是指令加载到内存并由CPU执行的时候。 与之相对应的是“编译时”，其指代码编译的时候，也就是C代码编译成可执行文件的时候，此时指令没有被CPU执行。 运行时库（Runtime Library） 运行时库就是程序运行的时候所需要依赖的库。 运行时环境（Runtime environment） 运行环境（英语：Runtime environment）又称“运行时系统”（run-time system），指一种把半编译的运行码在目标机器上运行的环境。 简介 Nodejs 只是一个js运行时环境 访问系统内核，访问本地文件，链接服务器… nodejs在浏览器之外运行v8引擎 跨平台 适合干IO密集型应用，不适合CPU密集型（单线程） CPU 密集型： 图像、音频处理需要大量的数据结构+算法 全局变量 node global 浏览器 window globalThis根据环境自动判断 ECMAScript中有的全局，如Math… __dirname 当前文件所在目录(绝对路径) __filename 当前文件路径（绝对路径） __extname 文件后缀 Buffer process 处理进程 process.argv 获取参数数组 process.cwd() 目录 process.exit() 终止进程 process.on('exit', ()=&gt;{console.log('退出')}) 监听事件 nodejs应用在（长期运行!!httpserver返回++counter）单个进程中运行，无需为每个请求创建新的线程 （相比，Apache，每一个请求创建一个线程） 单线程，并发量为1 采用了非阻塞的开发范式（事件循环机制） + v8引擎加持，轻松应对高并发 主线程是单线程，io是libuv维护的线程池 当函数调用栈内有函数运行时，js不能处理其他请求 异步模块（多线程）和事件循环（监听 派发，不占用单独线程） 循环不停监听异步模块处理进度，等处理完成后，派发函数调用栈执行 最快的速度清空函数调用栈，把耗时的操作全部做异步处理 node将【异步操作和对应的回调函数】封装成一个请求对象，交给底层的异步模块处理 异步操作有结果之后，回调函数进入事件循环等待执行， 事件循环在调用栈清空时，按照某个优先级顺序将回调函数推入到调用栈执行 node异步API 定时器： setTimeOut setInterval （最小1ms，浏览器4ms） I/O操作： 文件读写，数据库操作，网络请求 node独有的，process.nextTick、setImmediate nextTick(优先级比事件循环队列更高) 微任务（promise） timer –&gt;poll（当执行到这里时卡住，检查timer或者check队列有误需要 执行的） check Poll 阻塞，从设计上，是想优先处理IO事件的 Settimeout(,0)与setimmdeiate 放入io中使用，定时器，总会先执行check队列的操作 Timer -&gt; check运行一周称为一个Tick nextTick先于下一个Tick执行 异步代码进入异步模块以非阻塞的形式执行，对应的异步函数会在对应的异步代码执行完成后，派发到不同的队列中 异常处理 为了健壮性：捕获并处理每一个错误 同步代码 try catch 异步代码 Promise (catch) async await trycatch 异步编程 流程控制 回调函数 --&gt; Promise —&gt; async await node官方的库 遵循，错误优先风格 回调函数，需要顺序执行，就要嵌套的写，但是导致回调地狱 平行 顺序 module module并不是全局变量，每一个模块有他相应的模块 核心模块（随着node） 第三方模块 自定义模块（引用路径） 运行时加载 cmj，知道运行时候再报错 编译时加载 esm import from 写在模块顶层 import() （异步，返回promise） V8 预编译阶段 （ESM -分配内存空间 -确定作用域链… 执行阶段 （CMJ Buffer js字符串不可变，所有对字符串的操作都要生成一个新的字符串 fs模块读取，不生命文件类型，默认返回的都是文件二进制缓冲区 1234567const buffer1 = Buffer.alloc(5) //申请五个字节console.log(buffer1.toString())buffer1.write('string') //多写入的部分不会写入console.log(buffer1, buffer1.toString())console.log(Buffer.from('a string')) stream i/o操作 端到端数据交换 加载 缓冲区 处理 流模式 加载一点处理一点 SEO TDK title description (meta) Key(meta) 语义化标签 &lt;a/&gt; href &lt;img/&gt; href alt 一个页面一个h1 和 main标签 … 借助第三方库jsdom（jsdom模拟浏览器环境的库，可以在 Node.js 中使用 DOM API），服务端渲染","link":"/posts/nodejs/"},{"title":"npm","text":"node package manager 基于命令行的工具 安装、卸载、更新、发布 version 版本号x,y,z 主 次 补丁 ^ 锁定从左边数第一个非0的 锁定主版本or次版本 latest 最新版本 依赖 dependecies devDependencies 开发依赖 peerDependencies 对等依赖，（插件不能凭空运行，需要依赖某一模块） 一些常用命令 npm config list 查看npm配置信息 npm get registry 查看镜像源 npm set registry xxxx设置镜像源 npm ls (-g) 当前（全局）安装的可执行文件 npm install 原理 安装依赖存放于根目录node_modules文件夹 排序: .bin @系列 abcd排序 广度优先，扁平化（理想情况下）处理下载 非理想： node_modules下a b 模块依赖不同版本的c模块，会给b模块下再建立一个node_modules文件夹 pakage-lock.json 锁定版本号 缓存： intergrity + verion + name 生成唯一的key，这个key在缓存文件中, npm config list 查看中的cache index-v5 索引目录，记录content-v2的索引位置，对应的 intergrity + verion + name由算法生成的哈希值 对应得上，就将这个加密的包解压到node_modules中 pakage-lock.json pakage.json 不一致 按照pakage中的版本下载，并更新lock中的版本号 一直 先找缓存，没有再下载资源 npm run 可执行命令都存在node_modules下的.bin文件夹中 当前项目node_modules/.bin 中查找 全局的node_modules查找 环境变量中查找 报错 也是有生命周期的 12345{ &quot;predev&quot;: &quot;node 1.js&quot;, &quot;dev&quot;: &quot;node 2.js&quot;, &quot;postdev&quot;: &quot;node 3.js&quot;} 运行 npm run dev, 自动执行了 1.js 2.js 3.js 比如一个打包命令，之前可以做一个清理的任务，最后做一个发布的工作，比如写一个CI脚本顺便把代码提交了 Vue-cli也是用了生命周期pretest: ‘yarn clean’ npx npm高版本自带的命令行工具 运行node_modules/.bin 下的可执行文件 之前通过package.json 中的scripts 配合npm run实现，现在可通过npx运行不需要安装这个依赖包运行命令 避免全局安装 当前项目node_modules/.bin —&gt; 全局modules/.bin —&gt; 官网下载，用完删除（需要联网），减少内存占用 总是使用最新版本 执行任意npm包 在一个项目中，npm i vite 没有全局安装，直接运行vite肯定是不行的， 此时配合npx， npx vite 在项目中的node_modules/.bin中查找运行 与npm区别 npx侧重执行命令 npm侧重安装或卸载某个模块，不具备执行某个模块的功能 发布npm包 npm addUser（创建npm账号） npm login 登录( 使用官方的源，而不是第三方镜像源) npm publish 发布（同版本号不能重新发布，包名唯一） 构建npm私服 部署到内网集群，离线使用 安全性 提高包下载速度 利用verdaccio库 npm i verdaccio -g verdaccio --listen 5000 开启服务 发包流程与之前的差不多","link":"/posts/npm/"},{"title":"React小记","text":"React库和框架的区别是什么？ 页面组件化 数据驱动 MVC V层 react库 ​ react.js是一个开放的js工具库，用于基于UI自检构建用户界面 react框架 ​ 通过脚手架工具搭建的一套完善的前端环境，包括：路由、状态管理、数据获取、第三方的UI组件库和第三方Hooks库(ahooks react-use) 严格模式 ​ 检查组件是否为纯函数 ​ 及早的发现useEffect中的错误 ​ 警告过时的API ESLint ​ 代码规范插件 npm run lint vite-plugin-eslint （vite构建下） Prettier ​ 代码格式化插件 react模块 ​ 核心功能 ​ 组件 react-dom ​ 操作浏览器DOM ​ react-dom/client 客户端渲染使用 ​ react-dom/server 服务端渲染使用 分离不同代码库，可跨平台使用 比如 编写react-native应用，当然不用使用react-dom模块 利用编译器编译成中间这种reactElement对象格式(虚拟DOM)，再利用react-dom库完成 fragment &lt;&gt;&lt;/&gt; 简写，这种方式不能写key classnames 控制样式 事件 ​ 合成事件：处理事件有差异（onmouseenter 实际使用的是over） ​ 事件委托：委托到容器’root’元素 ​ 传参处理 ​ 箭头函数 ​ 高阶函数 条件渲染 ​ 条件分支if else switch case ​ 三目 ? : ​ 逻辑运算符 || ?? &amp;&amp; 不会渲染的值：null、undefined、boolean、‘’ 、对象、函数 利用JSON.stringify() 或者 {undefied +‘’}(拼接空串) ​ 数组渲染 ​ jsx默认对数组进行join()操作 ​ 循环语句 ​ ​ 数组方法（map） 必须写key 帮助react推断发生了什么，从而得以正确的更新DOM树 跟踪列表每一项的身份， 唯一标识 组件的点标记写法 对象形式 ​ 组件写为对象的方法 ​ 可解构使用 函数形式（更好的进行组件分类 ​ 将组件直接挂载在上级组件上 ​ 组件通信方式 props传递值 ​ 整体接收， 解构接收 props传递事件 通过扩展运算符{…}批量上传 组件组合方式 插槽 利用props的children属性 ​ 指定顺序 props默认值 ​ 利用es6的默认值方式 ​ react的defaultProps props类型限定 ​ 使用ts ​ 使用第三方proptypes 组件纯函数 ​ 只负责自己的任务，不会在更改函数调用前就已存在的对象和变量。（不能修改这个函数组件作用域外的对象和变量） ​ 严格模式检测当前组件是否为纯函数，对这函数调用两次，检测值是否变化 ​ 输入相同，则输出相同。纯函数总是返回相同的结果。 ​ 不管调用多次，函数都输出同一个值，对于测试更方便。增强健壮性 组件的状态 瞬间变化的数据被称为状态（state），状态可以进行数据驱动 useState hooks 提供 状态 和 修改状态的方法 ​ 普通变量 无法重新渲染JSX ​ state状态，重新触发函数组件，并且具备组件的记忆。 ​ 普通纯函数函数， 多次调用执行结果 状态是如何改变视图的 渲染与提交的过程 1️⃣触发一次渲染 ​ 💡组件的初次渲染，createRoot.render ​ 🔦内部状态更新，触发渲染送入队列 2️⃣渲染您的组件 ​ 💡在进行初次渲染，react调用根组件&lt;App/&gt; ​ 🔦内部状态更新，会渲染对应的函数组件 3️⃣提交到DOM上 ​ 💡初次渲染，appendChild DOM API ​ 🔦内部状态更新，更新差异的DOM节点 多状态如何正确记忆？ 同一个组件的每次渲染中，useState都依托于一个稳定的调用顺序 在react内部，每个组件保存了一个数组， 按照索引记忆usestate位置。[{索引，useState对}] 所以不要将useState写到一些分支逻辑中，会打乱useState顺序 配合eslint检查，语法是否合规 状态的快照 本次作用域中的状态不会改变 点击后，触发三次setcount，但是当前作用域的count都为0 快照的陷阱，异步的时候造成错觉，其实异步逻辑中的状态还是依赖于这次函数作用域 词法作用域，只看定义，不看调用 状态队列与自动批处理 自动批处理 ​ 等事件处理函数中的所有代码都运行完毕再处理你的state更新 ​ 队列都执行完毕后，在进行ui更新 更新函数的写法 形参c来自于react内部，所以这里并不是保存的count快照，连续调用三次后，得到3 更新函数在内部还是以回调的形式，但没使用形参 严格遵守状态不可变 默认情况下，修改的状态跟上一次相同的情况下，是不会重新触发渲染 引用数据类型 拷贝 ​ 数组，使用相关方法 ​ 扩展运算符 ​ 深克隆（将没改变的数据也是克隆了一份） ​ immer useimmer 可以直接对数据进行修改 惰性初始化状态的值 当状态的值组要通过复杂计算才能得到的话，可以对其进行惰性初始化 只在初始化的时候执行一次 状态提升解决共享问题 父组件管理状态，子组件props 状态的重置处理问题 当组件被销毁会时，所对应的状态也会被重置 当组件位置没有发生变化，状态会被保留 组件渲染位置发生变化，状态不被保留 不同的结构体，给组件添加key属性 diff算法，同层级的元素是否发生改变 利用状态产生计算变量 根据状态会重新渲染组件的特性，利用当前状态快照生成对应的计算变量 受控组件与非受控组件 通过props控制的组件成为受控，通过state控制的组件称为非受控组件 react表单内置了受控组件的行为 ​ value + onChange ​ checked + onChange input标签并不是原始的标签 123456789101112131415const App = () =&gt; { const [value, setValue] = useState(&quot;&quot;); return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={value} onChange={(e) =&gt; { console.log(e.target.value); setValue(e.target.value) }} /&gt; &lt;/div&gt; );}; Hooks react中以use开头的函数被称为Hook钩子，Hooks被称为use函数的集合，也就是钩子的集合 Hooks就是一堆功能函数，（像插件 分为： 内置、自定义、第三方 useRef 使用ref引用一个值，具备记忆功能 改变ref不会触发重新渲染组件 定时器案例：timer用ref存储，始终引用的同一个值 useref进行dom操作 ​ 如：让元素获取焦点，滚动到他或测量尺寸位置 回调写法，在逻辑中操作dom forwardRef 给组件设置ref需要forwardRef转发 forwardRef让您的组件通过ref向父组件公开DOM节点 直接转发ref给子组件报错 useImperativeHandle 自定义由ref暴露出来的句柄 纯函数处理useEffect 纯函数： 副作用： ​ 函数在执行过程中对外部造成的影响成为副作用，如ajax、dom操作、与外部系统同步 ​ 事件可以处理副作用，onclick事件等 ​ 处理副作用，借助useEffect钩子 useEffect触发时机，jsx渲染后触发 依赖项，内部通过Object.is() 方法判定 ​ 当依赖项为空，指挥初始渲染 ​ ESLint会检查依赖项是否正确，包括props state 计算变量 函数写在useEffect中 useCallback 函数始终是同一个 每次重新渲染函数，函数指向地址发生改变 useEffect清理工作 严格模式，检测有无做清理工作 初始化数据时，注意清理操作， ​ 更简洁的方法是使用第三方，ahooks的useRequest useEffectEvent useLayoutEffect 同步执行状态更新 useEffect是在渲染之后，更新之前 如过需要在useEffect中处理DOM，并且改变页面的样式，就需要使用useLayoutEffect， useInsertionEffect DOM更新前触发 此时拿不到dom元素 在css-in-js库中使用的多 useReducer 局部的状态管理，抽离逻辑 useImmerReducer immer类型数据 Context向组件深层次传递数据 reducer配合context实现状态数据共享 更复杂的情况使用第三方库,redux mobx,zuster memo在props不变时跳过重新渲染 达到一些性能优化 props改变的情况下，会重新渲染组件 没有props useMemo对计算结果进行缓存 虽然使用memo，并且props 数组list****值未变化，但是list的引用地址发生变化，底层使用Object.is([], []) ==&gt;flase 比较，则props值改变 使用useMemo对计算数据进行缓存（类似useCallback缓存函数） useCallback对函数进行缓存 useMemo的一种特殊写法 12const fn = useMemo(()=&gt; () =&gt; { console.log(1) })const fn = useCallback(() =&gt; { console.log(1) }) StartTrasition 方法及并发模式 ​ react18开始，渲染是一个单一的、不间断的、同步的事务，一旦渲染开始，就不能被中断 react18引入并发模式，允许标记更新作为一个transition，这回告诉react它们可以被中断执行。这样可以把紧急的任务先更新，不紧急的任务后更新 任务切换 useTrasition hook 提供一个pending状态的布尔值，（配合实现一个loading效果），还有一个startTrasition方法 useDeferredValue 延迟 获取该值的延迟版本 useId 产生唯一标识 id 局部前缀 ​ xxx + id (字符串拼接) id 全局前缀 ​ createRoot 第二参 123ReactDOM.createRoot(document.getElementById('root')!, { identifierPrefix: 'xxx'}) useDebugValue 在自定义hook中打印信息，devtool useSyncExternalStore 操作状态 订阅外部 store 的 React Hook。","link":"/posts/react%E5%B0%8F%E8%AE%B0/"},{"title":"Typora图床","text":"Llllllb, 购买了正版Typora之后，终于可以美美享受图床服务咯 图床平台：sm.ms 5.00 GB免费空间 上传服务器：PicGo 手把手步骤： sm.ms 注册 获取Token PicGo 全局下载 CLI：yarn add global picgo 配置：picgo set 全部默认就行（图床选择 smms） 查看配置：macos 默认保存在~/.picgo目录下 vim ~/.picgo/config.json Typora 设置 &gt; 图像 &gt; 上传服务设置 使用 OMG 你怎么知道我 3.8.2024 要去THE ERAS TOUR Singapore","link":"/posts/typora%E5%9B%BE%E5%BA%8A/"},{"title":"redux-toolkit学习","text":"Redux-Toolkit 摘自官网 Redux Toolkit 是 Redux 官方强烈推荐，开箱即用的一个高效的 Redux 开发工具集。 简化最常见场景下的 Redux 开发， ​ 包括配置 store、定义 reducer，不可变的更新逻辑 ​ 可以立即创建整个状态的 “切片 slice”，而无需手动编写任何 action creator 或者 action type 自带了一些最常用的 Redux 插件， ​ 例如用于异步逻辑 Redux Thunk， ​ 用于编写选择器 selector 的函数 Reselect （可缓存select数据） 在 Redux 中,**切片(Slice)**指的是使用 createSlice API 创建的 reducer 和 action 的组合。它是 Redux Toolkit 中的一个核心概念。 createSlice 接收一个配置对象参数,里面包含: 初始 state reducers:包含不同 reducer 的对象 extraReducers:处理 action 的 reducer 函数 切片让我们可以把 reducer 与 action 打包在一起 创建简化了编写 reducer 的流程 自动生成 action 类型 ⚙️ CRA新建一个react项目 create-react-app myapp --template typescript ⚙️ 安装react-redux react-toolkit npm install @reduxjs/toolkit react-redux 项目基本结构 新建状态管理主文件 12345678910111213// store.tsimport { configureStore } from &quot;@reduxjs/toolkit&quot;import counterReducer from &quot;./slice/counterSlice&quot; // 由切片导入的reducerexport const store = configureStore({ reducer: { counter: counterReducer }})// 根据store本身推断出推断 `RootState` 和 `AppDispatch`类型export type RootState = ReturnType&lt;typeof store.getState&gt;export type AppDispatch = typeof store.dispatch 在项目入口文件，给App组件注入store 1234567891011// index.tsx//....import { store } from './redux/store'const root = ReactDOM.createRoot( document.getElementById('root') as HTMLElement);root.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;); 创建切片 之前利用 都要分别写各自actionCreator和各自的reducer， 现在只用一个切片即可管理 😇 React Toolkit 创建的 Slice 状态state本身是 immutable 的，所以可以放心的直接加工使用 123456789101112131415161718192021222324252627282930313233// src/redux/slice/counterSlice.tsimport { createSlice } from &quot;@reduxjs/toolkit&quot;import { PayloadAction } from &quot;@reduxjs/toolkit&quot;interface ICounterState { value: number}const initialState: ICounterState = { value: 1}// 创建切片export const counterSlice = createSlice({ name: 'counter', initialState, reducers: { increment: (state) =&gt; { state.value += 1 }, decrement: (state) =&gt; { state.value -= 1 }, incrementByAmount: (state, action: PayloadAction&lt;number&gt;) =&gt; { state.value += action.payload }, }})// Action creators 会在各自的reducer函数中自动创建， 这里直接导出export const { increment, decrement, incrementByAmount } = counterSlice.actions// 💡注意&gt; 默认导出的是reducerexport default counterSlice.reducer 尝试在App.tsx组件中使用 123456789101112131415161718192021import React from 'react'import { useDispatch, useSelector } from 'react-redux'import { AppDispatch, RootState } from './redux/store'import { decrement, increment, incrementByAmount } from './redux/slice/counterSlice'const App: React.FC = () =&gt; { const count = useSelector((state: RootState) =&gt; state.counter.value) const disptach = useDispatch&lt;AppDispatch&gt;() return ( &lt;div className=&quot;App&quot;&gt; {count} &lt;button onClick={() =&gt; disptach(increment())}&gt;点击我+1&lt;/button&gt; &lt;button onClick={() =&gt; disptach(decrement())}&gt;点击我-1&lt;/button&gt; &lt;button onClick={() =&gt; disptach(incrementByAmount(100))}&gt;点击我+100&lt;/button&gt; &lt;/div&gt; );}export default App; ✅成功","link":"/posts/redux-toolkit%E5%AD%A6%E4%B9%A0/"},{"title":"vue3数据绑定之-sync","text":"啊啊啊啊学了这么久vue3还不知道sync已经在vue3中被剔除了！！！ 在vue2中我们利用v-bind值给子组件，子组件props接受父组件传来的值 子组件想直接通过props修该父组件传来的值，是不被允许的，这违背了单项数据流的原则 那要子组件想要修改父组件的值，需要通过自定义事件 由父组件定义回调，子组件emit触发回调函数通知父组件修改改，（这里就不展开述说了） 在vue2中提供了一个v-bind修饰符.sync，旨在传递一个值给子组件，而子组件可以更改这个值 而在vue3中这个sync被v-model替代了 传递给子组件的，vmodel绑定的这个值一定得是响应式的","link":"/posts/vue3%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B9%8B-sync/"},{"title":"一键速通菲区Spotify","text":"prerequisite 菲区电话卡、菲区梯子🪜 流程 Spotify换区（挂上🇵🇭🪜） 某宝下单菲律宾电话卡（推荐Globe卡￥20+） 话费充值（推荐易付宝， Google Play下载） 登录进入手机端Spotify，选择套餐通过话费充值 切记💡 第三步，必须在手机端中操作，账号登录成功后不要挂任何🪜，网络直连就行 Other 也可以试试GCash支付，需要实名。 应填写真实的信息（护照等），不然一个月之内检测被封。（谷歌搜有相应的教程）","link":"/posts/%E4%B8%80%E9%94%AE%E9%80%9F%E9%80%9A%E8%8F%B2%E5%8C%BASpotify/"},{"title":"简单实现Toast组件","text":"一个模版文件Toast.vue 一个渲染挂载导出方法文件index.ts 通过Toast.success(‘xxxx’) 调用 这里UI使用Flowbite的Toast组件（需要配合tailwindcss） 供给渲染的模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;script lang=&quot;ts&quot; setup&gt;import { ref } from 'vue'interface Props { visible: boolean type: string message: string}const props = withDefaults(defineProps&lt;Props&gt;(), { visible: false, type: '', message: ''})const status = props.type === 'success' ? 'success' : 'danger'const toast = ref&lt;HTMLDivElement&gt;()const handleClose = () =&gt; { toast.value!.style.display = 'none'}&lt;/script&gt;&lt;template&gt; &lt;Transition name=&quot;toast&quot; enter-active-class=&quot;transition ease-out duration-300&quot; leave-active-class=&quot;transition ease-in duration-300&quot; &gt; &lt;div class=&quot;fixed inset-0 h-0&quot; v-if=&quot;props.visible&quot;&gt; &lt;div :id=&quot;`toast-${status}`&quot; class=&quot;absolute top-5 left-1/2 -translate-x-1/2 flex items-center w-full max-w-xs p-4 mb-4 text-gray-500 bg-white rounded-lg shadow dark:text-gray-400 dark:bg-gray-800&quot; role=&quot;alert&quot; ref=&quot;toast&quot; &gt; &lt;div v-if=&quot;props.type === 'success'&quot; class=&quot;inline-flex items-center justify-center flex-shrink-0 w-8 h-8 text-green-500 bg-green-100 rounded-lg dark:bg-green-800 dark:text-green-200&quot; &gt; &lt;svg class=&quot;w-5 h-5&quot; aria-hidden=&quot;true&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot; &gt; &lt;path d=&quot;M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5Zm3.707 8.207-4 4a1 1 0 0 1-1.414 0l-2-2a1 1 0 0 1 1.414-1.414L9 10.586l3.293-3.293a1 1 0 0 1 1.414 1.414Z&quot; /&gt; &lt;/svg&gt; &lt;span class=&quot;sr-only&quot;&gt; Check icon &lt;/span&gt; &lt;/div&gt; &lt;div v-else-if=&quot;props.type === 'error'&quot; class=&quot;inline-flex items-center justify-center flex-shrink-0 w-8 h-8 text-red-500 bg-red-100 rounded-lg dark:bg-red-800 dark:text-red-200&quot; &gt; &lt;svg class=&quot;w-5 h-5&quot; aria-hidden=&quot;true&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot; &gt; &lt;path d=&quot;M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5Zm3.707 11.793a1 1 0 1 1-1.414 1.414L10 11.414l-2.293 2.293a1 1 0 0 1-1.414-1.414L8.586 10 6.293 7.707a1 1 0 0 1 1.414-1.414L10 8.586l2.293-2.293a1 1 0 0 1 1.414 1.414L11.414 10l2.293 2.293Z&quot; /&gt; &lt;/svg&gt; &lt;span class=&quot;sr-only&quot;&gt; Error icon &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;ml-3 text-sm font-normal&quot;&gt; &lt;!-- {/* 不同 */} --&gt; {{ props.message }} &lt;/div&gt; &lt;button type=&quot;button&quot; class=&quot;ml-auto -mx-1.5 -my-1.5 bg-white text-gray-400 hover:text-gray-900 rounded-lg focus:ring-2 focus:ring-gray-300 p-1.5 hover:bg-gray-100 inline-flex items-center justify-center h-8 w-8 dark:text-gray-500 dark:hover:text-white dark:bg-gray-800 dark:hover:bg-gray-700&quot; data-dismiss-target=&quot;#toast-success&quot; aria-label=&quot;Close&quot; @click=&quot;handleClose&quot; &gt; &lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt; &lt;svg class=&quot;w-3 h-3&quot; aria-hidden=&quot;true&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;none&quot; viewBox=&quot;0 0 14 14&quot; &gt; &lt;path stroke=&quot;currentColor&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;m1 1 6 6m0 0 6 6M7 7l6-6M7 7l-6 6&quot; /&gt; &lt;/svg&gt; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Transition&gt;&lt;/template&gt;&lt;style scoped&gt;.toast-enter-from,.toast-leave-to { opacity: 0; transform: translateY(-30px);}&lt;/style&gt; 导出toast方法，提供给Vue进行挂载 index.ts 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//@ts-nocheckimport { createApp, h } from 'vue'import ToastComponent from './template/Toast.vue'interface ToastProps { visible: boolean type: 'success' | 'error' message: string}const ToastContainer = createApp({ render() { return h(ToastComponent, this.toastProps) }, data() { return { toastProps: { visible: false, type: '', message: '' } as unknown as ToastProps } }})const toast = ToastContainer.mount(document.createElement('div'))document.body.appendChild(toast.$el)const Toast = { success(message: string) { toast.toastProps = { visible: true, type: 'success', message } setTimeout(() =&gt; { toast.toastProps.visible = false }, 3000) }, error(message: string) { toast.toastProps = { visible: true, type: 'error', message } setTimeout(() =&gt; { toast.toastProps.visible = false }, 3000) }}export default Toast 👨‍💻使用 12Toast.success('hello')Toast.error('world')","link":"/posts/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0Toast%E7%BB%84%E4%BB%B6/"},{"title":"面试1","text":"主要围绕简历展开 自我介绍 ​ 从未准备过，每次都是“面试官你好，我是来自xx学校xx学院的学生，学习前端xx年了”，然后就戛然而止。。。 项目 实习项目简介 实习负责板块介绍 难点，遇到什么问题 对于技术上手快吗 计网 Ajax 工作方式 http请求响应过程 杂项 JWT 前端axios拦截 后端加密解密~ vue react 区别 会不会后端（❓ 是否接受加班 反问 公司产品（自研？ 工作地点 &amp; 加班 。。。","link":"/posts/%E9%9D%A2%E8%AF%951/"},{"title":"滑动验证","text":"最近在写一个注册表单的需要一个滑动验证模块。 👨‍💻网上搜寻一番，发现了一个组件比较好用vue3-puzzle-vcode 配合ELement-Plus: dialog 和 form 组件使用 Login组件控制Register表单组件显示 1234567891011121314151617//login.vue&lt;script lang=&quot;ts&quot; setup&gt;import { ref } from 'vue'import Register from '@/components/Register.vue'const registerDiaVisible = ref(false)const openRegisterDia = () =&gt; { registerDiaVisible.value = true}&lt;/script&gt;&lt;template&gt;...&lt;Register v-model:registerDiaVisible=&quot;registerDiaVisible&quot; /&gt;...&lt;/template&gt; Register组件 （表单校验成功后，打开滑动验证组件，再次成功调用onSuccess） 注意调整滑动验证组件的z-index，默认el-dialog组件层级高于Vcode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;script lang=&quot;ts&quot; setup&gt;import { formPost } from '@/api/request'import { ElMessage, FormInstance } from 'element-plus'import { reactive, ref } from 'vue'import { RegisterForm } from '@/ts/interfaces/login.interface'import Vcode from 'vue3-puzzle-vcode'const props = defineProps&lt;{ registerDiaVisible: boolean}&gt;()const emit = defineEmits&lt;{ 'update:registerDiaVisible': [registerDiaVisible: boolean]}&gt;()const handleCancel = () =&gt; { emit('update:registerDiaVisible', false)}//表单绑定的响应式对象const formData = reactive({ nickName: '', realName: '', pwd: ''})// 表单的引用对象const formRef = ref()// 表单校验const rules = reactive({ nickName: [ { required: true, message: '请输入昵称', trigger: 'blur' }, { min: 3, max: 10, message: '请输入3-10位昵称', trigger: 'blur' } ], realName: [ { required: true, message: '请输入用户名', trigger: 'blur' }, { min: 3, max: 10, message: '请输入3-10位用户名', trigger: 'blur' } ], pwd: [ { required: true, message: '请输入密码', trigger: 'blur' }, { min: 3, max: 10, message: '请输入3-10位密码', trigger: 'blur' } ]})const onClose = () =&gt; { isShow.value = !isShow.value}const onSuccess = () =&gt; { // 滑动验证成功, 发送请求 formPost&lt;RegisterForm, string&gt;({ url: '/user/register', data: { ...formData } }) .then(res =&gt; { isShow.value = !isShow.value ElMessage.success(res.data) }) .catch(err =&gt; { isShow.value = !isShow.value ElMessage.error(err.msg) })}const onSubmit = async (formEl: FormInstance | undefined) =&gt; { if (!formEl) return formEl.validate((valid, fields) =&gt; { if (valid) { isShow.value = !isShow.value } else { console.log('error submit!', fields) } })}const isShow = ref(false)&lt;/script&gt;&lt;template&gt; &lt;el-dialog title=&quot;用户注册&quot; v-model=&quot;props.registerDiaVisible&quot; :before-close=&quot;handleCancel&quot; &gt; &lt;el-form :rules=&quot;rules&quot; :model=&quot;formData&quot; ref=&quot;formRef&quot;&gt; &lt;el-form-item label=&quot;昵称:&quot; label-width=&quot;120&quot; prop=&quot;nickName&quot;&gt; &lt;el-input v-model=&quot;formData.nickName&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;姓名:&quot; label-width=&quot;120&quot; prop=&quot;realName&quot;&gt; &lt;el-input v-model=&quot;formData.realName&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码:&quot; label-width=&quot;120&quot; prop=&quot;pwd&quot;&gt; &lt;el-input v-model=&quot;formData.pwd&quot; show-password /&gt; &lt;/el-form-item&gt; &lt;div&gt; &lt;el-button @click=&quot;handleCancel&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit(formRef)&quot;&gt; 确 定 &lt;/el-button&gt; &lt;/div&gt; &lt;/el-form&gt; &lt;/el-dialog&gt; &lt;Vcode :show=&quot;isShow&quot; @success=&quot;onSuccess&quot; @close=&quot;onClose&quot; /&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;:global(.vue-puzzle-vcode) { z-index: 10000;}&lt;/style&gt; final","link":"/posts/%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81/"},{"title":"乐山","text":"寒假终于有机会出游（蹭的）（特别感谢我哥和我嫂子）🫰 三天两晚，乐山城区、苏稽古镇、金口河 （不得不说来乐山旅游的人真的太多多多了，城区每家店子人都爆满 吃的板眼儿多得遭不住 🆘​ 炸串（排队排队） 咔饼 豆腐脑（不能接受勾了芡的食品） 甜皮鸭 404忘记拍照了… 苏稽翘脚牛肉单拎出来，太好吃了 favorito~ 坐船看了乐山大佛，逛了苏稽古镇，当然最impressive的还是金口河大峡谷。。。 人类真的特别特别渺小","link":"/posts/gallery-%E4%B9%90%E5%B1%B1/"},{"title":"表格导出为excel","text":"配合xlsx模块 + fileSaver模块 ⚙️ 下载 yarn add xlsx file-saver 🔦 使用 ​ tableData格式 [ { xxx: yyy }, …] 123456789101112131415161718192021222324import * as XLSX from 'xlsx'import FileSaver from 'file-saver'const excelTable = tableData.map(item =&gt; { //格式化一下表格数据 return { '系统编号': item.id, '账单时间': item.billTime, '类型': item.natureName=== '收入'?'收入':'支出', '金额': item.natureName=== '收入'?item.amountMoney:-item.amountMoney, '备注': item.remarks } }) const worksheet = XLSX.utils.json_to_sheet(excelTable) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1') const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' }) const blob = new Blob([excelBuffer], { type: 'application/vnd.ms-excel' }) setTimeout(() =&gt; { FileSaver.saveAs(blob, '账单') // 下载文件 文件名 }, 500) 本来是想利用WebWorker在另一线程中处理数据，在vite中还没配置好，on the way~","link":"/posts/%E8%A1%A8%E6%A0%BC%E5%AF%BC%E5%87%BA%E4%B8%BAexcel/"},{"title":"大理","text":"永远怀念那一个自由的夏天 洱海傍晚 我最好的一张摄影作品🫣（just shot on the mobile device） 喜洲稻田 洱海午后 其他 I think this is the life, but august always slipped away into moment in time 🎯","link":"/posts/gallery-%E5%A4%A7%E7%90%86/"},{"title":"杂项","text":"highlight ​🈂️​ 2 1console.log('111')","link":"/posts/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Computer Network","slug":"Computer-Network","link":"/tags/Computer-Network/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"Preparation","slug":"Preparation","link":"/tags/Preparation/"},{"name":"new found","slug":"new-found","link":"/tags/new-found/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"utils","slug":"utils","link":"/tags/utils/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"enhanced","slug":"enhanced","link":"/tags/enhanced/"},{"name":"Interview","slug":"Interview","link":"/tags/Interview/"}],"categories":[{"name":"gallery","slug":"gallery","link":"/categories/gallery/"}]}