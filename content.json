{"pages":[{"title":"About Me","text":"","link":"/aboutme/index.html"},{"title":"brat","text":"","link":"/brat/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"自定义页面 body { font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; max-width: 800px; margin: 0 auto; } .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } h1 { color: #333; border-bottom: 2px solid #eee; padding-bottom: 10px; } 欢迎来到自定义页面 这是一个示例页面，您可以根据需要修改内容。","link":"/custom-page/index.html"},{"title":"My Friends","text":"","link":"/friendlinks/index.html"},{"title":"'tag'","text":"","link":"/tag/index.html"},{"title":"timer","text":"","link":"/timer/index.html"}],"posts":[{"title":"就让2025的思绪留在2025吧","text":"回想起来，2025的确是令我难忘的一年。我觉得自己今年成长了许多。 无论是个人形象上的改变，比如剪短了头发，开始健如身（健身房完全是一个高能量场所，我的快乐老家了，仅限ytc’lk）。 还是在情感方面，我经历了人生的初恋，体会到了那种心动的甜蜜，也体会到了分离时的痛苦。在这期间，我学会了用文字记录情感，梳理自己的情绪。其实2025的后半年，我的生活几乎都围绕着这段关系，直到最后我终于明白，感情需要双方共同经营，而不是一个人的付出和妥协。我也不想把自己包装成受害者角色，其实的确是两人不同频吧。我很珍视这段缘分，这段关系也真真实实地让我成长了很多。 (其实想说的话还有很多，剩下的那就留在我的笔记里，留在我的回忆里吧) 工作上，今年是我步入职场后第一个完整的年份。大部分时候感觉还算从容，遇到棘手的问题，静下心来理清思路，也都能解决。一年下来，自己也算是熟悉了工作的节奏。 关于友情，我意识到不必总是充当连接大家的那个人。有些友情本就是独立存在的，不需要我去刻意维系。 我也在学着不做一味讨好别人的人，不再习惯性地委屈自己。 今年，也去了很多地方，看了些许演出现场和电影，希望明年也可以继续这样开心地活着。 蒽，好像也没什么好说的了，好像也没点题。 那就最后，2026愿你我永远安康，永远懂得飞翔… 2025-12-30 22:58 就这样简简单单总结一下吧（往年貌似都没写过XD👊 以我的SOTY结束一下子，对了，别忘了打开🪜","link":"/posts/2025/"},{"title":"How to Develop AEM Components","text":"Prerequisites Understanding how to configure components are on AEM pages Basic front-end development skills, not limited to HTML, JavaScript, Vue.js [!TIP] Using the CLP project as an example The top level directory structure of an AEM project is roughly like this. Frontend component development mainly focuses on the ui.apps and ui.frontend directories: 1234567891011├── all├── core├── it.tests├── ui.apps├── ui.apps.structure├── ui.config├── ui.content├── ui.frontend├── ui.tests├── archetype.properties└── pom.xml ui.apps Component dialogs and metadata are defined in ui.apps In ui.apps/src/main/content/jcr_root/apps/clphk-postlogin/components, you can find declared AEM components. Their directory structure is: 1234├── _cq_dialog│ └── .content.xml ①├── .content.xml ②└── XXXXX.html 🔦 Define Component Dialog _cq_dialog folder defines the component dialog: The dialog pops up when clicking a component in the page editor for configuring component options. ①xml defines dialog structure including fields, labels, defaults etc. It follows JCR (Java Content Repository) to describe layout and functions. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;jcr:root xmlns:sling=&quot;http://sling.apache.org/jcr/sling/1.0&quot; xmlns:cq=&quot;http://www.day.com/jcr/cq/1.0&quot; xmlns:jcr=&quot;http://www.jcp.org/jcr/1.0&quot; xmlns:nt=&quot;http://www.jcp.org/jcr/nt/1.0&quot; jcr:primaryType=&quot;nt:unstructured&quot; sling:resourceType=&quot;cq/gui/components/authoring/dialog&quot; jcr:title=&quot;...DIALOG TITLE&quot;&gt; &lt;items jcr:primaryType=&quot;nt:unstructured&quot;&gt; &lt;tab1 jcr:primaryType=&quot;nt:unstructured&quot; sling:resourceType=&quot;cq/gui/components/authoring/dialog/tabpanel&quot; jcr:title=&quot;...TAB 1&quot;&gt; &lt;items jcr:primaryType=&quot;nt:unstructured&quot;&gt; &lt;field1 jcr:primaryType=&quot;nt:unstructured&quot; sling:resourceType=&quot;granite/ui/components/foundation/form/textfield&quot; fieldLabel=&quot;...FIELD 1&quot; name=&quot;./field1&quot;/&gt; &lt;!-- ...MORE FIELDS HERE --&gt; &lt;/items&gt; &lt;/tab1&gt; &lt;!-- ...MORE TABS HERE --&gt; &lt;/items&gt; &lt;/jcr:root&gt; 12345678910111213### 🔦 Define Component- ② xml file: - Defines AEM component metadata. - ```xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;jcr:root xmlns:cq=&quot;http://www.day.com/jcr/cq/1.0&quot; xmlns:jcr=&quot;http://www.jcp.org/jcr/1.0&quot; jcr:primaryType=&quot;cq:Component&quot; jcr:title=&quot;CLP Eco Feed Vertical&quot; // Component title componentGroup=&quot;CLP HK PostLogin - Develop&quot;/&gt; // Component group 🔦 Define Component Template Reference The HTML file uses HTL (HTML Template Language) to render custom components in AEM pages (In this project, use Vue.js for joint development). 123456789101112&lt;sly data-sly-use.templates=&quot;core/wcm/components/commons/v1/templates.html&quot; data-sly-set.hasContent=&quot;${false}&quot; /&gt;&lt;!-- aquire modal data --&gt;&lt;sly data-sly-use.clpecofeed=&quot;com.clp.clphkpostlogin.core.models.CLPEcoFeed&quot;&gt;&lt;/sly&gt;&lt;div data-dom&gt; &lt;!-- properties is defined by dialog data --&gt; &lt;VUE-COMPONENT props1=&quot;${properties.modeltype}&quot; props2=&quot;${clpecofeed}&quot;&gt;&lt;/VUE-COMPONENT&gt; &lt;!-- in Vue SFC, can get the properties from the `prop` --&gt;&lt;/div&gt;&lt;sly data-sly-call=&quot;${templates.placeholder @ isEmpty=!hasContent}&quot;&gt;&lt;/sly&gt; ui.frontend ui.frontend is built with webpack + Vue in this project 🔦 Write SFC (Single File Component) Write Vue components in ui.frontend/src/main/webpack/vue/components (Please ensure to define name attribute for reference in AEM). componnents directory structure 12345678- _register - common # common components - components aem components - elementui elementui components- common- components match aem naming- utils common js libs- main.js entry Notes: Register needed Element UI components in _register/elementui. Register new AEM components in _register/components. AEM components can use registered Element UI and common components. 🔦 Register Components Export Vue components in ui.frontend/src/main/webpack/vue/_register/component for main.js to import and mount with createApp.component(). 💡 Preview Components Please configre the component on AEM page before Preview Components For independent components [!TIP] independent components refers to to a component that is developed and previewed standalone, without associations with other components. For example, no need to navigate to other components or pages. No need to bundle the entire ui.frontend. Mount defined component in ui.frontend/src/main/webpack/templates/local.html: &lt;div id=&quot;localApp&quot; class=&quot;dtt-uf dtt-uf-vc dtt-uf-dc&quot;&gt; &lt;div class=&quot;dtt-uf&quot;&gt; &lt;div data-dom&gt; &lt;CustomComponent /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Run npm run local and open browser to preview this component. “local”: “cross-env VUE_APP_MY_ENV=local webpack-dev-server --open --config ./webpack.local.js” For associated components [!TIP] Need to bundle the entire ui.frontend. Option 1: Maven build Universal but Time-Consuming Solutions In project directoty, run mvn clean install -PautoInstallSinglePackage. Then preview in AEM system. Production environment For debug logs during development: ​ Comment out Terser plugin in webpack prod config that removes console.log. ​ Or use window.console.log. Option 2: AEM Sync plugin in VsCode Install AEM Sync plugin in VsCode. In ui.frontend directoty, run npm run dev. Plugin will sync build to AEM. Preview in launched server. “dev”: “webpack -d --env dev --config ./webpack.dev.js &amp;&amp; clientlib --verbose” Development environment","link":"/posts/AEM-dev/"},{"title":"AEM","text":"AEM - Adobe Experience Manager","link":"/posts/AEM/"},{"title":"CSS只显示两行","text":"-webkit-line-clamp CSS 属性可以把块容器中的内容限制为指定的行数。 它只有在 display 属性设置成 -webkit-box 或者 -webkit-inline-box 并且 box-orient 属性设置成 vertical时才有效果。 在大部分情况下，也需要设置 overflow 属性为 hidden，否则，里面的内容不会被裁减，并且在内容显示为指定行数后还会显示省略号。 12345678{ overflow: hidden; display: -webkit-box; text-overflow: ellipsis; -webkit-line-clamp: 2; /* 两行 */ -webkit-box-orient: vertical; word-break: break-all;} 效果 💡 其中， word-break 指定了怎样在单词内断行， 这里 break-all 将单词截断换行，由于这里只能显示 2 行，所以出现图中效果","link":"/posts/CSS%E5%8F%AA%E6%98%BE%E7%A4%BA%E4%B8%A4%E8%A1%8C/"},{"title":"Cookie & Session","text":"HTTP无状态（一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接），引入cookie 、session维持和跟踪用户状态。 Session ​ 用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId ​ cookie每次请求都把SessionId自动带到服务器 ​ 当一个用户提交了表单时，浏览器会将用户的SessionId自动附加在HTTP头信息中，（这是浏览器的自动功能，用户不会察觉到），当服务器处理完这个表单后，将结果返回给SessionId所对应的用户。 存储位置不同: Cookie数据存放在客户的浏览器上 Session数据放在服务器上 安全性不同: Cookie不是很安全,别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 Session存放在服务器上,比较安全 大小限制不同: Cookie大小有限制,最大4K左右 Session大小一般可设置1M到几十M,根据服务器的内存大小而定 有效期不同: Cookie的有效期需要程序员自己设置 Session的有效期默认到浏览器关闭时失效 作用范围不同: Cookie被客户端记录,每次请求时都会携带,对于服务器请求数量多的情况下会增加请求数据量 Session只保存在服务器端,不会增加请求数据量 实现机制不同: Cookie通过检查客户浏览器的cookie来确定客户身份 Session通过给客户浏览器分配一个特定的ID来识别客户身份。服务器通过匹配session ID来管理session graph TD A[客户端发起请求] --> B{请求是否包含sessionId?} B -- 包含 --> C[使用已存在的Session] B -- 不包含 --> D[创建一个新的Session] D --> E[生成一个唯一的sessionId] D --> F[为Session分配资源] E --> G[将sessionId返回给客户端] G --> H[客户端保存sessionId] C --> I[使用已存在的Session资源] I --> J[处理请求] J --> K[响应请求] K --> L[结束] F --> L[结束]","link":"/posts/CookieSession/"},{"title":"Create-React-App项目Template","text":"💡项目地址 123456789101112├── .husky├── .vscode├── public├── src│ ├── App.tsx│ ├── index.tsx│ └── react-app-env.d.ts├── prettier.config.js├── tsconfig.json├── package.json└── yarn.lock├── README.md 初始化项目 ​ yarn add create-react-app [app-name] --template typescript prettier ​ yarn add -D prettier 12345678910111213//prettier.config.jsmodule.exports = { semi: false, // 在每条语句的末尾不使用分号 trailingComma: 'es5', // 允许在ES5中有效的尾随逗号 singleQuote: true, // 使用单引号而不是双引号 printWidth: 80, // 指定打印行的最大长度 tabWidth: 3, // 设置每个缩进级别的空格数 useTabs: false, // 使用空格而不是制表符进行缩进 bracketSpacing: true, // 在对象字面量中添加空格 jsxBracketSameLine: false, // 在JSX中把'&gt;'放在最后一行的末尾 arrowParens: 'avoid', // 当箭头函数只有一个参数时不使用圆括号 endOfLine: 'lf', // 行尾序列使用LF（\\n）} husky ​ yarn add -D husky 1234//package.json&quot;scripts&quot;: { &quot;prettier&quot;: &quot;prettier --write \\&quot;src/**/*.{js,jsx,ts,tsx,json,css,scss,md}\\&quot;&quot;} ​ 启用 Git 钩子： npx husky install ​ 添加 pre-commit 钩子：npx husky add .husky/pre-commit &quot;yarn prettier&quot; 路径别名 1234567&quot;compilerOptions&quot;: { // ...其他配置... &quot;baseUrl&quot;: &quot;src&quot;, &quot;paths&quot;: { &quot;@/*&quot;: [&quot;*&quot;] }} 静候补充...","link":"/posts/Create-React-App%E9%A1%B9%E7%9B%AETemplate/"},{"title":"JS类型转换","text":"JS是动态类型语言，我们在定义一个变量其实并没有指定这个变量到底属于那种类型，只有到程序执行阶段才确定当前数据类型。 而各种运算符对数据类型是有要求的，所以就会触发类型转换机制（no matter 人为 or 隐式触发） 显示转换： ​ 通过JS内置的函数明确转换的数据类型 Number parseInt(string, ?进制) 比Number宽松，一位一位解析遇到不能解析的停止 String Boolean 隐式转换： ​ 运算操作符两边数据类型不一致（比较运算符、算术运算符） 转为Boolean (需要布尔值的地方，借助的Boolean()函数) falsely变量：undefined、null、false、+/-0、NAN、&quot;&quot; 转为String （复合类型—&gt;原始类型----&gt;字符串） 常发生在，如 &quot;5&quot; + xxx 的加法运算中 转为Number 除了加法运算符号，其他都有可能 other === 在不进行类型转换情况下，双方的类型与值都相等","link":"/posts/JS%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"title":"Event Loop","text":"JS单线程，为了不阻塞线程，很多代码通过回调的方式异步执行 JS代码执行顺序被打乱，就需要一种机制–事件循环，协调各个事件的执行顺序 浏览器 同步代码，一行一行在Call Stack中执行（压栈弹栈） 遇到异步代码，记录下代码，等时机到了将代码入队Callback Queue中 当同步代码执行为空，Call Stack为空，Event Loop开始工作 Event Loop轮询查找Callback Queue中是否有可执行代码 有，将代码送入Call Stack执行 没有，将继续轮询查找 调用栈为空触发Event Loop执行先后顺序：微任务、DOM渲染、宏任务 微任务： Promise, async/await 宏任务： 定时器、Ajax、DOM事件 Node Node异步API 定时器 I/O操作 node独有 setTimeoutsetInterval 文件读写数据库操作网络请求… process.nextTicksetImmediate 设计上，事件循环优先处理执行I/O事件 process.nextTick不属于事件循环一部分，优先于事件循环执行 从Timer到Check为一个Tick setImediate(()=&gt;{})、与setTimeout(()=&gt;{}, 0) 中执行时机不确定？ setTimeout(, 0) —&gt; 浏览器 4ms, node 1ms 解决： 将两者放在I/O操作回调中，能保证setImmediate回调先执行","link":"/posts/EventLoop/"},{"title":"RENEW-vue2","text":"1. 关于生命周期 1.1 生命周期有哪些？发送请求在created还是mounted？ 1请求接口测试：https://fcm.52kfw.cn/index.php?_mall_id=1&amp;r=api/default/district Vue2.x系统自带有8个 12345678beforeCreatecreatedbeforeMountmountedbeforeUpdateupdated // DOM 已经更新beforeDestroy // 实例还在，进行清理任务，比如清除计时器、解绑全局事件监听器destroyed 发送请求在created还是mounted？ 1这个问题具体要看项目和业务的情况了，因为组件的加载顺序是，父组件引入了子组件，那么先执行父的前3个生命周期，再执行子的前4个生命周期，那么如果我们的业务是父组件引入子组件，并且==优先加载子组件==的数据，那么在父组件中当前的请求要放=mounted=中，如果当前组件没有依赖关系那么放在哪个生命周期中请求都是可以的。 生命周期：先执行 父前三，在执行子元素前四 如果优先加载子组件的数据，就放在mounted中发送请求 ，确保子组件优先挂载 1.2 为什么发送请求不在beforeCreate里？beforeCreate和created有什么区别？ 为什么发送请求不在beforeCreate里？ 拿不到methods方法（如果请求封装在methods中） 1因为：如果请求是在methods封装好了，在beforeCreate调用的时候，beforeCreate阶段是拿不到methods里面的方法的（会报错了）。 beforeCreate和created有什么区别？ 拿不拿得到$data与methods 12345beforeCreate没有$datacreated中有$datacreated是可以拿到methods的方法的beforeCreate拿不到methods的方法 1.3 在created中如何获取dom 异步获取 1231. 只要写异步代码，获取dom是在异步中获取的，就可以了。 例如：setTimeout、请求、Promise.xxx()等等...2. 使用vue系统内置的this.$nextTick 1.4 一旦进入组件会执行哪些生命周期？ 进入组件，组件已经挂载 1234beforeCreatecreatedbeforeMountmounted 1.5 第二次或者第N次进去组件会执行哪些生命周期？ 看是否缓存了组件 如果当前组件加入了keep-alive，只会执行一个生命周期 1activated 如果没有加入keep-alive 1234beforeCreatecreatedbeforeMountmounted 1.6 父组件引入子组件，那么生命周期执行的顺序是？ 父三 子四 1234父：beforeCreate、created、beforeMount子：beforeCreate、created、beforeMount、mounted...父：mounted 1.7 加入keep-alive会执行哪些生命周期？ 如果使用了keep-alive组件，当前的组件会额外增加2个生命周期（系统8 + 2 ） 12activateddeactivated 如果当前组件加入了keep-alive第一次进入这个组件会执行5个生命周期 12345beforeCreatecreatedbeforeMountmountedactivated 1.8 你在什么情况下用过哪些生命周期？说一说生命周期使用场景 activated 中重新刷新数据 ， 因为使用了缓存组件，后续进入该组件只会运行这一个生命周期 deacticated 清理定时器相关的 1234created ===&gt; 单组件请求mounted ===&gt; 同步可以获取dom，如果先子组件请求后父组件请求activated ===&gt; 判断id是否相等，如果不相同发起请求destroyed ===&gt; 关闭页面记录视频播放的时间,初始化的时候从上一次的历史开始播放 2. 关于组件 父 -&gt; 子 props、this.$parent.xxx(子元素可以直接修改父元素数据)、依赖注入（在配置主题颜色 react中的context上下文 provider） 子 -&gt; 父 自定义事件emit、$refs 兄弟元素： eventbus （发布订阅模式） 集中状态管理 vuex pinia 2.1 组件传值（通信）的方式 12345678910111213141516171819父传后代 ( 后代拿到了父的数据 )1. 父组件引入子组件，绑定数据 &lt;List :str1='str1'&gt;&lt;/List&gt; 子组件通过props来接收 props:{ str1:{ type:String, default:'' } } ***这种方式父传子很方便，但是父传给孙子辈分的组件就很麻烦（父=》子=》孙） 这种方式：子不能直接修改父组件的数据2. 子组件直接使用父组件的数据 子组件通过：this.$parent.xxx使用父组件的数据 这种方式：子可以直接修改父组件的数据 3. 依赖注入 优势：父组件可以直接向某个后代组件传值(不让一级一级的传递) 123456后代传父 （父拿到了后代的数据）1. 子组件传值给父组件 子组件定义自定义事件 this.$emit2. 父组件直接拿到子组件的数据 &lt;List ref='child'&gt;&lt;/List&gt; this.$refs.child 123平辈之间的传值 ( 兄弟可以拿到数据 ) 通过新建bus.js文件来做 2.2 父组件如何直接修改子组件的值 12&lt;List ref='child'&gt;&lt;/List&gt;this.$refs.child.xxx = 'yyyy'; 2.3 子组件如何直接修改父组件的值 1子组件中可以使用：this.$parent.xxx去修改 2.4 如何找到父组件 1this.$parent 2.5 如何找到根组件 1this.$root 2.6 keep-alive 1keep-alive是什么 ： 缓存当前组件 2.7 slot/插槽 1匿名插槽 ：插槽没有名字 1具名插槽 ：插槽有名字 1作用域插槽 ： 传值 2.8 provide/inject 1provide/inject ===&gt; 依赖注入 2.9 如何封装组件 1组件一定要难点，涉及的知识点：slot、组件通信... 3. 关于Vuex 3.1 Vuex有哪些属性 12345state ==&gt; 全局共享属性getters ==&gt; 针对于state数据进行二次计算mutatioins ==&gt; 存放同步方法的actions ==&gt; 存放异步方法的，并且是来提交mutationsmodules ==&gt; 把vuex再次进行模块之间的划分 3.2 Vuex使用state值 1this.$store.state.xxx 1辅助函数：mapState 以上俩种方式都可以拿到state的值，那么区别是什么？ 123使用this.$store.state.xxx是可以直接修改vuex的state数据的使用辅助函数的形式，是不可以修改的 3.3 Vuex的getters值修改 面试官可能会这样问：组件使用了getters中的内容，组件使用采用v-model的形式会发生什么？ 1getters是不可以修改的 3.4 Vuex的mutations和actions区别 1相同点：mutations和actions都是来存放全局方法的，这个全局方法return的值拿不到 12345区别： mutations ==》 同步 actions ==》 返回的是一个Promise对象，他可以执行相关异步操作 mutations是来修改state的值的，actions的作用是来提交mutations 3.5 Vuex持久化存储 ：在页面使用了state值：1，然后把1修改成2，然后刷新页面又回到了1为什么？ 我用的pinia state在LS，读取时getItem，修改时setItem 1Vuex本身不是持久化存储的数据。Vuex是一个状态管理仓库（state：全局属性）==》就是存放全局属性的地方。 1实现持久化存储：1. 自己写localStorage 2. 使用vuex-persistedstate插件 1插件使用方式：https://www.xuexiluxian.cn/blog/detail/dae4073b07144d3c9abb3e2cc8495922 4. 关于路由 4.1 路由的模式和区别 history 使用HTML5 的history API, pushState(state, title, url) popstate replacestate hash检测浏览器url hash值 , 浏览器并不会因为hash值的改变而作响应向服务器发送请求，而是有vuerouter控制客户端作相应的响应，利用onhashchange（window.location.hash） 同一页面内的不同位置标记 hash 服务器只需要返回入口页面（通常是 index.html）, 而后面一切都是由vuerouter在客户端渲染完成的 history 需要在后端额外配置请求的uri地址 1路由的模式：history、hash 123456789区别：1. 关于找不到当前页面发送请求的问题 history会给后端发送一次请求而hash不会2. 关于项目打包前端自测问题 hash是可以看到内容的 history默认情况是看不到内容的3. 关于表象不同 hash:# history:/ 4.2 子路由和动态路由 动态路由 /user/:id 占位 4.3 路由传值 query 和 params 两种 4.4 导航故障 可以catch捕获，isNavigationFailure 给出相关提示 1官网说明：https://v3.router.vuejs.org/zh/guide/advanced/navigation-failures.html#%E6%A3%80%E6%B5%8B%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C 解决： $router.push跳转到一个相同的路由报错 重写push方法 12345import VueRouter from 'vue-router'const routerPush = VueRouter.prototype.pushVueRouter.prototype.push = function (location) { return routerPush.call(this, location).catch(error =&gt; error)} 4.5 router和router和router和route区别 123$router不仅包含当前路由还包含 ==整个路由的属性和方法==$route包含==当前==路由对象 4.6 导航守卫 beforeResolve 所有组件内守卫和异步路由组件被解析之后，而在导航被最终确认之前。 提供了一个最后的机会来取消或修改即将发生的路由跳转。 （权限 12345678910111213141. 全局守卫 beforeEach 路由进入之前 afterEach 路由进入之后2. 路由独享守卫 beforeEnter 路由进入之前3. 组件内守卫 beforeRouteEnter 路由进入之前 beforeRouteUpdate 路由更新之前 beforeRouteLeave 路由离开之前 5. 关于API 5.1 $set 给响应式对象添加新属性 响应式数组对象不能直接通过修改索引的方式修改数据 ， 利相关方法push pop shift unshift splice sort reverse，更改length 1面试官：你有没有碰到过，数据更新视图没有更新的问题==》$set 1this.$set(target,key,修改后的值) 5.2 $nextTick 在写单元测试的时候使用过，因为要获取当前最新的DOM，返回promise 数据更新导致视图变化，（给这个DOM添加动画 DOM是异步更新的，确保获取最新的DOM借助nexttick 12345678$nextTick返回的参数[函数]，是一个异步的。功能：==获取更新后的dom==源码|原理：$nextTick( callback ){ return Promise.resolve().then(()=&gt;{ callback(); })} 5.3 $refs 1来获取dom的 5.4 $el 1$el 获取当前组件的根节点 5.5 $data 1$data 获取当前组件data数据的 5.6 $children 1$children 获取到当前组件的所有子组件的 5.7 $parent 1找到当前组件的父组件，如果找不到返回自身 5.8 $root 1找到根组件 5.9 data定义数据 1234数据定义在data的return内和return外的区别：1. return外：单纯修改这个数据是不可以修改的，因为没有被get/set2. reutnr内：是可以修改的 5.10 computed计算属性 getter setter写法 123computed计算属性的结果值，可以修改吗？可以的，需要通过get/set写法当前组件v-model绑定的值是computed来的，那么可以修改吗？可以的，需要通过get/set写法 5.11 watch 可以在其中执行异步方法，但是要注意trycatch捕获处理异常 在组件销毁时清理watch，返回一个销毁函数 123456789watch:{ obj:{ handler(newVal,oldVal){ console.log( 'obj',newVal , oldVal ) }, immediate:true, deep:true },} 5.12 methods和computed区别 1computed是有缓存机制的，methods是没有缓存机制的（调用几次执行几次） 6. 关于指令 6.1 如何自定义指令 组件权限管理 123456全局：Vue.directive('demo', { inserted: function (a,b,c) { console.log( a,b,c ); }}) 123456789101112局部：&lt;script&gt;export default { directives: { demo: { bind: function (el) { console.log( 1 ) } } }}&lt;/script&gt; 6.2 vue单项绑定 1双向绑定：v-model 1单项绑定：v-bind 6.3 v-if和v-for优先级 同时作用在一个元素上，浪费性能，我们其实只想渲染出list其中符合条件的item，事实上我们却把每条item都遍历了一遍 所以我们应该在vfor之前过滤filter Vue2 ​ 利用computed重新生成数组 Vue3 虽说可以同时使用，但是，vif优先级高，可能不能及时获取到当前的item导致错误 ​ 借助vfor template标签 12345&lt;template v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt; &lt;li v-if=&quot;item.show&quot;&gt; {{ item.name }} &lt;/li&gt;&lt;/template&gt; 1vue2中：v-for &gt; v-if 1vue3中：v-if &gt; v-for 7. 关于原理 7.1 $nextTick原理 1$nextTick功能：获取更新后的dom 1234567$nextTick( callback ){ return Promise.resolve().then(()=&gt;{ callback(); }) } 7.2 双向绑定原理 双向绑定就是 数据与视图 UI 控件的变化能自动更新数据模型 vmodel 语法糖，vbind绑定在监听@input or @change事件做出改变 响应式 数据劫持： 当对数据进行取值操作的时候，就会对这个数据进行依赖收集，当这个数据发生改变的时候，就会触发视图更新，刷新页面。 在get中进行depend依赖收集，在set中进行notify通知依赖的watcher去重新渲染（视图更新） Object.defineProperty这个api存在着一些问题，比如必须要深层次递归监听一个对象内所有的属性，性能并不太好，并且不能监听数组的length改变 数据代理 （复制一份） ​ Vue 在组件实例上通过 this 提供对组件数据的直接访问。这是通过将 data 对象中的属性代理到 Vue 实例上实现的。这样，你可以通过 this.propertyName 直接访问数据，而不是 this.data.propertyName 12345678910Object.keys(vm.$data).forEach(key=&gt;{ Object.defineProperty(vm, key, { get() { return vm.$data[key]; }, set(newVal) { vm.$data[key] = newVal; } })})","link":"/posts/RENEW-vue2/"},{"title":"FUNNY_ERROR","text":"1、immediate 写错位置 哭晕 123456789101112131415161718const reCompolist = ref([])watch( () =&gt; props.list, () =&gt; { ;(reCompolist.value as any) = props.list.map( (row) =&gt; { const newRow: Record&lt;string, any&gt; = {} props.labels.forEach(([key, _]) =&gt; { newRow[key] = row[key] }) return newRow }, { immediate: true, } ) })","link":"/posts/FUNNY-ERROR/"},{"title":"GPTPlus速通","text":"","link":"/posts/GPTPlus%E9%80%9F%E9%80%9A/"},{"title":"TCP","text":"在不可靠的网络链路中，进行可靠的链接/断开 全双工（Full Duplex） 双向传输:TCP连接的两端都可以同时发送和接收数据包。 双向流量控制:发送方和接收方都可以通过滑动窗口机制控制数据流量,防止对方缓冲区溢出。 双向确认:发送的数据包可以得到对方的确认应答ACK。接收方也可以通过ACK告知发送方自己已经正确接收了数据。 双向重传:如果任意一方没有收到确认或数据包丢失,都可以触发重传机制,直到数据正确发送。 全双工通信:TCP的全双工特性使得双方可以同时进行发言而不会相互干扰,就像电话通话一样。 ACK 和FIN 是 TCP 协议中两个重要的控制标志(control flag) ACK(Acknowledgement) 确认号，表示确认号,确认接收端已正确接收到前面的数据 FIN (Finish) 结束标志，表示发送端已经发送完数据,可以关闭连接了。 三次握手🤝 传输 一包数据可能被拆为多包数据发送 丢包问题？乱序问题？ TCP为每个链接建立了一个发送缓冲区 一问一答的方式发送接收（发送端一次也可以发送多包数据，接收端只用回复一次ACK） 发送端可以切割发送，接收端利用序列号和长度重组出完整的数据 丢失了某个数据包，接收端可以要求发送端重传。 接收端向发送端发送ACK=xxx，发送端重传，接收端收到再补齐数据 四次挥手👋🏻 这里以客户端取消l为例 Client等待一段时间，目的为了确保ACK成功发送给Server，否则Server重新发送FIN给client，再重新执行","link":"/posts/TCP/"},{"title":"Volta node版本管理","text":"volta 试了多种node版本工具nvm fnm，都没有成功下在离线状态下托管本地node包 快速安装管理和切换不同版本的node、npm、yarn等的工具 离线管理不同版本的node（Windows） 1. 下载安装volta https://github.com/volta-cli/volta/releases/download/v2.0.1/volta-2.0.1-windows-x86_64.msi 2. 导入本地node预构二进制文件压缩包 将Windows的 node zip包放在C:\\Users\\{用户}\\AppData\\Local\\Volta\\tools\\inventory\\node文件夹中 到这一步volta还没有托管手动导入的node包，需要手动挂载到全局或者项目中，才能正常使用 3. 托管本地node包（切换node版本也是这流程） 全局级别 volta install node@&lt;version&gt; 项目级别 进入项目根目录终端，volta pin node@&lt;version&gt; volta将托管导出进来的node包，并在文件夹下生成一个node-v版本号-npm文件 查看当前托管的node版本 volta list node","link":"/posts/Volta-node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"title":"angular-ng","text":"Angualr 组件模式 AMD scope 00 ng-app 指令表明这个 html 文件为 angular 模板文件解析 使用 ngApp 指令自动引导 AngularJS 应用程序非常简单，并且适合大多数情况。在高级情况下，例如使用脚本加载器时，您可以使用命令/手动方式来引导应用程序。 The injector that will be used for dependency injection is created. 创建将用于依赖注入的注入器。 The injector will then create the root scope that will become the context for the model of our application. 然后，注入器将创建根范围，该范围将成为我们应用程序模型的上下文。 AngularJS will then “compile” the DOM starting at the ngApp root element, processing any directives and bindings found along the way. 然后，AngularJS 将从 ngApp 根元素开始“编译”DOM，处理沿途发现的任何指令和绑定。 Added phone images to app/img/phones/. 将手机图像添加到 app/img/phones/ 。 Added phone data files (JSON) to app/phones/. 将电话数据文件 (JSON) 添加到 app/phones/ 。 01 控制器 简单理解就是在控制器中写页面处理逻辑 02 组件 ​ 由于这种组合（模板 + 控制器）是一种常见且重复出现的模式，因此 AngularJS 提供了一种简单而简洁的方法将它们组合成可重用且独立的实体（称为组件）。此外，AngularJS 将为我们组件的每个实例创建一个所谓的隔离范围，这意味着没有原型继承，并且我们的组件没有影响应用程序其他部分的风险，反之亦然。 ​ 事实上，人们可以将组件视为其更复杂、更冗长（但功能更强大）的同级指令（指令）的固执己见和精简版本，指令是 AngularJS 教授 HTML 新技巧的方式。您可以在开发人员指南的指令部分阅读有关它们的所有内容。 海云项目还没用到 component， 04 分文件编写 加载顺序 在分文件编写的时候发现模块加载顺序很重要 05 filter 12345678910111213141516171819&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-2&quot;&gt; &lt;!--Sidebar content--&gt; Search: &lt;input ng-model=&quot;$ctrl.query&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;col-md-10&quot;&gt; &lt;!--Body content--&gt; &lt;ul class=&quot;phones&quot;&gt; &lt;li ng-repeat=&quot;phone in $ctrl.phones | filter:$ctrl.query&quot;&gt; &lt;span&gt;{{phone.name}}&lt;/span&gt; &lt;p&gt;{{phone.snippet}}&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 06 双向数据绑定 vue 的 v-model 1&lt;input type=&quot;text&quot; ng-model=&quot;$ctrl.test&quot; /&gt; &lt;strong&gt;{{$ctrl.test}}&lt;/strong&gt; 07 依赖注入 DI subsystem 在控制器中使用“服务” 服务以$ 开头，$$被认为是私有的 给某个 controller 注入内置$http服务 1234function PhoneListController($http) {...}PhoneListController.$inject = ['$http'];....component('phoneList', {..., controller: PhoneListController}); 内联写法 123function PhoneListController($http) {...}....component('phoneList', {..., controller: ['$http', PhoneListController]}); 08 templating and links ngSrc 指令可防止浏览器向无效位置发出 HTTP 请求 09 Routing and Mutiple Views Angular-route : npm i angular-route 注入$routeProvider 提供路由服务 12345678910111213angular.module(&quot;phonecatApp&quot;).config([ &quot;$routeProvider&quot;, function config($routeProvider) { $routeProvider .when(&quot;/phones&quot;, { template: &quot;&lt;phone-list&gt;&lt;/phone-list&gt;&quot;, }) .when(&quot;/phones/:phoneId&quot;, { template: &quot;&lt;phone-detail&gt;&lt;/phone-detail&gt;&quot;, }) .otherwise(&quot;/phones&quot;) },]) 配合 ng-view 指令 （类似 vuerouter 的&lt;router-view/&gt;） AngularJS（默认情况下）使用 URL 的哈希部分（即哈希 ( # ) 符号后面的内容）来确定当前路由。除此之外，你还可以指定一个散列前缀（默认为 ! ），它需要出现在散列符号之后，以便 AngularJS 将该值视为“AngularJS 路径”并处理它（例如例如，尝试将其与路线匹配）[Using location](https://docs.angularjs.org/guide/location](https://docs.angularjs.org/guide/location](https://docs.angularjs.org/guide/location) phoneDetail 模块依赖于 ngRoute 模块来提供 $routeParams 对象，该对象在 phoneDetail 组件的控制器中使用。由于 ngRoute 也是主 phonecatApp 模块的依赖项，因此其服务和指令已在应用程序中的任何位置可用（包括 phoneDetail 组件）。 始终明确子模块的依赖关系。不要依赖从父模块继承的依赖项（因为有一天该父模块可能不存在）。 11 自定义过滤器 由于此过滤器是通用的（即它不特定于任何视图或组件），因此我们将其注册到 core 模块中，该模块包含“应用程序范围”功 12345'use strict';// Define the `core` moduleangular.module('core', []); 12angular. module('core'). filter('checkmark', function() { return function(input){ return input ? '\\u2713' : '\\u2718'; }; }); 模版中直接使用 {{ true | checkmark }} 13 rest 和 定制服务 使用 $resource 工厂来定义一个资源服务，这个服务可以用来与后端进行 RESTful 交互 angular.directive 指令 在 AngularJS 中，restrict 属性用于指定指令可以在模板中以哪种方式使用。restrict 属性可以接受以下参数： ‘E’ (Element)： 指令作为元素使用。 1&lt;my-directive&gt;&lt;/my-directive&gt; ‘A’ (Attribute)： 指令作为属性使用。 1&lt;div my-directive&gt;&lt;/div&gt; ‘C’ (Class)： 指令作为类使用。 1&lt;div class=&quot;my-directive&quot;&gt;&lt;/div&gt; ‘M’ (Comment)： 指令作为注释使用。 1&lt;!-- directive: my-directive --&gt; 组合使用 可以组合使用多个参数，例如 ‘EA’ 表示指令可以作为元素和属性使用。 1234567.directive('myDirective', function() { return {​ restrict: 'EA',​ // 其他配置 };}); angular.factory .factory 是一个常用的方式来创建并返回一个服务的单例。.factory 方法用于封装业务逻辑或 API 服务，并在整个应用中共享。","link":"/posts/angular-ng/"},{"title":"SUMMARY","text":"01 数据类型 基本数据类型： Null typeof null 等于 object Undefined Let var 声明未初始化值为 undefined Boolean falsely=== null undefined 0 '' NaN Number 10 进制 1 8 进制 0 开头 070 16 进制 0x 开头 0x1 浮点数 包含小数点 1.1 1.0 .1 3.14e10 科学计数法 NaN 不是数值 Object.is(NaN,NaN) 返回true String Symbol （栈）值类型：String 、Number、 Boolean、 Symbol （堆）引用类型：object{}、 Array、 null、function 02 数组方法 splice 增(return []) 删return删除数组 改return[] 不影响原数组 splice(initIndex, deleteNum, InsertElement) 返回数组 slice (from, to) 截取数组，不会影响原数组，返回新数组 增 push() 尾部增加 返货数组新长度 unshift 首部增加 返回数组新长度 concat(“yellow”, [“red”, “green”]) 不会改变原数组 删 pop() 返回删除元素 shift 返回删除元素 查 indexOf() 返回元素所在索引，没有返回-1 includes() 返回 true/false find 返回第一个查找元素, 没有返回 undefined (finnIndex、findLast、findLastIndex） 排序方法： sort(?compareFn) —toSorted reverse --toReverse 转换 join(?separator) 转为由分隔符分隔的字符串 迭代 （都有 thisArg 形参，更改回调函数体内 this 指向，但是直接使用箭头函数 this 仍指向上一层 this） some() 某一个符合条件 true，every 全部符合条件 true forEach、filter、map 03 字符串方法 增 (返回副本) + ${} concat() 删（返回副本） slice(startIndex, endIndex)(与 substring 差不多，但 substring 不支持负数索引，start &gt; end 交换索引) substr(startIndex, length) 改 trim、trimLeft/Right 删空格 repeat(count) 重复几次这个字符串 padStart/End(maxLength, ?fillString) 不符合 maxLength 就长度填充， 默认填充空格 查 charAt(index) 根据索引返回元素，没有返回空串 indexOf startWith include 查找返回 true/false 转换方法 split() 字符串转数组 模板匹配 match(whichpattern) search replace(originString, replaceString) (reg, function(match, …)) 04 AJAX Ajax 允许我们利用 js 和 xmlHttpRequest 在后台与服务器交换数据 允许我们不用刷新网页，与后端交换数据，局部更新部分网页 通过 XmlHttpRequest 向服务器发送异步请求，从服务器获得数据，利用 js 操作 dom 更新页面 123456789101112131415//1. 创建xhr对象实例const xhr = new XMLHttpRequest()//与服务器创建连接xhr.open(&quot;GET&quot;, true)//给服务端发送数据xhr.send()//接受服务端数据相应xhr.onreadystatechange = function () { if (xhr.readyState === 4) { //done 整个过程请求完成 if (xhr.status &gt;= 200 &amp;&amp; shr.status &lt;= 300) { console.log(xhr.responseText) } }} 05 数据传输 multipart/form-data 可以传输二进制文件 application/x-www-form-urlencoded 用于传输普通的表单数据, application/json 用于传输 JSON 对象, 二者都不会传输文件,主要传输字符串、数字类型的数据。 12345678910111213141516function upload(url, Form) { // FormData格式提交给后端 const params = new FormData() for (let i in Form) { params.append(i, Form[i]) } //这里使用了 params.append(name, value) 方法,将字段名和值添加到 FormData 对象中。 return axios .post(url, params, { headers: { &quot;Content-Type&quot;: &quot;multipart/form-data&quot;, }, }) .then((res) =&gt; res.data)} 06 URL To Browser url 协议 + 域名 + 资源名(目录名/文件名) DNS 解析 找缓存- 浏览器 操作系统 本地 host 没有缓存 向域名服务器发送请求(dig +trace baidu.com) 根域名 . 顶级域名 .com 权威域名 baidu.com 发送网络请求 建立 TCP 链接 三次握手 发送 HTTP 请求 options 请求，在其他请求之前发送 post 请求格式为 application/json 格式才会触发 options 触发 options 跨域，options 请求预先检测 自定义请求头 浏览器缓存 强缓存 浏览器强制缓存服务端的数据（静态资源） res.setHeader('Cache-Control', 'max-age=10')或者设置 res.setheader(expires GMT时间)) form disk cahce 磁盘缓存服务端的资源 from memory cache 内存缓存服务端资源 ，多次刷新，就读内存里的 协商缓存 Last-Modified GMT 时间 最后更改时间 if-Modified-Since 如果前后时间(或 xxx 字段)是一致的那么就代表资源没有改变，后端返回 304， 变了代表资源改变，后端返回新的资源，返回 200 ETAG:‘xxx’ (文件 hash，or 版本号) 唯一标识符，用于标识特定版本的资源 if-None-Match TCP 断链 4 次挥手 HTML 渲染 html 解析器 解析标签为 DOM 树 样式计算 渲染引擎格式化计算 css 样式(rem-&gt;px bold-&gt;700…) CSSOM 构建 回流 计算得到几何信息、大小 触发回流 首次渲染 resize 跟大小宽高有关的改变 hover js 获取 clientWidth 重绘 元素样式的改变并不影响它在文档流中的位置(color backgoroung-color,visibility)，浏览器将新样式给他并重新绘制 GPU 渲染 v8 解析 js 渲染树？？ 07 TCP HTTP OSI 七层 应用层 （应用进程之间的交互规则） 万维网 HTTP 邮件 SMTP 域名系统 DNS 表示层 （通信的应用程序能够解释交换数据的含义） 会话层 （建立、管理和终止表示层实体之间的通信会话） 传输层 （为进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他）TCP UDP 网络层 （选择合适的网间路由和交换节点，确保数据按时成功传送） 数字链路层 （两台主机之间的数据传输，总是在一段一段的链路上传送的，将 IP 数据组合成帧，相邻节点传输帧） 物理层 （定义传输媒介） All People need data processing 08 VUE v-if 切换有一个局部编译/卸载的过程，切换过程中合适的销毁和重建内部事件监听和子组件，v-show 只是简单的进行 css 的切换 vif 切换消耗 Vshow 初始渲染消耗 09 定义列表 自定义 1234&lt;dl&gt; &lt;dt&gt;标题&lt;/dt&gt; &lt;dd&gt;内容&lt;/dd&gt;&lt;/dl&gt; 有序 1234&lt;ol&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt;&lt;/ol&gt; 无序 1234&lt;ul&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt;&lt;/ul&gt; 选择框—分组 filedset legend 10 拖拽 11 ==和=== == 123456// 双等号隐式类型转换 ALL trueconsole.log(100 == &quot;100&quot;)console.log(0 == &quot;&quot;)console.log(0 == false)console.log(&quot;&quot; == false)console.log(null == undefined) 开发尽量使用===， 但是这种情况可以，两者等价 obj==null 与obj===null || obj===undefined 12 闭包 指函数和其周围的状态（即词法环境）的组合，作用域的特殊运用 内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后 自由变量 在闭包函数中使用但不是在该函数作用域内声明的变量 自由变量的值：在函数定义的地方向上层寻找，与函数调用的地方无关 以下是一些常见的触发闭包的情况： 函数嵌套：内部函数可以访问外部函数的变量，导致形成了闭包。 函数作为返回值：如果一个函数返回了一个内部函数，那么该内部函数可以访问到外部函数的变量，从而形成闭包。 ​ 事件监听：如果在事件监听函数内部定义了函数，那么该内部函数可以访问到事件监听函数的变量，形成闭包。 延迟调用：如果在一个函数内部调用了另外一个函数，并且该函数有一个定时器或者是回调函数，那么该回调函数可以访问到外部函数的变量，形成闭包。 IIFE（立即调用的函数表达式）：如果在一个函数内部定义了一个函数并立即调用，那么该内部函数可以访问到外部函数的变量，形成闭包。 13 防抖节流 事件被频繁触发时，减少事件执行的次数 防抖 Debounce 在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。(input 输入，resize ) 1234567891011121314151617181920212223&lt;input type=&quot;text&quot; id=&quot;ipt&quot; /&gt;&lt;script&gt; let ipt = document.querySelector(&quot;#ipt&quot;) ipt.addEventListener( &quot;keyup&quot;, debounce(function () { console.log(ipt.value) }) ) function debounce(fn) { let timer = null return function () { if (timer) clearTimeout(timer) timer = setTimeout(() =&gt; { fn.apply(this, arguments) timer = null }, 500) } }&lt;/script&gt; 节流 Throttle 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。（拖拽、scoll） 1234567891011121314151617181920212223242526&lt;div class=&quot;box1&quot; draggable=&quot;true&quot; style=&quot;background-color: red; width: 100px;height: 100px;&quot;&gt;&lt;/div&gt;&lt;script&gt; let box1 = document.querySelector(&quot;.box1&quot;) box1.addEventListener( &quot;drag&quot;, throttle(function (e) { console.log(e.clientX) }) ) function throttle(fn) { let timer = null return function () { if (timer) return timer = setTimeout(() =&gt; { fn.apply(this, arguments) timer = null }, 500) } }&lt;/script&gt; 14 浏览器相关 l 进程：一个程序的运行实例 运行一个程序，操作系统会创建一块内存， 给代码和运行时的数据使用 ，并且创建一个线程来处理任务 线程是 一个进程的执行任务或者控制单元，负责当前进程中程序的执行 一个进程至少有一个线程，多个线程可以进行数据的共享 特点： 一个线程崩溃，整个进程崩溃 同一进程中，线程可以数据共享 进程关闭后，内存会正确回收 普通单线程浏览器 不稳定， 容易卡， 内存泄漏（所有页面在一个进程中，单个页面因为代码编写问题数据泄露。关闭页面时，泄露的内存不会回收） 安全问题（插件和渲染线程拥有很高权限，各种脚本代码（通常第三方编写）） Chrome 多线程 每个页面单独渲染进程和插件进程，装进沙箱，不能获取系统权限 权限由浏览器主线程操作 主进程：页面的展示，页面的交互，管理子进程，提供存储功能 网络进程：下载网络资源 GPU 进程：绘制网页和 UI 界面 渲染进程：js v8 引擎，排版引擎 Blink （h5 css js 转换为网页） 网络协议 互联网协议 Internet protocol IP 网络层协议 计算机系统通过 ip 协议在网络中互相传输数据 IP 不好记 ----&gt; 域名 DNS 域名系统 Domain name system 找到具体服务器的系统服务器的 IP 地址，如何指定访问具体程序 ​ UDP 用户数据包协议 user datagram protocol 端口号访问指定的程序 传输层协议 ​ UDP 协议发送数据时，不能保证接收端一定收到 ​ TCP 数据传输（控制）协议 transmission control protocol 传输层协议 ​ 将数据拆分成数据包的形式传输 ​ 数据包的丢失，提供重传的机制 ​ 面向连接，在传输数据之前，他会和目标设备进行连接，在传输完成后和目标断开连接 （创建和断开的过程，三次握手，四次挥手） 特性 TCP UDP 连接方式 有连接 无连接 可靠性保证 提供可靠性保证 不提供可靠性保证 传输数据顺序保证 传输数据顺序得到保证 不保证传输数据顺序 传输数据开销较大 是 否 适用场景 适用于数据传输要求可靠的应用程序，如文件传输、电子邮件等 适用于数据传输速度要求快的应用程序，如在线游戏、实时视频和音频通信等 TCP 🤝👋🏻 三次握手(建立连接) ​ 1. 客户端请求连接的请求 SYN，随机起始序列号 Sequence Number 给 服务端 ​ 2. 服务端接受到请求，发送确认信息 ACK、SYN（伴随随机起始序列号）、客户端发送来的序列号+1（aka确认序列号 Acknowledgement Number） ​ 3. 客户端收到服务器的 SYN 和 ACK，向服务器发送一个 ACK 确认信息（服务器随机序列号+1） 通过握手过程，TCP 协议可以保证连接的可靠性和正确性，同时还可以进行流量控制和拥塞控制，以确保网络的稳定性和可靠性。 四次挥手 （关闭连接） 🅰️ 发送一个 FIN 消息，表示没有数据传输，但 🆎 双方仍可接受数据 🅱️ 接受到 FIN，向对方发送 ACK，表示已经接受到该消息 🅱️ 也发送一个 FIN 消息，表示数据全部传输完毕，但 🆎 双方 🈲 不可发送数据 🅰️ 收到 FIN，返回一个 ACK 消息，表示已经接受到该消息 通过挥手过程，TCP 协议可以保证数据的完整性和可靠性，在数据传输结束后及时关闭连接，释放资源，以便其他应用程序可以使用它们。 规定传输格式 浏览器 http 协议 http 请求流程 ​ url 给我网页数据 查找缓存（存在且没过期，暂停请求 网页更快加载，减轻服务器压力 ​ 没有缓存，http 做应用层协议，tcp ip 发送到网络中（之前通过域名获取 IP 地址，找到缓存，下次直接使用对应 ip,访问域名没有加端口，默认加:80(http 默认端口) ​ 为 TCP 建立连接做 3 次握手，完成 发送 http 请求 ||服务端接受返回数据 输入 URL 到页面展示 浏览器判断输入的内容，不符合 URL 规则，内置搜索引擎搜索；符合规则，加上协议 请求阶段：浏览器主进程 =URL(进程之间通信) =&gt; 网络进程=（转圈，接受服务器返回的 http 相应头 html）,让浏览器开启一个渲染进程，发送一个提交文档命令。 网络进程=（HTTP 文档）=&gt; 渲染进程 ​ ​ 渲染完毕 ，接受完毕指令，当前页面白屏 渲染进程联合 GPU 进程渲染，并返回 网络进程 ?缓存资源(返回给浏览器主进程，中断请求) ​ 没有，进入网络流程 ​ DNS 解析 ip 地址 同一站点（根域名，协议相同 ）公用一条渲染进程 15 面向对象 类的封装、继承、多态 封装：低内聚高耦合 多态：重载和重写 ​ 重载：方法名相同，形参个数或者类型不一样 ​ JS 中不存在真正意义上的重载，JS 重载指的是使用同一个方法，根据传参不同，实现不同的效果 JS 中的面向对象是基于原型和原型链的 继承：子类继承父类的方法 JS 继承： 原型继承 优点：父类方法可以被复用 缺点：1. 父类的引用类型数据会被子类共享篡改 2. 子类实例不能给给父类构造函数传参 call 继承 借用构造函数 优点：父类的引用类型数据不会被子类共享篡改 缺点：不能访问父类原型属性上的方法 **组合继承（**原型继承和 call 继承的结合） 优点： 父类方法复用 父类引用数据不会被子类共享篡改 子类可以访问父类原型上的方法 缺点： 会调用两次父类的数据，会有两份一样的属性和方法，影响性能 寄生组合继承 优点 改变以上优缺点 缺点 ES6 extends、super 16 判断数据类型 typeof Array Object null 都是返回 object 类型 (set、map 也是 object，symbol 返回 symbol) Object.prototype.toString.call() 都可以区分 [] {} null 17 手写代码 instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 判断继承关系，在同一条原型链上，返回 true 12345678910function myInstanceof(obj1, obj2) { let objProto = obj1.__proto__ while (true) { if (objProto === null) return false if (objProto === obj2.prototype) return true // 一层一层往上找 objProto = objProto.__proto__ }} bind 123456789101112131415161718Function.prototype.myBind = function () { // console.log(this) //fn函数 const fn = this let arg = Array.from(arguments) const _this = arg.shift() return function () { return fn.apply(_this, arg) }}Function.prototype.myBind = function (context, ...args) { const fn = this return function () { return fn.apply(context, [...args, ...arguments]) }} 深拷贝 123function deepClone(obj) { return JSON.parse(JSON.stringify(obj))} 需要注意的是，在一些复杂的对象中，比如包含函数、正则表达式、日期等类型的对象时，使用JSON.parse(JSON.stringify(obj))可能会导致数据丢失或类型错误，因为这些类型的对象不能被序列化为 JSON 字符串。这时候需要采用其他的深度复制方法，比如手动递归复制、使用第三方库等。 递归 (没有考虑循环引用) 如果对象 A 引用了对象 B，而对象 B 又引用了对象 A，那么在进行深拷贝的时候会陷入死循环。（哈希表） 123456789101112function deepClone(obj) { if (typeof obj !== &quot;object&quot; || obj == null) return obj let res = obj instanceof Array ? [] : {} // for in会遍历到obj原型链上的属性，增加判断，健壮性 for (let key in obj) { if (obj.hasOwnProperty(key)) { // 嵌套的一层不会被克隆，所以再加一次深度克隆 res[key] = deepClone(obj[key]) } } return res} lodash.cloneDeep() 扁平化数组 借助 Array.prototype.concat.apply([], arr) 18 预编译 JS 预编译 js 属于解释性语言，在执行过程中顺序执行，但是会分块先预编译再执行。因此 JS 存在一种变量提升的现象。 但是是因为有预编译才有 所谓的变量提升 函数先于变量提升 变量提升 var 声明变量提升、function 声明函数提升 无论这两者声明或调用的位置是前是后，系统总是会将其提升到调用前面，因此只值为 undefined JS 代码运行的三大步骤 词法分析 预编译 解释执行 暗示全局变量 imply global 任何变量，未经声明就赋值，此变量为全局所有 12345678910&lt;script&gt; a = 100 console.log(a, window.a)) //100 100 function test(){ b = 200 } test() console.log(b, window.b) //200 200&lt;/script&gt; 、、、、、在 ES5 下、、、、、 Global Object 和 Activition Object 所谓的全局作用域，局部作用域 创建 GO 对象 寻找变量声明 var，值设定为 undefined 寻找函数声明，将函数名作为 GO 属性名，值为函数体 创建 AO 对象 寻找函数的形参和变量声明var，将变量和形参名作为 AO key，value 为 undefined 统一形参和实参，即更改形参后的 undefined 为实参值 寻找函数声明，将函数作为 AO key，value 为函数体 匿名函数、函数表达式不参与预编译 ES6 新增的块级作用域 123456789101112function test(a, b) { console.log(a) //1 c = 0 var c a = 3 b = 2 console.log(b) //2 function b() {} function d() {} console.log(b) //2}test(1) 预编译 AO：{ ​ a:undefined 1 ​ b:undefined fn ​ c:undefined ​ d: fn } 执行 AO：{ ​ a:undefined 1 3 ​ b:undefined fn 2 ​ c:undefined 0 ​ d: fn } 12345678910111213141516function test(a, b) { console.log(a) //fn a console.log(b) //udefined var b = 1 console.log(b) //1 a = 2 console.log(a) //2 function a() {} var a b = 3 var b = function () {} console.log(a) //2 console.log(b) //fn}test(1) 预编译 AO：{ ​ a:undefined 1 fn ​ b:undefined } 执行 AO：{ ​ a:undefined 1 fn 2 ​ b:undefined 1 3 fn } 1234567891011121314151617181920212223a = 100function test(e) { function e() {} arguments[0] = 2 console.log(e) //2 console.log(c) // undefined if (a) { var b = 123 function c() {} //在if语句里面不声明（块级作用域） } var c var a a = arguments[1] console.log(a) //2 console.log(b) //undefined f = 456 console.log(c) //undefined console.log(f) //456}var atest(1, 2)console.log(a) //100console.log(f) //456 预编译 AO：{ ​ e:undefined 1 fn(e) ​ b: undefined ​ c: undefined ​ a:undefined } GO:{ ​ a: undefined ​ test: fn } 执行 AO：{ ​ e:undefined 1 fn(e) 2 ​ b: undefined ​ c: undefined ​ a:undefined 2 } GO:{ ​ a: undefined 100 ​ test: fn } 19 for in of For in 遍历得到 key 可枚举的数据 (Object.getOwnPropertyDescriptors()) ​ 数组、字符串、对象 for...in 循环可以遍历对象的可枚举属性，包括自有属性和继承属性。但是需要注意的是，它不能保证属性的遍历顺序，而且会遍历对象的原型链上的属性，所以需要使用 hasOwnProperty() 方法来判断属性是否为自有属性。 for of 遍历得到 value 可迭代的数据 (arr[Symbol.iterator]()) ​ 数组、字符串、set、map For await of 遍历一组 Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script&gt; function generatePromise(num) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(num) }, 500) }) } const p1 = generatePromise(1) const p2 = generatePromise(2) const p3 = generatePromise(3) const p4 = generatePromise(4) const list = [p1, p2, p3, p4] // 如何一下子拿到所有结果 /* (async function(){ for await(let val of list){ console.log(val) //1,2,3,4一行一行打印 } })() Promise.all(list).then(res=&gt;{ console.log(res) //[1,2,3,4] 返回数组结果 }) */ // 如和一步一步拿到结果 const data = [1, 2, 3, 4, 5] ;(async function () { for (let val of data) { const res = await generatePromise(val) console.log(&quot;??&quot;, res) } /* const res1 = await generatePromise(data[0]) console.log(res1) const res2 = await generatePromise(data[1]) console.log(res2) const res3 = await generatePromise(data[2]) console.log(res3) const res4 = await generatePromise(data[3]) console.log(res4) const res5 = await generatePromise(data[4]) console.log(res5) */ })()&lt;/script&gt; 20 JS 类型转换 js 是动态类型语言，我们在定义一个变量其实并没有指定这个变量到底属于那种类型，只有到程序执行阶段才确定当前数据类型。 而各种运算符对数据类型是有要求的，所以就会触发类型转换机制（no matter 人为 or 隐式触发） 显示转换： ​ 通过 JS 内置的函数明确转换的数据类型 Number parseInt(string, ?进制) 比 Number 宽松，一位一位解析遇到不能解析的停止 String Boolean 隐式转换： ​ 运算操作符两边数据类型不一致（比较运算符、算术运算符） 转为 Boolean (需要布尔值的地方，借助的Boolean()函数) falsely 变量：undefined、null、false、+/-0、NAN、&quot;&quot; 转为 String （复合类型—&gt;原始类型----&gt;字符串） 常发生在 &quot;5&quot; + xxx 加法运算符号 转为 Number 除了加法运算符号，其他都有可能 other === 在不进行类型转换情况下，双方的类型与值都相等 21 JS 事件机制 事件 就是 html 文档与浏览器的一些交互操作，使网页具备互动性 由于DOM是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了**事件流**的概念 捕获 目标 冒泡 123addEventLisener(&quot;click&quot;, () =&gt; {}, false) //默认false，不在捕获阶段执行event.preventPropagation() //阻止在冒泡阶段执行 click 事件 冒泡 22 JS 异步机制 JS 异步编程 单线程 DOM 操作，必须要使用单线程模型，否则出现多线程同步问题（一个线程增，一个线程删，麻烦） 假如说只用同步来解决，即排队执行代码，那么则简单、安全。但是遇到一段非常耗时的代码段，导致整个程序被拖延，导致假死（阻塞）情况。所以 JS 带来同步模式异步模式来解决此问题。 同步模式与异步模式 事件循环与消息队列 异步编程几种方式 Promise 异步方案、宏任务/微任务队列 （ES2015） Generator 异步方案（ES2015），Async/Await 语法糖（ES2017） 同步模式与异步模式 同步模式 排队一步一步执行 开始执行 JS 引擎将全部代码加载进来，call stack压入一个(anonymous) （全部代码放入匿名函数中执行，call stack是调用栈，函数声明不会压入栈中） 异步模式 不会等待这个任务结束，才开始下一个任务。开启过后，立即开始下一个任务。后续逻辑一般会通过回调函数的方式定义 代码执行顺序混乱？？ 倒计时器根本不会管 call stack 和 Queue，放在 WebAPI 中 call stack 正在执行的工作表 Queue 待办工作表 Event Loop 监听 call stack 和 Queue， 一旦 call stack 任务结束，事件循环会从 Queue 中取出第一个回调函数压入到 call stack JS 单线程，是指执行代码是单线程的，但浏览器并不是单线程。 而我们所说的同步异步问题是指运行环境提供的 API 是以同步或异步模式的方式工作 回调函数 所有异步编程方案的根基 理解为：一件你想要做的事---&gt;但不知道这件事所依赖的事情什么时候结束---&gt;交给异步任务执行者，他知道 ​ 调用者定义 交给执行者执行 事件机制、发布订阅基于回调 Promise 一种更优秀的异步编程统一方案（CommonJS 社区提出，被纳入 ES2015） 明确成功或失败的结果（不可被修改）后，都会有相应的任务自动执行。 链式调用（不是通过函数 return this 达到的链式调用） .then( )方法 返回的是全新的 Promise 对象 （返回 每一个 then 方法实际上都是为上一个 then 返回的 Promise 对象添加状态明确的回调 Promise 的 then 方法返回一个全新的 Promise 对象（所以可以采用.then 链式调用） .then 后面会返回一个新的 promise 实例，又可以继续调用 then 或者 catch 方法 后面的 then 方法就是在为上一个 then 方法返回的 Promise 对象注册回调（添加状态明确的回调） 前面 then 方法 return 的返回值会作为下一个 then 方法回调的参数 如果 return 的是 Promise 对象，那么后面的 then 方法会等待到他的结束 异常处理 两个回调(onFulfilled，onRejected) （只能在当前 then 方法调用中接住） .catch （相当于两个回调 其中(undefined，onRejected) ，异常可以被传递，而被 catch 接住 unHandledRejection（全局） 静态方法 Promise.reslove() 将一个值快速转换为 Promise 对象 用此方法包装一个 Promise 对象得到的还是原本的 Promise 对象 1234567let p = new Promise((resolve, reject) =&gt; { resolve(&quot;111&quot;)})let p2 = Promise.resolve(p)console.log(p === p2) //true 如果用此方法，包装如下带有 then 方法的对象 (thenable 可以被 then 的对象) 1234567Promise.resolve({ then: (onFulfilled, onRejected) =&gt; { onFulfilled(&quot;qqqq&quot;) },}).then((res) =&gt; { console.log(res) //qqqq}) Promise.reject() 无论传什么参数，都会作为 Promise 失败的理由 Priomse 并行执行 在页面请求多个接口的情况，这些请求没有过多依赖，那么就可同时请求 怎么知道这些请求完成？传统用计数器 Promise.all() 多个 Promise 集中管理 （同步执行多个 Promise 的方式）等待所有 Promise 结束后 1Promise.all([xxx, yyy]) // xxx,yyy为Promise对象 Promise.race() 只会等待第一个完成的任务，就结束 Promise 执行时序 宏任务 vs 微任务 Promise 执行时序有点特殊 回调队列 Queue 中的任务 『宏任务』，宏任务执行过程期间可能会加上额外的需求， ​ 这些需求可以选择作为新的宏任务进入到队列 Queue 中排队 ​ 也可以作为当前任务的『微任务』，直接在当前任务结束之后立即执行，而不是进入队列排队 Promise 回调作为微任务 执行的 （本轮结束的末尾，自动执行，不进入队列） ​ 如果处于 pending 状态就不能进入这一次微任务 ​ await 后面的语句加入到微任务队列 微任务：提高整体的响应能力 目前绝大多数异步调用都是作为宏任务执行 微任务：Promise、mutationObserver 以及 Node 中的 process.nextTick Generator 异步方案 Promise 处理异步任务的串联执行，仍然有大量的回调函数，虽然没有嵌套，影响阅读 传统异步模式，更简洁，更利于阅读 Generator ES2015 Generator 函数返回的遍历器对象都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。外面 try catch 捕获 生成器函数执行器 1234567891011121314151617181920212223242526272829303132333435363738394041424344function* main() { try { const api = yield ajax(&quot;/api.json&quot;) console.log(api) const api2 = yield ajax(&quot;/api2.json&quot;) console.log(api2) } catch (e) { console.log(e) }}/* const g = main() handleResult(g.next()) // 生成器函数执行器 function handleResult(result) { if (result.done) return result.value.then(data =&gt; { handleResult(g.next(data)) }, error =&gt; { g.throw(error) } ) } */co(main)// 生成器函数执行器function co(generator) { const g = generator() handleResult(g.next()) function handleResult(result) { if (result.done) return result.value.then( (data) =&gt; { handleResult(g.next(data)) }, (error) =&gt; { g.throw(error) } ) }} 异步调用扁平化 Async Await ES2017 不在需要类似 co 的执行器，语言层面的标准一步语法 async 函数返回的是一个 Promise 对象，利于控制整体 1234567891011121314151617181920212223242526console.log(&quot;start&quot;) //1setTimeout(() =&gt; { //宏任务1 console.log(&quot;children2&quot;) Promise.resolve().then(() =&gt; { console.log(&quot;children3&quot;) })}, 0)new Promise(function (resolve, reject) { console.log(&quot;children4&quot;) //2 setTimeout(function () { //宏任务 console.log(&quot;children5&quot;) resolve(&quot;children6&quot;) }, 0)}).then((res) =&gt; { // 微任务 console.log(&quot;children7&quot;) setTimeout(() =&gt; { console.log(res) }, 0)})// start children4 children2 children3 children5 children7 children6//juejin.cn/post/6950786264941461541 async/await 执行顺序 我们知道async隐式返回 Promise 作为结果的函数,那么可以简单理解为，await 后面的函数执行完毕时，await 会产生一个微任务(Promise.then 是微任务)。 但是我们要注意这个微任务产生的时机，它是执行完 await 之后，直接跳出 async 函数，执行其他代码(此处就是协程的运作，A 暂停执行，控制权交给 B)。 其他代码执行完毕后，再回到 async 函数去执行剩下的代码，然后把 await 后面的代码注册到微任务队列当中。我们来看个例子： 1234567891011121314151617181920212223242526272829console.log(&quot;script start&quot;)async function async1() { await async2() console.log(&quot;async1 end&quot;) //1微任务}async function async2() { console.log(&quot;async2 end&quot;)}async1()setTimeout(function () { console.log(&quot;setTimeout&quot;)}, 0)new Promise((resolve) =&gt; { console.log(&quot;Promise&quot;) resolve()}) .then(function () { console.log(&quot;promise1&quot;) }) .then(function () { console.log(&quot;promise2&quot;) })console.log(&quot;script end&quot;)// 旧版输出如下，但是请继续看完本文下面的注意那里，新版有改动// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTime","link":"/posts/SUMMARY/"},{"title":"btoa-atob","text":"今天在找登录token发先存于Cookie的access_token被加密成ASCII字符串，遂找到了两个window下的api 123456789// base64Encryptionexport function encryptToken(token) { const encryptedToken = btoa(token) return encryptedToken}export function decryptToken(encryptedToken) { const decryptedToken = atob(encryptedToken) return decryptedToken} Binary To ASCII btoa() 方法可以将一个二进制字符串（例如，将字符串中的每一个字节都视为一个二进制数据字节）编码为 Base64 编码的 ASCII 字符串。 **ASCII To Binary ** atob() 对经过 base-64 编码的字符串进行解码","link":"/posts/btoa-atob/"},{"title":"computed与watch","text":"计算属性computed ​ 适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来 支持缓存，只有依赖数据发生改变，才会重新进行计算 不支持异步，当computed内有异步操作时无效，无法监听数据的变化 computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed 如果computed属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;p&gt;计算属性示例&lt;/p&gt; &lt;p&gt;原始数据: {{ originalData }}&lt;/p&gt; &lt;p&gt;计算属性: {{ computedProperty }}&lt;/p&gt; &lt;button @click=&quot;updateData&quot;&gt;更新数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { originalData: 5 }; }, computed: { computedProperty() { // 计算属性，依赖于原始数据 return this.originalData * 2; } }, methods: { updateData() { // 更新原始数据，会触发计算属性重新计算 this.originalData += 1; } }};&lt;/script&gt; 侦听属性watch ​ 适用于观测某个值的变化去完成一段复杂的业务逻辑（例如执行异步或开销较大的操作） 不支持缓存，数据变，直接会触发相应的操作； watch支持异步； 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值； 当一个属性发生变化时，需要执行对应的操作；一对多； 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：新值和旧值 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;p&gt;监听的数据: {{ watchedData }}&lt;/p&gt; &lt;button @click=&quot;changeData&quot;&gt;改变数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { watchedData: '初始值' }; }, methods: { changeData() { this.watchedData = '新值'; } }, watch: { watchedData(newVal, oldVal) { // 在数据变化时触发的操作 console.log('新值：', newVal); console.log('旧值：', oldVal); // 这里可以执行您想要的其他操作 } }};&lt;/script&gt;","link":"/posts/computed%E4%B8%8Ewatch/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/posts/hello-world/"},{"title":"HTTP summary","text":"HTTP Hyper Text Transfer Protocol Stateless : every Request is INDEPENDENT regard each request as a single transaction use cookie session localStorage … to enhance user experience( memorize the state from the user ) HTTPS Hyper Text Transfer Protocol Secure Data sent is encrypt SSL – Secure Sockets Layer TLS – Transfer Layer Security install certificate on web host to use HTTPs Message Headers General Request URL、Request Method、Status Code、Remote Address、Referrer Policy Request Cookies、Accept-xxx、Content-Type、Content-Length、Auhurization、User-Agent、Referrer Response Server、Set-Cookie、Content-Type、Content-Length、Date Status Code Status Code Means 1xx request received / processing 2xx Success received, understood, accepted 3xx Further action must be taken / redirect 4xx Client error 5xx Server error 200 - OK 201 - OK created 301 - Move to new URL 304 - Not Modified (Cached version) 400 - Bad Request （❌ not sending correct data） 401 - Unauthorized （missing token） 404 - Not Found (resources do not exsist) 500 - Internal Server Error HTTP2 multiplexing","link":"/posts/http/"},{"title":"nodejs","text":"pre 运行时（Runtime) &quot;运行时&quot;就是程序运行的时候，也就是指令加载到内存并由CPU执行的时候。 与之相对应的是“编译时”，其指代码编译的时候，也就是C代码编译成可执行文件的时候，此时指令没有被CPU执行。 运行时库（Runtime Library） 运行时库就是程序运行的时候所需要依赖的库。 运行时环境（Runtime environment） 运行环境（英语：Runtime environment）又称“运行时系统”（run-time system），指一种把半编译的运行码在目标机器上运行的环境。 简介 Nodejs 只是一个js运行时环境 访问系统内核，访问本地文件，链接服务器… nodejs在浏览器之外运行v8引擎 跨平台 适合干IO密集型应用，不适合CPU密集型（单线程） CPU 密集型： 图像、音频处理需要大量的数据结构+算法 全局变量 node global 浏览器 window globalThis根据环境自动判断 ECMAScript中有的全局，如Math… __dirname 当前文件所在目录(绝对路径) __filename 当前文件路径（绝对路径） __extname 文件后缀 Buffer process 处理进程 process.argv 获取参数数组 process.cwd() 目录 process.exit() 终止进程 process.on('exit', ()=&gt;{console.log('退出')}) 监听事件 nodejs应用在（长期运行!!httpserver返回++counter）单个进程中运行，无需为每个请求创建新的线程 （相比，Apache，每一个请求创建一个线程） 单线程，并发量为1 采用了非阻塞的开发范式（事件循环机制） + v8引擎加持，轻松应对高并发 主线程是单线程，io是libuv维护的线程池 当函数调用栈内有函数运行时，js不能处理其他请求 异步模块（多线程）和事件循环（监听 派发，不占用单独线程） 循环不停监听异步模块处理进度，等处理完成后，派发函数调用栈执行 最快的速度清空函数调用栈，把耗时的操作全部做异步处理 node将【异步操作和对应的回调函数】封装成一个请求对象，交给底层的异步模块处理 异步操作有结果之后，回调函数进入事件循环等待执行， 事件循环在调用栈清空时，按照某个优先级顺序将回调函数推入到调用栈执行 node异步API 定时器： setTimeOut setInterval （最小1ms，浏览器4ms） I/O操作： 文件读写，数据库操作，网络请求 node独有的，process.nextTick、setImmediate nextTick(优先级比事件循环队列更高) 微任务（promise） timer –&gt;poll（当执行到这里时卡住，检查timer或者check队列有误需要 执行的） check Poll 阻塞，从设计上，是想优先处理IO事件的 Settimeout(,0)与setimmdeiate 放入io中使用，定时器，总会先执行check队列的操作 Timer -&gt; check运行一周称为一个Tick nextTick先于下一个Tick执行 异步代码进入异步模块以非阻塞的形式执行，对应的异步函数会在对应的异步代码执行完成后，派发到不同的队列中 异常处理 为了健壮性：捕获并处理每一个错误 同步代码 try catch 异步代码 Promise (catch) async await trycatch 异步编程 流程控制 回调函数 --&gt; Promise —&gt; async await node官方的库 遵循，错误优先风格 回调函数，需要顺序执行，就要嵌套的写，但是导致回调地狱 平行 顺序 module module并不是全局变量，每一个模块有他相应的模块 核心模块（随着node） 第三方模块 自定义模块（引用路径） 运行时加载 cmj，知道运行时候再报错 编译时加载 esm import from 写在模块顶层 import() （异步，返回promise） V8 预编译阶段 （ESM -分配内存空间 -确定作用域链… 执行阶段 （CMJ Buffer js字符串不可变，所有对字符串的操作都要生成一个新的字符串 fs模块读取，不生命文件类型，默认返回的都是文件二进制缓冲区 1234567const buffer1 = Buffer.alloc(5) //申请五个字节console.log(buffer1.toString())buffer1.write('string') //多写入的部分不会写入console.log(buffer1, buffer1.toString())console.log(Buffer.from('a string')) stream i/o操作 端到端数据交换 加载 缓冲区 处理 流模式 加载一点处理一点 SEO TDK title description (meta) Key(meta) 语义化标签 &lt;a/&gt; href &lt;img/&gt; href alt 一个页面一个h1 和 main标签 … 借助第三方库jsdom（jsdom模拟浏览器环境的库，可以在 Node.js 中使用 DOM API），服务端渲染","link":"/posts/nodejs/"},{"title":"js红宝书","text":"&lt;script&gt;标签 一些属性 defer 推迟 async 异步 期间不要动DOM intergrity 检查安全 src GET 跨域 引入外部文件文件，行内代码写了没用 MIME 代码块中的脚本语言内容类型 &lt;noscript&gt;&lt;/noscript&gt; 严格模式（ES5增加） 遵守的是es3的语法 开启严格模式，脚本开头写上&quot;use strict&quot;; ，也可写在函数内部开头，单独开启严格模式 变量 ​ var变量提升hoist ，函数作用域,全局声明成为window对象属性 ​ let，块级作用域，暂存性死区（temporal dead zone) ​ let和var 只是指出变量在相关作用域如何让存在 ​ const 适用于for-in(对象属性名)、for-of（数组） 声明风格 ​ 不使用var， const优先，let次之 3.4 数据类型 ​ Undefined、Null、Boolean、Number、String、Symbol、Object ​ typeof 操作符 ​ typeof null =&gt; onject (null被认为是空对象的引用) ​ Number ​ 八进制: 0111 在严格模式下报错、0o111可以 ​ 1. 和 1.0 为整数，1.1、1.2浮点数 ​ ES会将小数点后至少包括6个0的浮点值转换成科学计数法 ​ String ​ ECMAScript中的字符串是不可变的immutable ​ toString 返回自身的一个副本 ​ 除了null 和 undefined都有toString方法。对于数值类型可以传参(转换进制数) ​ 对于变量未知类型的，转为字符串，利用**String()转型函数** ​ 模板字面量 `` ​ 保留换行字符，跨行定义字符串 ​ 字符串插值 ``${js表达式}` ，调用了toString方法强制转换为字符串 ​ 标签函数(模板字面量隔开形成的字符串数组，...模板字面量的值) ​ 原始字符串String.raw 12console.log(`\\u00A9`) //© (输出转义后的符号console.log(String.raw`\\u00A9`) //\\u00A9 (输出原始的字符串 ​ Symbol ​ 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同 ​ 全局符号： ​ symbol.for()执行幂等操作，第一次操作会检查全局运行时注册表，是否存在对应的symbol.for() ​ 查询全局注册表Symbol.keyFor(参数) (参数必须为symbol类型，否则抛出typeError) ​ 查询成功返回symbol值，否则返回undefined ​ 作为对象[属性]使用 ​ defineProperty添加symbol类的值作为属性（在node下不能） ​ 内置符号（不可写，不可枚举，不可配置） ​ Symbol.iterator for-of循环会使用这个属性 ​ Symbol.asyncIterator for-await-of使用，异步迭代器 ​ Symbol.hasInstance定义在Function的原型身上 ​ Symbol.isConcatSpreadable（默认值undefined） 控制Array.prorotype.concat是否“打平”连接 ​ 对于数组对象(默认打平），设置为falsely变量，不会打平连接，会让整个对象追加到数组末尾 ​ 对于类数组对象（默认不打平），设置为truely变变量，会打平连接，到数组实例 ​ Object ​ ECMAScript只要求给构造函数提供参数时使用括号 1const obj = new Object //合法，但不推荐 ​ hasOwnProperty ​ valueof() 定义在对象里的方法。 return的值， ​ 显示获取：obj.valueOf() ​ 隐式获取：++obj 对obj进行数学运算，直接调用的valueOf()方法 3.5 操作符 ​ 一元操作符 ​ 自增、自减、+、- ​ + 拼接字符串，- 先Number()转换，在减法操作 ​ 位操作符 ​ ECMAScript 数值 以IEEE 745 64位格式存储 ​ 位操作，将值转为32位整数，再进行操作，最后再把结果转为64位 ········ 3.6 语句 ​ for-in 严格迭代语句，遍历对象的可枚举非symbol类型属性 ​ for-of 严格迭代语句，遍历可迭代对象 ​ 标签语句 配合continue和break使用 ​ with语句，将代码的作用域设定为特殊的对象 123456789const a = process.pidconst b = process.ppidconst c = process.titleconsole.log(a, b, c)with(process){ console.log(pid, ppid, title)}//严格模式不支持with，影响性能，难于调试，不推荐使用 ​ switch 全等操作符，不会强制转换类型 第四章 变量、作用域与内存 4.1 原始值与引用值 ​ 原始值（基础数据类型值） ​ 引用值，保存在内存中的对象 ​ ECMAScript函数参数传递是按值传递，（传递的是值的副本而非值本身） ​ 确定类型： ​ instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 ​ typeof…etc 4.2 执行上下文与作用域 ​ var的函数作用域声明：变量会添加到最近的上下文，作用域提升 ​ with语句中var声明的变量为在全局作用域中 ​ let、const {}块级作用域 使用const变量有助于JS引擎(谷歌V8引擎)优化，编译时就将所有实例替换成实际的值，而不会通过查询表进行变量查找 ​ 标识符查找：沿作用域链查找 4.3 垃圾回收♻️ ​ 基本思路：确定那个变量不会再使用，然后释放他占用的空间。（周期性自动运行） ​ 主要标记策略 ​ 标记清理： ​ 标记内存中的所有变量 ➡️ 去掉上下文或者上下文引用的变量的标记 ➡️ （这时候再被加上标记的变量就是待删除的了，任何上下文的变量都访问不到它们了）回收 **引用计数**(❗️导致循环引用) ​ 变量声明并赋引用值，引用数为1； ​ 如果同一个值又被赋值给另一个，引用数+1； ​ 该引用值被其他值覆盖，则引用数-1。 ​ 当引用值为0时，就会被垃圾回收 ​ 将变量设为null，切断变量与其之前引用值之间的关系。 ​ 性能： ​ 现代垃圾回收程序根据运行时的环境来决定何时运行（以前IE是达到设定的阈值，就执行回收） ​ 也有浏览器提供方法可以主动触发垃圾回收（❌） ​ 提升性能： ​ 使用const let声明变量：相对于函数作用域的var，块级作用域可能会更早终止，会让垃圾回收程序接介入，尽早回收内存 ​ 隐藏类和删除操作delete ​ V8引擎将JS代码编译成实际的机器码会利用”隐藏类”，能够共享隐藏类的对象性能更高 ​ 动态添加、删除属性导致不共享一个隐藏类 123456789function Foo(){ this.name = 'iam foo'}// 两个实例共用一个相同的隐藏类，因为两个实例共享一个共同的构造函数let f1 = new Foo()let f2 = new Foo()//‼️但是如此修改（这种操作的频率和隐藏类的大小对性能产生明显影响f2.name = 'iamf2'//Foo实例对应两个 不同 的隐藏类。 12345678910111213//✅解决方案： 先创建再补充function Foo(name){ this.name = name}//这样对应相同的隐藏类let f1 = new Foo('iamf1')let f2 = new Foo()//‼️但是，使用delete关键字动态删除属性导致，不再共享一个隐藏类delete f1.name//✅解决方案 把不想要的属性设置为nullf1.name = null ​ 内存泄漏 ​ 意外声明全局变量 ​ 定时器回调引用外部变量 ​ 使用闭包 ​ 静态分配与对象池 第五章 基本引用类型 5.1 Date UTC 协调世界时 GMT格林威治平时 ​ ​ Date.parse(创建的是本地日期) Date.UTC(创建的是GMT日期) 将一个表示日期的字符串解析为对应的时间戳（毫秒数） ​ new Date(传入时间字符串) ，根据字符串格式隐式调用上面两个构造函数 ​ Date类重写了toLocaleString toString valueOf(返回时间戳) ❓5.2 正则 5.3 原始值包装类型 ECMAScript提供了3种特殊的引用类型，Boolean String Number ​ 正常来说原始值本身不是对象，按逻辑上不应该有方法 12let s1 = 'some text'console.log(s1.substring(2)) //me text 包装类型让原始值拥有对象行为 ​ 创建一个String类型实例 ​ 调用实例上的方法 ​ 销毁实例 123456789// 显示创建原始值包装类型(不推荐)const s = new String('i am a string')//构造函数console.log(typeof s) //objectconst s = 'i am a string' console.log(typeof s) //stringconst s = String('i am a string') //转型函数console.log(typeof s) //string 12345// object工厂方法创建const os = new Object('i am a string')// 创建的是一个String实例console.log(typeof os, os instanceof String)// object true number ​ toFixed方法，返回的字符串保留几位小数（0~20位+，超过，四舍五入） 1234const num = 10console.log(num.toFixed(2))//10.00console.log(Number(10.005).toFixed(2))//10.01 ​ toPrecision返回最合理的数值(1-21小数位) String ​ JS 一个字符16位 ​ 与模式匹配相关的方法: match search replace split 5.4 单例内置对象 Global ​ eval函数（⛔️XSS攻击） ​ 这个函数就是个完整的ECMAScript解释器 ​ 定义在eval函数中的变量和函数，不存在函数提升 ​ 开启严格模式够，外部访问不到eval函数里的数据 Math 第六章 集合引用类型 6.1 Object ​ 字面量{}形式创建一个对象，并不会new Object() 6.2 Array ​ 字面量[]形式创建一个数组，也不会new Array() 1const arr = new Array(20) //定义数组长度为20 Array.from() 将伪数组转为真数组 Array.of() 将一系列参数转为数组 Array.of( 1, 2, 3) ➡️ [1, 2, 3] 数组空位 ​ 字面量一串逗号形式创建空位 ​ ​ ES6新增的方法和迭代器，将空位当成存在的元素，值为undefined ​ ​ ES6之前的方法， 忽略空位（具体的行为因方法而异） ​ map跳过空位，join将空位视为空字符串 ​ 数组索引 ​ 数组的length不是只读的，利用这个特性删除数组末尾元素（当然也可添加数组空位） ​ 检测数组 ​ 在一个全局上下文中，使用instanceof。 多个 iframe多个全局上下文。然后每个里面都有 Array 这个对象。他们并不相等。 本质来讲 instanceof 是去找 prototype 之类的，看看是否有继承。 ​ Array.isArray() 迭代器方法 ​ arr.keys() 返回数组索引的迭代器 ​ values() 返回数组元素的迭代器 ​ entries() 返回 索引/值 对的迭代器 ​ alert期待字符串 排序方法 ​ sort ，事先对数组中的没项元素都使用的String转型函数 ​ 升序：compare(val1, val2) val1 &gt; val2 return 1 ​ 降序：compare(val1, val2) val1 &gt; val2 return -1 操作方法 ​ concat splice 搜索方法 ​ indexof lastIndexOf includes ​ find findIndex 迭代方法 ​ every some ​ filter map forEach 归并方法 reduce reduceRight 6.3 定型数组 6.4 Map Set ​ 定义时都接受一个可迭代对象初始化映射 ​ 使用forEach，for-of迭代值 6.5 weakMap weakSet ​ weakMap存储键值对的键必须为引用类型数据 如果键的指向为空，自动称为垃圾回收的目标 weakMap实现真正的私有变量 都不可迭代值 6.8 迭代与扩展操作 ​ 定义的默认迭代器（Array 定型数组 Map Set） ​ 支持for-of顺序迭代、兼容扩展操作符 浅复制：只会复制对象的引用 第七章 迭代器与生成器 ​ 迭代：按顺序反复执行一段程序 ​ 循环是迭代的基础 迭代器模式 ​ 开发者无需知道如何迭代就能实现迭代操作 ​ 实现可迭代iterable接口的对象，都能被事件iterator接口的结构消费 ​ 内置iterable接口的类型：Stirng Array Map Set arguments对象 NodeList等DOM集合类型 ​ 接受可迭代对象的原生语言特性 ​ for-of 数组解构 扩展操作符 ​ Array.from new Set/Map ​ Promise.all / race yeild*操作符 给对象添加可迭代的iterable接口， 1234567891011121314151617let obj = { list: [1, 2, 3, 4], [Symbol.iterator]() { let count = 0 const { length } = this.list return { next: () =&gt; { return { done: count === length ? true : false, value: this.list[count++] } }, //提前终止，调用return方法 return() { console.log('Exiting Early!') return { done: true } } } }} 接收迭代器实例 123const iter = obj[Symbol.iterator]()console.log(iter.next()) //调用next方法console.log(iter.next()) 不同迭代器实例之间没有联系 迭代器不与对象某时刻的快照绑定，也可根据实际情况动态变化 迭代器维护一个指向可迭代对象的引用，⛔️阻止垃圾回收可迭代对象 提前终止迭代器 ​ 如上return方法指定迭代器提前关闭时执行的逻辑 ​ for-of 循环 在 break continue return throw时，触发提前终止逻辑 123456789for (let val of obj){ if(val === 3){ break } console.log(val)}// 1// 2// Exiting Early! ​ 解构操作并未消费所有的值时 1234const [item1, item2] = objconsole.log(item1, item2)// Exiting Early!// 1 2 如果迭代器没有关闭，可以从上次离开的地方继续迭代（数组的迭代器不能关闭） return() 方法是可选的 仅仅给一个不可关闭的迭代器器增加一个return方法并不能让他关闭。调用return方法并不会强制迭代器进入关闭状态。 生成器模式 临时的可迭代对象称为生成器 ​ 生成器拥有在函数块内暂停和恢复代码执行的能力 可以用于自定义迭代器和实现协程 💬定义生成器 ​ 函数名前加『 *』，箭头函数不可用于定义生成器函数 12function * generatorFn(){}//函数表达式方式 对象方法 类方法 类静态方法。。。 ​ 调用生成器函数产生生成器对象 12const g = generatorFn()console.log(g)// 开始暂时处于暂停执行状态，生成器对象也实现了iterator接口，具有next方法 初次调用next()方法指明开始调用生成器 value属性是生成器返回值，默认undefined 🛑yeild中断执行 yeild关键字只能在生成器函数中使用 作为可迭代对象使用 生成器显示调用next方法用处不大。 将生成器对象作为可迭代对象使用 12345678function *genneratorFn(){ yield 1 yield 2 yield 3}for(let val of genneratorFn()){ console.log(val)} yeild实现输入输出 yeild产出的值传给g.next() g.next()传入的参数，作为是yeild的返回值 产生可迭代对象 123// ...yeild *[1, 2, 3]// ... yeild* 其实也就是将可迭代对象序列化为一串可以单独产出的值 123456789function* genneratorFnA(){ for (const val of [1, 2, 3]){ yield val }}// 等价！！！function* genneratorFnB(){ yield* [1, 2, 3]} ✅作为默认迭代器使用 123456789101112class Foo { constructor(){ this.list = [1, 2, 3, 4] } * [Symbol.iterator](){ yield* this.list }}const f = new Foo()for(const val of f){ console.log(val)} 提前终止生成器 return() 强制生成器进入关闭状态 throw() 将一个错误注入到生成器中 如果生成器没处理这个错误，生成器会closed 生成器内部处理了这个错误生成器就不会关闭，而且会恢复执行（只是跳过了这个值） 第八章 对象、类与面向对象编程 8.1 对象 定义 ​ 构造函数、字面量形式 对象属性 数据属性（默认都为true) Configurable 属性可由delete删除 Enumerable 是否可由for-in枚举 Writable 是否可被修改 Value 包含实际值，默认undefined ​ 使用Object.defineProperty对对象属性属性修改（不配置值，默认为fasle） (严格模式下： 尝试对configurable: false; witable: false；的值修改，会抛出错误。) 不能对同一个属性，定义多次Object.defineProperty() 访问器属性 getter setter 12345678910111213141516171819202122232425const obj = { _name: 'levy_init' } Object.defineProperty(obj, 'name', { get() { return this._name }, set(newVal) { console.log('尝试修改name') this._name = newVal console.log('修改成功') } }) const obj2 = { _name: 'levyy', get name() { return this._name }, set name(newVal) { console.log('尝试修改name') this._name = newVal console.log('修改成功') } } Object.defineProperties 对一个对象的多个属性一次性进行描述符规定 12345678910111213const obj = { _name: 'levy'}Object.defineProperties(obj, { name: { get(){ return this._name } }, age: { value: 21 }}) 读取属性特性 ​ 读取对象某一个： Object.getOwnProperty(obj, 'aProperty') ​ 读取对象全部属性的特性：Object.getOwnProperties(obj) //其实也是对每个属性调用了上面的方法，在一个新对象返回 合并对象（混入） Object.assign()浅复制，只复制可枚举(PropertyIsEnumerable)、自身(hasOwnPropery)属性 不复制属性的getter setter 没有回滚之前赋值的状态，尽力赋值 相等判断 Object.is() 增强语法 属性值简写、可计算属性、方法简写、对象解构 8.2 创建对象 ES6 Class Extends也是基于ES5原型链继承的语法糖 工厂模式 12345678910function createPerson(name, age){ const o = new Object() //显式创建对象 o.name = name o.age = age o.sayName = () =&gt; { return o.name } return o //return 对象}const p1 = createPerson('小明', 10) 构造函数模式 12345678function Person(name, age){ this.name = name this.age = age this.sayName = () =&gt; { return this.name }}const p2 = new Person('小红', 10) new操作符 内存中创建一个新对象 这个新对象的内部的[[Prototype]]属性赋值为构造函数的prototype属性 构造函数内部的this被赋值为这个新对象（this指向新对象） 执行构造函数内部代码（给新对象添加属性） 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的对象 123456const myNew = (constructor, ...args) =&gt; { const o = new Object() o.__proto__ = constructor.prototype const res = constructor.apply(o, args) return res instanceof Object ? res : o} ​ 构造函数如果不传参可以不用写括号 问题 ​ 不同实例上的方法不是同一个，方法都是做同样的事，没必要定义两个不同的Function实例。 ​ 解决可以把方法定义在构造函数外部，构造函数内部方法直接引用 原型模式 在构造函数原型定义的属性方法可以被实例共享 1234567891011121314151617181920212223function Person(){ Person.prototype.name = '小小' Person.prototype.sayName = () =&gt; { return this.name }}const p = new Person()console.log(p.name, p.sayName)// 简化写法：function Person(){ Person.prototype = { name: '小小', sayName(){ return this.name } }}Object.defineProperty(Person.prototype, 'constructor', { value: Person, enumerable: false //原生constructor不可枚举，用这种方式定义}) isPrototypeOf 检查原型 原型链 1Person.prototype.isPrototypeOf(p) //true Object.getPrototypeOf() 获取原型对象 1Object.getPrototypeOf(p) === Person.prototype //true 更改原型对象 ​ Object.setPrototypeOf() 影响性能 ​ Object.create 1234567891011121314let a = { name: 'a'}let b = { age: 18}console.log(b)Object.setPrototypeOf(a, b)console.log(Object.getPrototypeOf(a) === b) //trueconsole.log(a.__proto__ === b) //truelet c = Object.create(a)console.log(Object.getPrototypeOf(c) === a)//trueconsole.log(c.__proto__ === a)//true 实例可以通过原型链查找属性 确定属性在自身还是是原型链上的 hasOwnProperty() in 操作符是在自身以及原型链上查找 Object.keys() 遍历实例可枚举属性 Object.getOwnPropertyNames() 遍历实例无论是否可枚举属性（除了Symbol ） Object.getOwnPropertySymbols() 遍历顺序 for-in Object.keys() 无序 对象迭代 Object.values() Object.entries() 浅复制对象、不迭代Symbol 8.3 继承 参考掘金 原型链继承 每个构造函数有一个原型对象prototype， 这个原型对象有个属性constructor指向构造函数本身。 而这个构造函数实例有一个内部指针__proto__，指向这个原型 那如果这个原型是另一个类型的实例，就意味着这和原型本身有个指针指向另一个原型，相应另一个原型也有个指针指向另一个构造函数。 这样形成了实例与原型之前的原型链 盗用构造函数 组合继承 原型式继承 寄生式继承 寄生组合继承 寄生式继承父类原型，然后将返回的对象赋值给子类原型 混入式继承 Class 继承 8.4 类 定义方式： 123456789// 类声明 class Foo{}// 类表达式 const Foo1 = class FooName{ //表达式类名FooName可选 identify(){ console.log(Foo1.name ,Foo2.name) //name字段获取类名 // class后定义了类名就是指定类名FooName，否则类名就是Foo1 } } 类是一种特殊的函数typeof，但是并不会有作用域提升 类声明受块级作用域影响，而函数生命则受函数作用域影响 constructor构造函数 构造函数默认返回this，构造函数返回的对象用作实例化的对象 如果这个构造函数返回的不是this对象，而是其他对象，那么通过instanceof操作符不会检测出这个对象与这个类有关。 因为在new操作时，会自动绑定this，如果 123456789101112class Foo { constructor(override) { this.foo = 'foo' if (override) { return {} } }}const foo1 = new Foo()console.log(foo1 instanceof Foo) // trueconst foo2 = new Foo(true)console.log(foo2 instanceof Foo)// false 类中定义的方法成为原型方法 类块中定义的方法都会定义在类的原型上 静态类方法 迭代器、生成器 继承 extends 继承一个类或者一个普通的构造函数 super只能在派生类构造函数和静态方法中使用 调用super()函数会调用父类构造函数，并将返回的实例赋值给this 给父类传参，super()手动传参 在类构造函数中不能在super()之前调用this 在派生类中显示定义了构造函数，必须要调用super或者返回一个对象 抽象基类 供其它类继承，却不被实例化 利用new.target实现 123456789class Foo{ constructor(){ console.log(new.target) //返回Foo类 if(new.target === Foo){ throw new Error('Foo 不能直接被实例化') } }}let f = new Foo() //报错 第九章 代理与反射 9.1 代理 用作目标对象的替身，但独立于对象 1new Proxy(target, handlerObj) //参数两者缺一不可 Proxy.proptotype 为undefined，所以不能使用instanceof操作符 ===严格相等可以用来区分代理和目标 捕获器 get ​ 接受参数（目标对象，要查询的属性，代理对象) 重建被捕获的原始行为： 使用捕获器，被代理的属性如果同时not Configurable and not Writable，则TypeError报错 反射API Reflect delete函数属性—&gt;Refelect.deleteProperty name in obj —&gt; Reflect.has(obj, ‘name’) 可撤销代理 撤销函数和代理对象是同时在实例化时生成的 123456789101112131415const obj = { foo: 'bar'}// 解构 代理对象和撤回函数const { proxy, revoke } =Proxy.revocable(obj, { get(){ return '1234' }})console.log(proxy.foo)//1234revoke() //撤销代理console.log(obj)console.log(proxy)//error 实用反射Reflect API 反射API不局限于捕获程序处理 代替Object上的方法（错误必须try catch捕获 到 反射API返回布尔值） 反射方法return 的值称为“状态标记”的布尔值 代替一些操作符 Reflect. get in set = 赋值操作符 has in 或者 with() deleteProperty delete Construct new 使用Reflect.apply调用函数(被调用函数，this指向，[实参…]) 构建多层拦截网 ​ 代理另一个代理 代理模式 一种编程模式 跟踪属性访问 隐藏属性 12345678910111213141516171819202122232425262728const hiddenProperties = ['age', 'sex']const person = { age: 18, sex: '男', name: '小明'}const proxy = new Proxy(person, { get(TrapTarget, property){ if(hiddenProperties.includes(property)){ return undefined } else { return Reflect.get(...arguments) } }, has(target, property){ if(hiddenProperties.includes(property)){ return false } else { return true } }})console.log(proxy.name)console.log(proxy.age) //undefinedconsole.log('name' in proxy) //trueconsole.log('sex' in proxy)//false 属性验证 ​ 赋值操作触发set，根据情况决定赋值 函数与构造函数参数验证 数据绑定和可观察对象","link":"/posts/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/"},{"title":"RENEW-汇总","text":"一、CSS 1.说一下CSS的盒模型。 ​ 在HTML页面中的所有元素都可以看成是一个盒子 ​ 盒子的组成：内容content、内边距padding、边框border、外边距margin ​ 盒模型的类型： ​ 标准盒模型 ​ margin + border + padding + content ​ IE盒模型 ​ margin + content(border + padding) ​ 控制盒模型的模式：box-sizing:content-box（默认值，标准盒模型）、border-box（IE盒模型）; 2.CSS选择器的优先级？ ​ CSS的特性：继承性、层叠性、优先级 ​ 优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式 ​ 标签、类/伪类/属性、全局选择器、行内样式、id、!important ​ !important &gt; inline样式 &gt; id &gt; class/伪类/属性 &gt; 标签 &gt; 全局选择器 3.隐藏元素的方法有哪些？ ​ display:none; ​ 元素在页面上消失，不占据空间 ​ html元素直接设置hidden ​ opacity:0; ​ 设置了元素的透明度为0，元素不可见，占据空间位置 ​ visibility:hidden; ​ 让元素消失，占据空间位置，一种不可见的状态 ​ position:absolute; clip-path: polygon(0 0, 0 0, 0 0, 0 0)将元素的可见部分裁剪掉 ​ position: absolute; left: -9999px; 4.px和rem的区别是什么？ ​ px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，绝对单位长度 ​ rem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%; ​ 1rem = 10px; （16px*62.5%=10px） 5.重绘重排有什么区别？ ​ 重排（回流Reflow）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小 ​ 重绘 (Repaint)：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制 ​ 浏览器的渲染机制 ​ 对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排 (对元素几何属性修改获取) ​ 对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘 6.让一个元素水平垂直居中的方式有哪些？ ​ 1.定位+margin ​ 2.定位+transform ​ 3.flex布局 ​ 4.grid布局 ​ 5.table布局 7.CSS的哪些属性哪些可以继承？哪些不可以继承？ ​ CSS的三大特性：继承、层叠、优先级 ​ 子元素可以继承父类元素的样式 ​ 1.字体的一些属性：font ​ 2.文本的一些属性：line-height ​ 3.元素的可见性：visibility:hidden ​ 4.表格布局的属性：border-spacing ​ 5.列表的属性：list-style ​ 6.页面样式属性：page ​ 7.声音的样式属性 8.有没有用过预处理器？ ​ 预处理语言增加了变量、函数、混入（重用@include）等强大的功能 ​ SASS LESS ​ nesting写法、@extend样式继承、 二、JavaScript 12基本数据类型：Null Undefined Boolean Number String Symbol Bigint（超过2^53 -1）引用数据类型（复杂数据类型）：Object Function Array 1.JS由哪三部分组成？ ​ ECMAScript：JS的核心内容，描述了语言的基础语法，比如var,for，数据类型（数组、字符串）， ​ 文档对象模型（DOM）：DOM把整个HTML页面规划为元素构成的文档 ​ 浏览器对象模型（BOM）：对浏览器窗口进行访问和操作 2.JS有哪些内置对象？ ​ String Boolean Number Array Object Function Math Date RegExp… ​ Math ​ abs() sqrt() max() min() ​ Data ​ new Data() getYear() ​ Array ​ String ​ concat() length slice() split() 3.操作数组的方法有哪些？ ​ push() pop() sort() splice() unshift() shift() reverse() concat() join() map() filter() ​ ervery() some() reduce() isArray() findIndex() ​ 哪些方法会改变原数组？ ​ push() pop() unshift() shift() sort() reverse() splice() 4.JS对数据类的检测方式有哪些？ ​ typeof() ​ instanceof() 123456789function myInstanceOf(instance, constructor){ let objectProto = instance.__proto__ // Object.getPrototypeOf while(objectProto !== null ){ if(objectProto.__proto__ == constructor.prototype) return true objectProto = objectProto.__proto__ } return false} ​ constructor 1([]).constructor.name; // &quot;Array&quot; ​ Object.prototype.toString.call() 12Array.isArray([]); // trueArray.isArray({}); // false 5.说一下闭包，闭包有什么特点？ ​ 什么是闭包？函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包 ​ 特点：可以重复利用变量，并且这个变量不会污染全局的一种机制；这个变量是一直保存再内存中，不会被垃圾回收机制回收 ​ 缺点：闭包较多的时候，会消耗内存，导致页面的性能下降，在IE浏览器中才会导致内存泄漏 ​ 使用场景：防抖，节流，函数嵌套函数避免全局污染的时候 6.前端的内存泄漏怎么理解？ ​ JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。 ​ 回收机制（标记清除、引用计数） ​ 因素：一些未声明直接赋值的变量；一些未清空的定时器；过度的闭包；一些引用元素没有被清除。 7.事件委托是什么？ 1事件捕获 和 冒泡 阶段 ​ 又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上 ​ 如果子元素组织了事件冒泡，那么委托也就不成立 ​ 组织事件冒泡：event.stopPropagation() ​ addEventListener(‘click’,函数名，true/false) 默认是false（事件冒泡），true（事件捕获） ​ 好处：提高性能，减少事件的绑定，也就减少了内存的占用。 8.基本数据类型和引用数据类型的区别？ ​ 基本数据类型：String Number Boolean undefined null ​ 基本数据类型保存在栈内存当中，保存的就是一个具体的值 ​ 引用数据类型（复杂数据类型）：Object Function Array ​ 保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址 ​ 假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变 9.说一下原型链。 ​ 原型就是一个普通对象，它是为构造函数的实例共享属性和方法；所有实例中引用的原型都是同一个对象 ​ 使用prototype可以把方法挂在原型上，内存值保存一份 ​ __proto__可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype） 10.new操作符具体做了什么？ ​ 1.先创建一个空对象 ​ 2.把空对象和构造函数通过原型链进行链接 ​ 3.把构造函数的this绑定到新的空对象身上 ​ 4.根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型 123456const myNew = function(constructor,...args){ const obj = {} obj.__proto__ = constructor.prototype const res = constructor.apply(obj,args) return res instanceof Object ? res : obj } 11.JS是如何实现继承的？ ​ 1.原型链继承 //篡改父类原型链上的数据 ​ 2.借用构造函数继承 //不能调用父类原型链上的方法 ​ 3.组合式继承 // 父类被调用了两次，影响性能 ​ 4.寄生组合继承 ​ 5.ES6的class类继承 12.JS的设计原理是什么？ ​ JS引擎 运行上下文 调用栈 事件循环 回调 13.JS中关于this指向的问题 全局对象中的this指向 指向的是window 全局作用域或者普通函数中的this 指向全局window this永远指向最后调用它的那个对象 在不是箭头函数的情况下 new 关键词改变了this的指向 apply,call,bind 可以改变this指向，不是箭头函数 箭头函数中的this 它的指向在定义的时候就已经确定了 箭头函数它没有this,看外层是否有函数，有就是外层函数的this，没有就是window 匿名函数中的this 永远指向了window,匿名函数的执行环境具有全局性，因此this指向window 14. script标签里的async和defer有什么区别？ ​ 当没有async和defer这两个属性的时候， 浏览器会立刻加载并执行指定的脚本 有async 加载和渲染后面元素的过程将和script的加载和执行并行进行（异步） 有defer 加载和渲染后面元素的过程将和script的加载并行进行（异步），但是它的执行事件要**等所有元素解析完成**之后才会执行 15.setTimeout最小执行时间是多少？ HTML5规定的内容： setTimeout最小执行时间是4ms setInterval最小执行时间是10ms 16.ES6和ES5有什么区别？ ​ JS的组成：ECMAScript BOM DOM ​ ES5:ECMAScript5,2009年ECMAScript的第五次修订，ECMAScript2009 ​ ES6:ECMAScript6,2015年ECMAScript的第六次修订，ECMAScript2015，是JS的下一个版本标准 17.ES6的新特性有哪些？ ​ 1.新增块级作用域（let,const） ​ 不存在变量提升 ​ 存在暂时性死区的问题 ​ 块级作用域的内容 ​ 不能在同一个作用域内重复声明 ​ 2.新增了定义类的语法糖（class） ​ 3.新增了一种基本数据类型（symbol） ​ 4.新增了解构赋值 ​ 从数组或者对象中取值，然后给变量赋值 ​ 5.新增了函数参数的默认值 ​ 6.给数组新增了API ​ 7.对象和数组新增了扩展运算符 ​ 8.Promise ​ 解决回调地狱的问题。 ​ 自身有all,reject,resolve,race方法 ​ 原型上有then,catch ​ 把异步操作队列化 ​ 三种状态：pending初始状态,fulfilled操作成功,rejected操作失败 ​ 状态：pending -&gt; fulfilled;pending -&gt; rejected 一旦发生，状态就会凝固，不会再变 ​ async await（ES7） ​ 同步代码做异步的操作，两者必须搭配使用 ​ async表明函数内有异步操作，调用函数会返回promise ​ await是组成async的表达式，结果是取决于它等待的内容，如果是promise那就是promise的结果，如果是普通函数就进行链式调用 ​ await后的promise如果是reject状态，那么整个async函数都会中断，后面的代码不执行 ​ 9.新增了模块化（import,export） ​ 10.新增了set和map数据结构 ​ set就是不重复 ​ map的key的类型不受限制 ​ 11.新增了generator ​ 12.新增了箭头函数 ​ 不能作为构造函数使用，不能用new 箭头函数就没有原型 箭头函数没有arguments ​ 箭头函数不能用call,apply,bind去改变this的执行 ​ this指向外层第一个函数的this 18.call,aply,bind三者有什么区别？ ​ 都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同 ​ call方法传的是一个参数列表 ​ apply传递的是一个数组 ​ bind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数还是可以传参的，bind()() ​ call方法的性能要比apply好一些，所以call用的更多一点 19.用递归的时候有没有遇到什么问题？ ​ 如果一个函数内可以调用函数本身，那么这个就是递归函数 ​ 函数内部调用自己 ​ 特别注意：写递归必须要有退出条件return 20.如何实现一个深拷贝？ ​ 深拷贝就是完全拷贝一份新的对象，会在堆内存中开辟新的空间，拷贝的对象被修改后，原对象不受影响 ​ 主要针对的是引用数据类型 ​ 1.扩展运算符 ​ 2.JSON.parse(JSON.stringify()) ​ 3.利用递归函数实现 123456789101112function deepClone(obj){ if(typeof obj !== 'object' || obj ==null) return obj let res = obj instanceof Array ? [] : {} // for in会遍历到obj原型链上的属性，增加判断，健壮性 for(let key in obj){ if(obj.hasOwnProperty(key)){ // 嵌套的一层不会被克隆，所以再加一次深度克隆 res[key] = deepClone(obj[key]) } } return res } 21.说一下事件循环。 ​ JS是一个单线程的脚本语言 ​ 主线程 执行栈 任务队列 宏任务 微任务 ​ 主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务 ​ 全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环！ 22.ajax是什么？怎么实现的？ ​ 创建交互式网页应用的网页开发技术 ​ 在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容 ​ 通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面 ​ 1.创建XmlHttpRequest对象 xmh ​ 2.通过xmh对象里的open()方法和服务器建立连接 ​ 3.构建请求所需的数据，并通过xmh对象的send()发送给服务器 ​ 4.通过xmh对象的onreadystatechange事件监听服务器和你的通信状态 ​ 5.接收并处理服务器响应的数据结果 ​ 6.把处理的数据更新到HTML页面上 23.get和post有什么区别？ ​ 1.get一般是获取数据，post一般是提交数据 ​ 2.get参数会放在url上，所以安全性比较差，post是放在body中 ​ 3.get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据 ​ 4.get请求时会被缓存,post请求不会被缓存 ​ 5.get请求会被保存在浏览器历史记录中,post不会 ​ 6.get请求只能进行url编码，post请求支持很多种 24.promise的内部原理是什么？它的优缺点是什么？ ​ Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果 ​ Promise主要就是解决回调地狱的问题，之前如果异步任务比较多，同时他们之间有相互依赖的关系， ​ 就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也很差 ​ 有三种状态：pending初始状态 fulfilled成功状态 rejected失败状态 ​ 状态改变只会有两种情况， ​ pending -&gt; fulfilled; pending -&gt; rejected 一旦发生，状态就会凝固，不会再变 ​ 首先就是我们无法取消promise，一旦创建它就会立即执行，不能中途取消 ​ 如果不设置回调，promise内部抛出的测u哦呜就无法反馈到外面 ​ 若当前处于pending状态时，无法得知目前在哪个阶段。 ​ 原理： ​ 构造一个Promise实例，实例需要传递函数的参数，这个函数有两个形参，分别都是函数类型，一个是resolve一个是reject ​ promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数，reject是执行第二个函数 25.promise和async await的区别是什么？ ​ 1.都是处理异步请求的方式 ​ 2.promise是ES6，async await 是ES7的语法 ​ 3.async await是基于promise实现的，他和promise都是非阻塞性的 ​ 优缺点： ​ 1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过tra catch进行捕获异常 ​ 2.async await最大的优点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作 ​ promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作 26.浏览器的存储方式有哪些？ ​ 1.cookies ​ H5标准前的本地存储方式 ​ 兼容性好，请求头自带cookie ​ 存储量小，资源浪费，使用麻烦（封装） ​ 2.localstorage 10MB ​ H5加入的以键值对为标准的方式 ​ 操作方便，永久存储，兼容性较好 ​ 保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫 ​ 3.sessionstorage ​ 当前页面关闭后就会立刻清理，会话级别的存储方式 ​ 4.indexedDB 指定配额 ​ H5标准的存储方式，，他是以键值对进行存储，可以快速读取，适合WEB场景 27.token存在sessionstorage还是loaclstorage？ ​ token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串 ​ 1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台 ​ 2.存cookie中，会自动发送，缺点就是不能跨域 ​ 如果存在localstorage中，容易被XSS（跨站脚本）攻击，但是如果做好了对应的措施，那么是利大于弊 ​ 如果存在cookie中会有CSRF（跨站请求伪造，利用浏览器会自动携带cookie）攻击 28.token的登录流程。 ​ 1.客户端用账号密码请求登录 ​ 2.服务端收到请求后，需要去验证账号密码 ​ 3.验证成功之后，服务端会签发一个token，把这个token发送给客户端 ​ 4.客户端收到token后保存起来，可以放在cookie也可以是localstorage ​ 5.客户端每次向服务端发送请求资源的时候，都需要携带这个token ​ 6.服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据 29.页面渲染的过程是怎样的？ ​ DNS解析 ​ 建立TCP连接 ​ 发送HTTP请求 ​ 服务器处理请求 ​ 渲染页面 ​ 浏览器会获取HTML和CSS的资源，然后把HTML解析成DOM树 ​ 再把CSS解析成CSSOM ​ 把DOM和CSSOM合并为渲染树 ​ 布局 ​ 把渲染树的每个节点渲染到屏幕上（绘制） ​ 断开TCP连接 30.DOM树和渲染树有什么区别？ ​ DOM树是和HTML标签一一对应的，包括head和隐藏元素 ​ 渲染树是不包含head和隐藏元素 31.精灵图和base64的区别是什么？ ​ 精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度 ​ base64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串 ​ base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载。 32.svg格式了解多少？ ​ 基于XML语法格式的图像格式，可缩放矢量图，其他图像是基于像素的，SVG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真 ​ 1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作 ​ &lt;svg&gt;&lt;/svg&gt; ​ 2.SVG可作为文件被引入 ​ &lt;img src=&quot;pic.svg&quot; /&gt; ​ 3.SVG可以转为base64引入页面 33.了解过JWT吗？ ​ JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输 ​ 信息传输、授权 ​ JWT的认证流程 ​ 1.前端把账号密码发送给后端的接口 ​ 2.后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT（token）。 ​ 3.前端每日请求时都会把JWT放在HTTP请求头的Authorization字段内 ​ 4.后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期） ​ 5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果 ​ 简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。 34.npm的底层环境是什么？ ​ node package manager,node的包管理和分发工具，已经成为分发node模块的标准，是JS的运行环境 ​ npm的组成：网站、注册表、命令行工具 35.HTTP协议规定的协议头和请求头有什么？ ​ 1.请求头信息： ​ Accept:浏览器告诉服务器所支持的数据类型 ​ Host:浏览器告诉服务器我想访问服务器的哪台主机 ​ Referer:浏览器告诉服务器我是从哪里来的（防盗链） ​ User-Agent:浏览器类型、版本信息 ​ Date:浏览器告诉服务器我是什么时候访问的 ​ Connection:连接方式 ​ Cookie ​ X-Request-With:请求方式 ​ 2.响应头信息： ​ Location:这个就是告诉浏览器你要去找谁 ​ Server:告诉浏览器服务器的类型 ​ Content-Type:告诉浏览器返回的数据类型 ​ Refresh:控制了的定时刷新 36.说一下浏览器的缓存策略。 ​ 强缓存（本地缓存）、协商缓存（弱缓存） ​ 强缓：不发起请求，直接使用缓存里的内容，浏览器把JS，CSS，image等存到内存中，下次用户访问直接从内存中取，提高性能 ​ 协缓：需要像后台发请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回304，浏览器就用缓存里的内容 ​ 强缓存的触发： ​ HTTP1.0:时间戳响应标头 ​ HTTP1.1:Cache-Control响应标头 ​ 协商缓存触发： ​ HTTP1.0:请求头：if-modified-since 响应头：last-modified ​ HTTP1.1:请求头：if-none-match 响应头：Etag 37.说一下什么是“同源策略”？ ​ http:// www. aaa.com:8080/index/vue.js ​ 协议 子域名 主域名 端口号 资源 ​ 同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击 ​ 主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，会产生跨域 ​ 三个允许跨域加载资源的标签：img link script ​ 跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了！ ​ JSONP 利用script标签跨域，动态创建script标签, script.src='xxxx?callback=handleResponse' ​ CORS ​ websocket ​ 反向代理 38.防抖和节流是什么？ ​ 都是应对页面中频繁触发事件的优化方案 ​ 防抖:避免事件重复触发 ​ 使用场景:1.频繁和服务端交互 2.输入框的自动保存事件 12345678910function debounce(fn){ let timer = null return function(){ if(timer) clearTimeout(timer) timer = setTimeout(()=&gt;{ fn.apply(this,arguments) timer = null },500) } } ​ 节流:把频繁触发的事件减少,每隔一段时间执行 ​ 使用场景:scroll事件 1234567891011 function throttle(fn){ let timer = null return function(){ if(timer) return timer = setTimeout(() =&gt; { fn.apply(this,arguments) timer = null }, 500) } }&lt;/scrip 39.解释一下什么是json？ ​ JSON是一种纯字符串形式的数据，它本身不提供任何方法，适合在网络中进行传输 ​ JSON数据存储在.json文件中，也可以把JSON数据以字符串的形式保存在数据库、Cookise中 ​ JS提供了JSON.parse() JSON.stringify() ​ 什么时候使用json：定义接口；序列化；生成token；配置文件package.json 40.当数据没有请求过来的时候，该怎么做？ ​ 可以在渲染数据的地方给一些默认的值 ​ if判断语句 41.有没有做过无感登录？ ​ 1.在相应其中拦截，判断token返回过期后，调用刷新token的接口 ​ 2.后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口 ​ 3.写定时器，定时刷新token接口 ​ 流程： ​ 1.登录成功后保存token 和 refresh_token ​ 2.在响应拦截器中对401状态码（access token 过期）引入刷新token的api方法调用 ​ 3.替换保存本地新的token ​ 4.把错误对象里的token替换 ​ 5.再次发送未完成的请求 ​ 6.如果refresh_token过期了，判断是否过期，过期了就清楚所有token重新登录 42.大文件上传是怎么做的？ ​ 分片上传： ​ 1.把需要上传的文件按照一定的规则，分割成相同大小的数据块 ​ 2.初始化一个分片上传任务，返回本次分片上传的唯一标识 ​ 3.按照一定的规则把各个数据块上传 ​ 4.发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件 ​ 断点续传： ​ 服务端返回，从哪里开始 浏览器自己处理 三、HTML5CSS3 1.语义化的理解。 ​ 在写HTML页面结构时所用的标签有意义 ​ 头部用head 主体用main 底部用foot… ​ 怎么判断页面是否语义化了？ ​ 把CSS去掉，如果能够清晰的看出来页面结构，显示内容较为正常 ​ 为什么要选择语义化？ ​ 1.让HTML结构更加清晰明了 ​ 2.方便团队协作，利于开发 ​ 3.有利于爬虫和SEO ​ 4.能够让浏览器更好的去解析代码 ​ 5.给用户带来良好的体验 2.H5C3有哪些新特性？ ​ H5的新特性： ​ 1.语义化的标签 ​ 2.新增音频视频 ​ 3.画布canvas ​ 4.数据存储localstorage sessionstorage ​ 5.增加了表单控件 email url search… ​ 6.拖拽释放API ​ CSS3的新特性： ​ 1.新增选择器：属性选择器、伪类选择器、伪元素选择器 ​ 2.增加了媒体查询 ​ 3.文字阴影 ​ 4.边框 ​ 5.盒子模型box-sizing ​ 6.渐变 ​ 7.过度 ​ 8.自定义动画 ​ 9.背景的属性 ​ 10.2D和3D 3.rem是如何做适配的？ ​ rem是相对长度，相对于根元素（html）的font-size属性来计算大小，通常来做移动端的适配 ​ rem是根据根元素font-size计算值的倍数 ​ 比如html上的font-size:16px，给div设置宽为1.5rem,1.2rem = 16px*1.2 = 19.2px. 4.解决了哪些移动端的兼容问题？ ​ 1.当设置样式overflow:scroll/auto时，IOS上的滑动会卡顿 ​ -webkit-overflow-scrolling:touch; ​ 2.在安卓环境下placeholder文字设置行高时会偏上 ​ input有placeholder属性的时候不要设置行高 ​ 3.移动端字体小于12px时异常显示 ​ 应该先把在整体放大一倍，然后再用transform进行缩小 ​ 4.ios下input按钮设置了disabled属性为true显示异常 ​ input[typy=button]{ ​ opcity:1 ​ } ​ 5.安卓手机下取消语音输入按钮 ​ input::-webkit-input-speech-button{ ​ display:none ​ } ​ 6.IOS下取消input输入框在输入引文首字母默认大写 ​ ​ 7.禁用IOS和安卓用户选中文字 ​ 添加全局CSS样式：-webkit-user-select:none ​ 8.禁止IOS弹出各种窗口 ​ -webkit-touch-callout:none ​ 9.禁止IOS识别长串数字为电话 ​ 添加meta属性 四、Vue 1.v-if和v-show的区别？ ​ 都可以控制元素的显示和隐藏 ​ 1.v-show时控制元素的display值来让元素显示和隐藏；v-if显示隐藏时把DOM元素整个添加和删除 ​ 2.v-if有一个局部编译/卸载的过程，切换这个过程中会适当的销毁和重建内部的事件监听和子组件；v-show只是简单的css切换 ​ 3.v-if才是真正的条件渲染；v-show从false变成true的时候不会触发组件的声明周期，v-if会触发声明周期 ​ 4.v-if的切换效率比较低 v-show的效率比较高 2.如何理解MVVM的？ 是Model-View-ViewModel的缩写。前端开发的架构模式 ​ M：模型，对应的就是data的数据 ​ V：视图，用户界面，DOM ​ VM：视图模型：Vue的实例对象，连接View和Model的桥梁 ​ 核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定 ​ ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为她是由MVVM统一管理 3.v-for中的key值的作用是什么？ ​ key属性是DOM元素的唯一标识 ​ 作用： ​ 1.提高虚拟DOM的更新 ​ 2.若不设置key，可能会触发一些bug ​ 3.为了触发过度效果 4.说一下你对vue生命周期的理解。 ​ 组件从创建到销毁的过程就是它的生命周期 ​ 创建 ​ beforeCreat ​ 在这个阶段属性和方法都不能使用 ​ created ​ 这里时实例创建完成之后，在这里完成了数据监测，可以使用数据，修改数据，不会触发updated，也不会更新视图 ​ 挂载 ​ beforeMount ​ 完成了模板的编译，虚拟DOM也完成创建，即将渲染，修改数据，不会触发updated ​ Mounted ​ 把编译好的模板挂载到页面，这里可以发送异步请求也可以访问DOM节点 ​ 更新 ​ beforeUpdate ​ 组件数据更新之前使用，数据是新的，页面上的数据时旧的，组件即将更新，准备渲染，可以改数据 ​ updated ​ render重新做了渲染，这时数据和页面都是新的，避免在此更新数据 ​ 销毁 ​ beforeDestroy ​ 实例销毁前，在这里实例还可以用，可以清楚定时器等等 ​ destroyed ​ 组件已经被销毁了，全部都销毁 ​ 使用了keep-alive时多出两个周期： ​ activited ​ 组件激活时 ​ deactivited ​ 组件被销毁时 5.在created和mounted去请求数据，有什么区别？ ​ created：在渲染前调用，通常先初始化属性，然后做渲染 ​ mounted：在模板渲染完成后，一般都是初始化页面后，在对元素节点进行操作 ​ 在这里请求数据可能会出现闪屏的问题，created里不会 ​ 一般用created比较多 ​ 请求的数据对DOM有影响，那么使用created ​ 如果请求的数据对DOM无关，可以放在mounted 6.vue中的修饰符有哪些？ ​ 1.事件修饰符 ​ .stop 组织冒泡 ​ .prevent 组织默认行为 ​ .capture 内部元素触发的事件先在次处理 ​ .self 只有在event.target是当前元素时触发 ​ .once 事件只会触发一次 ​ .passive 立即触发默认行为 ​ .native 把当前元素作为原生标签看待 ​ 2.按键修饰符 ​ .keyup 键盘抬起 ​ .keydown 键盘按下 ​ 3.系统修饰符 ​ .ctrl ​ .alt ​ .meta ​ 4.鼠标修饰符 ​ .left 鼠标左键 ​ .right 鼠标右键 ​ .middle 鼠标中键 ​ 5.表单修饰符 ​ .lazy 等输入完之后再显示 ​ .trim 删除内容前后的空格 ​ .number 输入是数字或转为数字 7.elementui是怎么做表单验证的？ ​ 1.在表单中加rules属性，然后再data里写校验规则 ​ 2.内部添加规则 ​ 3.自定义函数校验 8.vue如何进行组件通信？ ​ 1.父传子 ​ props ​ 父组件使用自定义属性，然后子组件使用props ​ ref​引用信息会注册在父组件的ref ​ 引用信息会注册在父组件的ref​引用信息会注册在父组件的refs对象上 ​ 2.子传父 ​ emit​子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数​3.兄弟传​new一个新的vue实例，用on和emit来对数据进行传输​4.vuex传值​9.keep−alive是什么？怎么使用？​Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们​作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验​10.axios是怎么做封装的？​下载创建实例接着封装请求响应拦截器抛出最后封装接口​11.vue路由时怎么传参的？​params传参​this.emit ​ 子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数 ​ 3.兄弟传 ​ new一个新的vue实例，用on和emit来对数据进行传输 ​ 4.vuex传值 ​ 9.keep-alive是什么？怎么使用？ ​ Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们 ​ 作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验 ​ 10.axios是怎么做封装的？ ​ 下载 创建实例 接着封装请求响应拦截器 抛出 最后封装接口 ​ 11.vue路由时怎么传参的？ ​ params传参 ​ this.emit​子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数​3.兄弟传​new一个新的vue实例，用on和emit来对数据进行传输​4.vuex传值​9.keep−alive是什么？怎么使用？​Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们​作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验​10.axios是怎么做封装的？​下载创建实例接着封装请求响应拦截器抛出最后封装接口​11.vue路由时怎么传参的？​params传参​this.router.push({name:‘index’,params:{id:item.id}}) ​ this.route.params.id​路由属性传参​this.route.params.id ​ 路由属性传参 ​ this.route.params.id​路由属性传参​this.router.push({name:'/index/{item.id}'}) ​ 路由配置 { path:'/index:id' } ​ query传参（可以解决页面刷新参数丢失的问题） ​ this.router.push({ ​ name:‘index’, ​ query:{id:item.id} ​ }) 12.vue路由的hash模式和history模式有什么区别？ ​ 1.hash的路由地址上有#号，history模式没有 ​ 2.在做回车刷新的时候，hash模式会加载对应页面，history会报错404 ​ 3.hash模式支持低版本浏览器，history不支持，因为是H5新增的API ​ 4.hash不会重新加载页面，单页面应用必备 ​ 5.history有历史记录，H5新增了pushState和replaceState()去修改历史记录，并不会立刻发送请求 ​ 6.history需要后台配置 13.路由拦截是怎么实现的？ ​ 路由拦截 axios拦截 ​ 需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截 1234567891011121314151617 { name:'index',​ path:'/index',​ component:Index,​ meta:{​ requirtAuth:true​ }​ }​ router.beforeEach((to,from,next) =&gt; {​ if(to.meta.requirtAuth){​ if( store.satte.token ){​ next()​ }else{​ } } }) 14.说一下vue的动态路由。 ​ 要在路由配置里设置meat属性，扩展权限相关的字段，在路由导航守卫里通过判断这个权限标识，实现路由的动态增加和跳转 ​ 根据用户登录的账号，返回用户角色 ​ 前端再根据角色，跟路由表的meta.role进行匹配 ​ 把匹配搭配的路由形成可访问的路由 15.如何解决刷新后二次加载路由？ ​ 1.window.location.reload() ​ 2.matcher ​ const router = createRouter() ​ export function resetRouter(){ ​ const newRouter = creatRouter() ​ router.matcher = newRouter.matcher ​ } 16.vuex刷新数据会丢失吗？怎么解决？ ​ vuex肯定会重新获取数据，页面也会丢失数据 ​ 1.把数据直接保存在浏览器缓存里（cookie localstorage sessionstorage） ​ 2.页面刷新的时候，再次请求数据，达到可以动态更新的方法 ​ 监听浏览器的刷新书简，在刷新前把数据保存到sessionstorage里，刷新后请求数据，请求到了用vuex，如果没有那就用sessionstorage里的数据 17.computed和watch的区别？ ​ 1.computed是计算属性，watch是监听，监听的是data中数据的变化 ​ 2.computed是支持缓存，依赖的属性值发生变化，计算属性才会重新计算，否则用缓存；watch不支持缓存 ​ 3.computed不支持异步，watch是可以异步操作 ​ 4.computed是第一次加载就监听，watch是不监听 ​ 5.computed函数中必须有return watch不用 18.vuex在什么场景会去使用？属性有哪些？ ​ state 存储变量 ​ getters state的计算属性 ​ mutations 提交更新数据的方法 ​ actions 和mutations差不多，他是提交mutations来修改数据，可以包括异步操作 ​ modules 模块化vuex ​ 使用场景： ​ 用户的个人信息、购物车模块、订单模块 19.vue的双向数据绑定原理是什么？ ​ 通过数据劫持和发布订阅者模式来实现，同时利用Object.defineProperty()劫持各个属性的setter和getter， ​ 在数据发生改变的时候发布消息给订阅者，触发对应的监听回调渲染视图，也就是说数据和视图时同步的，数据发生改变，视图跟着发生改变，视图改变，数据也会发生改变。 ​ 第一步：需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter ​ 第二步：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图 ​ 第三步：Watcher订阅者是Observer和Compile之间的通信桥梁，作用： ​ 1.在自身实例化的时候忘订阅器内添加自己 ​ 2.自身要有一个update()方法 ​ 3.等待属性变动时，调用自身的update方法，触发compile这种的回调 ​ 第四步：MVVM作为数据绑定的入口，整合了observer、compile和watcher三者，通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher把observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果 20.了解diff算法和虚拟DOM吗？ ​ 虚拟DOM，描述元素和元素之间的关系，创建一个JS对象 ​ 如果组件内有响应的数据，数据发生改变的时候，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的虚拟DOM内容，然后去对应的真实DOM中修改 ​ diff算法就是虚拟DOM的比对时用的，返回一个patch对象，这个对象的作用就是存储两个节点不同的地方，最后用patch里记录的信息进行更新真实DOM ​ 步骤： ​ 1.JS对象表示真实的DOM结构，要生成一个虚拟DOM，再用虚拟DOM构建一个真实DOM树，渲染到页面 ​ 2.状态改变生成新的虚拟DOM，跟就得虚拟DOM进行比对，这个比对的过程就是DIFF算法，利用patch记录差异 ​ 3.把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了。 21.vue和jquery的区别是什么？ ​ 1.原理不同 ​ vue就是数据绑定；jq是先获取dom再处理 ​ 2.着重点不同 ​ vue是数据驱动，jq是着重于页面 ​ 3.操作不同 ​ 4.未来发展不同 22.vuex的响应式处理。 ​ vuex是vue的状态管理工具 ​ vue中可以直接触发methods中的方法，vuex是不可以的。未来处理异步，当触发事件的时候，会通过dispatch来访问actions中的方法，actions中的commit会触发mutations中的方法从而修改state里的值，通过getter把数据更新到视图 ​ Vue.use(vuex)，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store就可以访问到store对象。 ​ vuex的state是响应式的，借助的就是vue的data，把state存到vue实例组件的data中 23.vue中遍历全局的方法有哪些？ ​ 1.普通遍历，对象.forEach() ​ arr.forEach(function(item,index,arr){ ​ console.log(item,index) ​ }) ​ 2.对元素统一操作 对象.map() ​ var newarr = arr.map(function(item){ ​ return item+1 ​ }) ​ 3.查找符合条件的元素 对象.filter() ​ arr.filter(function(item){ ​ if(item &gt; 2){ ​ return false ​ }else{ ​ return true ​ } ​ }) ​ 4.查询符合条件的元素，返回索引 对象.findindex() ​ arr.finindex(function(item){ ​ if(item&gt;1){ ​ return true ​ }else{ ​ return false ​ } ​ }) ​ 对象.evening() 遇到不符合的对象会停止 ​ 对象.some() 找到符合条件的元素就停止 24.如何搭建脚手架？ ​ 下载：node cnpm webpack vue-cli ​ 创建项目： ​ 1.找到对应的文件，然后利用node指令创建（cmd） ​ 2.vue init webpack xxxx ​ 3.回车项目描述 ​ 4.作者回车 ​ 5.选择vue build ​ 6.回车 ​ 7.输入n ​ 8.不按照yarn ​ 9.输入npm run dev 25.如何封装一个组件？ ​ 1.使用Vue.extend()创建一个组件 ​ 2.使用Vue.components()方法注册组件 ​ 3.如果子组件需要数据，可以在props中接收定义 ​ 4.子组件修改好数据，要把数据传递给父组件，可以用emit()方法 ​ 原则： ​ 把功能拆开 ​ 尽量让组件原子化，一个组件做一件事情 ​ 容器组件管数据，展示组件管视图 26.封装一个可复用的组件，需要满足什么条件？ ​ 1.低耦合，组件之间的依赖越小越好 ​ 2.最好从父级传入信息，不要在公共组件中请求数据 ​ 3.传入的数据要进行校验 ​ 4.处理事件的方法写在父组件中 27.vue的过滤器怎么使用？ ​ vue的特性，用来对文本进行格式化处理 ​ 使用它的两个地方，一个是插值表达式，一个是v-bind ​ 分类： ​ 1.全局过滤器 ​ Vue.filter(‘add’,function(v){ ​ return v &lt; 10 ? ‘0’ + v : v ​ }) &lt;div&gt;{{33 | add}}&lt;/div&gt; ​ 2.本地过滤器 ​ 和methods同级 ​ filter:{ ​ add:function(v){ ​ return v &lt; 10 ? ‘0’ + v : v ​ } ​ } 28.vue中如何做强制刷新？ ​ 1.localtion.reload() ​ 2.this.$router.go(0) ​ 3.provide和inject 29.vue3和vue2有哪些区别？ ​ 1.双向数据绑定的原理不同 ​ 2.是否支持碎片 ​ 3.API不同 ​ 4.定义数据变量方法不同 ​ 5.生命周期的不同 ​ 6.传值不同 ​ 7.指令和插槽不同 ​ 8.main.js不同 30.vue的性能优化怎么做？ ​ 1.编码优化 ​ 不要把所有数据都放在data中 ​ v-for时给每个元素绑定事件用事件代理 ​ keep-alive缓存组件 ​ 尽可能拆分组件，提高复用性、维护性 ​ key值要保证唯一 ​ 合理使用路由懒加载，异步组件 ​ 数据持久化存储的使用尽量用防抖、节流优化 ​ 2.加载优化 ​ 按需加载 ​ 内容懒加载 ​ 图片懒加载 ​ 3.用户体验 ​ 骨架屏 ​ 4.SEO优化 ​ 预渲染 ​ 服务端渲染ssr ​ 5.打包优化 ​ CDN形式加载第三方模块 ​ 多线程打包 ​ 抽离公共文件 ​ 6.缓存和压缩 ​ 客户端缓存、服务端缓存 ​ 服务端Gzip压缩 31.首屏优化该如何去做？ ​ 1.使用路由懒加载 ​ 2.非首屏组件使用异步组件 ​ 3.首屏不中要的组件延迟加载 ​ 4.静态资源放在CDN上 ​ 5.减少首屏上JS、CSS等资源文件的大小 ​ 6.使用服务端渲染 ​ 7.简历减少DOM的数量和层级 ​ 8.使用精灵图请求 ​ 9.做一些loading ​ 10.开启Gzip压缩 ​ 11.图片懒加载 32.vue3的性能为什么比vue2好？ ​ 1.diff算法的优化 ​ 2.静态提升 ​ 3.事件侦听缓存 33.vue3为什么使用proxy？ ​ 1.proxy可以代理整个对象，defineproperty只代理对象上的某个属性 ​ 2.proxy对代理对象的监听更加丰富 ​ 3.proxy代理对象会生成新的对象，不会修改被代理对象本身 ​ 4.proxy补兼容ie浏览器 34.说一下你对组件的理解。 ​ 可以重复使用的vue实例，独一无二的组件名称 ​ 可以抽离单独的公共模块 ​ 提高代码的复用率 35.你是如何规划项目文件的？ ​ public ​ 图标、index.html、img ​ src ​ api ​ assets ​ components ​ 按分类再次划分子目录 ​ plugins ​ router ​ static ​ styles ​ utils ​ views ​ App.vue ​ main.js ​ package.json ​ vue.config.js 36.是否使用过nuxt.js？ ​ 是基于vue的应用框架，关注的是渲染，可以开发服务端渲染应用的配置 ​ SSR：服务端渲染 ​ 好处： ​ SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索 ​ 优化了首屏加载时间 ​ SEO：优化搜索引擎 ​ SPA的应用不利于搜索引擎SEO的操作 37.SEO如何优化？ ​ 1.SSR ​ 2.预渲染 prerender-spa-plugin 五、Echarts ​ 1.echarts有用过吗？常用的组件有哪些？ ​ title标题组件 show text link ​ toolbox工具栏 导出图片 数据视图 切换 缩放 show orient feature ​ tooltip tigger 触发类型 ​ markPoint标注点 ​ markLine图标的标线 六、Uni-APP ​ 1.uni-app有没有做过分包？ ​ 优化小程序的下载和启动速度 ​ 小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示 七、Weabpack ​ 1.webpack打包和不打包的区别？ ​ 1.运行效率 ​ 2.对基础的支持不够 ​ 2.webpack是怎么打包的，babel是做什么的？ ​ webpack会把js css image看作一个模块，用import/require引入 ​ 找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起 ​ 把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件 ​ 如果一个被多个文件引用，打包时只会生成一个文件 ​ 如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包 ​ 对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中 八、Git ​ 1.git如何合并、拉取代码？ ​ 拉取代码 git pull ‘仓库地址’ ​ 查看状态 git status ​ 提交到本地缓存区 git add . ​ 提交本地仓库 git commit -m ‘修改描述’ ​ 提交到远程仓库 git push ‘仓库地址’ master ​ 创建分支 git branch -b xxx ​ 合并分支 git merge ‘合并分支的名字’ ​ 2.git如何解决冲突问题？ ​ 1.两个分支中修改了同一个文件 ​ 2.两个分支中修改了同一个文件的名字 ​ 1.解决：当前分支上，直接修改代码 add commit ​ 2.解决：在本地当前分支上，修改冲突代码 add commit push","link":"/posts/RENEW-%E6%B1%87%E6%80%BB/"},{"title":"React小记","text":"React库和框架的区别是什么？ 页面组件化 数据驱动 MVC V层 react库 ​ react.js是一个开放的js工具库，用于基于UI自检构建用户界面 react框架 ​ 通过脚手架工具搭建的一套完善的前端环境，包括：路由、状态管理、数据获取、第三方的UI组件库和第三方Hooks库(ahooks react-use) 严格模式 ​ 检查组件是否为纯函数 ​ 及早的发现useEffect中的错误 ​ 警告过时的API ESLint ​ 代码规范插件 npm run lint vite-plugin-eslint （vite构建下） Prettier ​ 代码格式化插件 react模块 ​ 核心功能 ​ 组件 react-dom ​ 操作浏览器DOM ​ react-dom/client 客户端渲染使用 ​ react-dom/server 服务端渲染使用 分离不同代码库，可跨平台使用 比如 编写react-native应用，当然不用使用react-dom模块 利用编译器编译成中间这种reactElement对象格式(虚拟DOM)，再利用react-dom库完成 fragment &lt;&gt;&lt;/&gt; 简写，这种方式不能写key classnames 控制样式 事件 ​ 合成事件：处理事件有差异（onmouseenter 实际使用的是over） ​ 事件委托：委托到容器’root’元素 ​ 传参处理 ​ 箭头函数 ​ 高阶函数 条件渲染 ​ 条件分支if else switch case ​ 三目 ? : ​ 逻辑运算符 || ?? &amp;&amp; 不会渲染的值：null、undefined、boolean、‘’ 、对象、函数 利用JSON.stringify() 或者 {undefied +‘’}(拼接空串) ​ 数组渲染 ​ jsx默认对数组进行join()操作 ​ 循环语句 ​ ​ 数组方法（map） 必须写key 帮助react推断发生了什么，从而得以正确的更新DOM树 跟踪列表每一项的身份， 唯一标识 组件的点标记写法 对象形式 ​ 组件写为对象的方法 ​ 可解构使用 函数形式（更好的进行组件分类 ​ 将组件直接挂载在上级组件上 ​ 组件通信方式 props传递值 ​ 整体接收， 解构接收 props传递事件 通过扩展运算符{…}批量上传 组件组合方式 插槽 利用props的children属性 ​ 指定顺序 props默认值 ​ 利用es6的默认值方式 ​ react的defaultProps props类型限定 ​ 使用ts ​ 使用第三方proptypes 组件纯函数 ​ 只负责自己的任务，不会在更改函数调用前就已存在的对象和变量。（不能修改这个函数组件作用域外的对象和变量） ​ 严格模式检测当前组件是否为纯函数，对这函数调用两次，检测值是否变化 ​ 输入相同，则输出相同。纯函数总是返回相同的结果。 ​ 不管调用多次，函数都输出同一个值，对于测试更方便。增强健壮性 组件的状态 瞬间变化的数据被称为状态（state），状态可以进行数据驱动 useState hooks 提供 状态 和 修改状态的方法 ​ 普通变量 无法重新渲染JSX ​ state状态，重新触发函数组件，并且具备组件的记忆。 ​ 普通纯函数函数， 多次调用执行结果 状态是如何改变视图的 渲染与提交的过程 1️⃣触发一次渲染 ​ 💡组件的初次渲染，createRoot.render ​ 🔦内部状态更新，触发渲染送入队列 2️⃣渲染您的组件 ​ 💡在进行初次渲染，react调用根组件&lt;App/&gt; ​ 🔦内部状态更新，会渲染对应的函数组件 3️⃣提交到DOM上 ​ 💡初次渲染，appendChild DOM API ​ 🔦内部状态更新，更新差异的DOM节点 多状态如何正确记忆？ 同一个组件的每次渲染中，useState都依托于一个稳定的调用顺序 在react内部，每个组件保存了一个数组， 按照索引记忆usestate位置。[{索引，useState对}] 所以不要将useState写到一些分支逻辑中，会打乱useState顺序 配合eslint检查，语法是否合规 状态的快照 本次作用域中的状态不会改变 点击后，触发三次setcount，但是当前作用域的count都为0 快照的陷阱，异步的时候造成错觉，其实异步逻辑中的状态还是依赖于这次函数作用域 词法作用域，只看定义，不看调用 状态队列与自动批处理 自动批处理 ​ 等事件处理函数中的所有代码都运行完毕再处理你的state更新 ​ 队列都执行完毕后，在进行ui更新 更新函数的写法 形参c来自于react内部，所以这里并不是保存的count快照，连续调用三次后，得到3 更新函数在内部还是以回调的形式，但没使用形参 严格遵守状态不可变 默认情况下，修改的状态跟上一次相同的情况下，是不会重新触发渲染 引用数据类型 拷贝 ​ 数组，使用相关方法 ​ 扩展运算符 ​ 深克隆（将没改变的数据也是克隆了一份） ​ immer useimmer 可以直接对数据进行修改 惰性初始化状态的值 当状态的值组要通过复杂计算才能得到的话，可以对其进行惰性初始化 只在初始化的时候执行一次 状态提升解决共享问题 父组件管理状态，子组件props 状态的重置处理问题 当组件被销毁会时，所对应的状态也会被重置 当组件位置没有发生变化，状态会被保留 组件渲染位置发生变化，状态不被保留 不同的结构体，给组件添加key属性 diff算法，同层级的元素是否发生改变 利用状态产生计算变量 根据状态会重新渲染组件的特性，利用当前状态快照生成对应的计算变量 受控组件与非受控组件 通过props控制的组件成为受控，通过state控制的组件称为非受控组件 react表单内置了受控组件的行为 ​ value + onChange ​ checked + onChange input标签并不是原始的标签 123456789101112131415const App = () =&gt; { const [value, setValue] = useState(&quot;&quot;); return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={value} onChange={(e) =&gt; { console.log(e.target.value); setValue(e.target.value) }} /&gt; &lt;/div&gt; );}; Hooks react中以use开头的函数被称为Hook钩子，Hooks被称为use函数的集合，也就是钩子的集合 Hooks就是一堆功能函数，（像插件 分为： 内置、自定义、第三方 useRef 使用ref引用一个值，具备记忆功能 改变ref不会触发重新渲染组件 定时器案例：timer用ref存储，始终引用的同一个值 useref进行dom操作 ​ 如：让元素获取焦点，滚动到他或测量尺寸位置 回调写法，在逻辑中操作dom forwardRef 给组件设置ref需要forwardRef转发 forwardRef让您的组件通过ref向父组件公开DOM节点 直接转发ref给子组件报错 useImperativeHandle 自定义由ref暴露出来的句柄 纯函数处理useEffect 纯函数： 副作用： ​ 函数在执行过程中对外部造成的影响成为副作用，如ajax、dom操作、与外部系统同步 ​ 事件可以处理副作用，onclick事件等 ​ 处理副作用，借助useEffect钩子 useEffect触发时机，jsx渲染后触发 依赖项，内部通过Object.is() 方法判定 ​ 当依赖项为空，指挥初始渲染 ​ ESLint会检查依赖项是否正确，包括props state 计算变量 函数写在useEffect中 useCallback 函数始终是同一个 每次重新渲染函数，函数指向地址发生改变 useEffect清理工作 严格模式，检测有无做清理工作 初始化数据时，注意清理操作， ​ 更简洁的方法是使用第三方，ahooks的useRequest useEffectEvent useLayoutEffect 同步执行状态更新 useEffect是在渲染之后，更新之前 如过需要在useEffect中处理DOM，并且改变页面的样式，就需要使用useLayoutEffect， useInsertionEffect DOM更新前触发 此时拿不到dom元素 在css-in-js库中使用的多 useReducer 局部的状态管理，抽离逻辑 useImmerReducer immer类型数据 Context向组件深层次传递数据 reducer配合context实现状态数据共享 更复杂的情况使用第三方库,redux mobx,zuster memo在props不变时跳过重新渲染 达到一些性能优化 props改变的情况下，会重新渲染组件 没有props useMemo对计算结果进行缓存 虽然使用memo，并且props 数组list****值未变化，但是list的引用地址发生变化，底层使用Object.is([], []) ==&gt;flase 比较，则props值改变 使用useMemo对计算数据进行缓存（类似useCallback缓存函数） useCallback对函数进行缓存 useMemo的一种特殊写法 12const fn = useMemo(()=&gt; () =&gt; { console.log(1) })const fn = useCallback(() =&gt; { console.log(1) }) StartTrasition 方法及并发模式 ​ react18开始，渲染是一个单一的、不间断的、同步的事务，一旦渲染开始，就不能被中断 react18引入并发模式，允许标记更新作为一个transition，这回告诉react它们可以被中断执行。这样可以把紧急的任务先更新，不紧急的任务后更新 任务切换 useTrasition hook 提供一个pending状态的布尔值，（配合实现一个loading效果），还有一个startTrasition方法 useDeferredValue 延迟 获取该值的延迟版本 useId 产生唯一标识 id 局部前缀 ​ xxx + id (字符串拼接) id 全局前缀 ​ createRoot 第二参 123ReactDOM.createRoot(document.getElementById('root')!, { identifierPrefix: 'xxx'}) useDebugValue 在自定义hook中打印信息，devtool useSyncExternalStore 操作状态 订阅外部 store 的 React Hook。","link":"/posts/react%E5%B0%8F%E8%AE%B0/"},{"title":"Typora图床","text":"Llllllb, 购买了正版Typora之后，终于可以美美享受图床服务咯 图床平台：sm.ms 5.00 GB免费空间 上传服务器：PicGo 手把手步骤： sm.ms 注册 获取Token PicGo 全局下载 CLI：yarn add global picgo 配置：picgo set 全部默认就行（图床选择 smms） 查看配置：macos 默认保存在~/.picgo目录下 vim ~/.picgo/config.json Typora 设置 &gt; 图像 &gt; 上传服务设置 使用 OMG 你怎么知道我 3.8.2024 要去THE ERAS TOUR Singapore","link":"/posts/typora%E5%9B%BE%E5%BA%8A/"},{"title":"npm","text":"node package manager 基于命令行的工具 安装、卸载、更新、发布 version 版本号x,y,z 主 次 补丁 ^ 锁定从左边数第一个非0的 锁定主版本or次版本 latest 最新版本 依赖 dependecies devDependencies 开发依赖 peerDependencies 对等依赖，（插件不能凭空运行，需要依赖某一模块） 一些常用命令 npm config list 查看npm配置信息 npm get registry 查看镜像源 npm set registry xxxx设置镜像源 npm ls (-g) 当前（全局）安装的可执行文件 npm install 原理 安装依赖存放于根目录node_modules文件夹 排序: .bin @系列 abcd排序 广度优先，扁平化（理想情况下）处理下载 非理想： node_modules下a b 模块依赖不同版本的c模块，会给b模块下再建立一个node_modules文件夹 pakage-lock.json 锁定版本号 缓存： intergrity + verion + name 生成唯一的key，这个key在缓存文件中, npm config list 查看中的cache index-v5 索引目录，记录content-v2的索引位置，对应的 intergrity + verion + name由算法生成的哈希值 对应得上，就将这个加密的包解压到node_modules中 pakage-lock.json pakage.json 不一致 按照pakage中的版本下载，并更新lock中的版本号 一直 先找缓存，没有再下载资源 npm run 可执行命令都存在node_modules下的.bin文件夹中 当前项目node_modules/.bin 中查找 全局的node_modules查找 环境变量中查找 报错 也是有生命周期的 12345{ &quot;predev&quot;: &quot;node 1.js&quot;, &quot;dev&quot;: &quot;node 2.js&quot;, &quot;postdev&quot;: &quot;node 3.js&quot;} 运行 npm run dev, 自动执行了 1.js 2.js 3.js 比如一个打包命令，之前可以做一个清理的任务，最后做一个发布的工作，比如写一个CI脚本顺便把代码提交了 Vue-cli也是用了生命周期pretest: ‘yarn clean’ npx npm高版本自带的命令行工具 运行node_modules/.bin 下的可执行文件 之前通过package.json 中的scripts 配合npm run实现，现在可通过npx运行不需要安装这个依赖包运行命令 避免全局安装 当前项目node_modules/.bin —&gt; 全局modules/.bin —&gt; 官网下载，用完删除（需要联网），减少内存占用 总是使用最新版本 执行任意npm包 在一个项目中，npm i vite 没有全局安装，直接运行vite肯定是不行的， 此时配合npx， npx vite 在项目中的node_modules/.bin中查找运行 与npm区别 npx侧重执行命令 npm侧重安装或卸载某个模块，不具备执行某个模块的功能 发布npm包 npm addUser（创建npm账号） npm login 登录( 使用官方的源，而不是第三方镜像源) npm publish 发布（同版本号不能重新发布，包名唯一） 构建npm私服 部署到内网集群，离线使用 安全性 提高包下载速度 利用verdaccio库 npm i verdaccio -g verdaccio --listen 5000 开启服务 发包流程与之前的差不多","link":"/posts/npm/"},{"title":"NEW START","text":"迷茫是自由产生的旋涡 顺其自然，随意地飘去吧 真实自有万钧之力 …","link":"/posts/NEW-START/"},{"title":"redux-toolkit学习","text":"Redux-Toolkit 摘自官网 Redux Toolkit 是 Redux 官方强烈推荐，开箱即用的一个高效的 Redux 开发工具集。 简化最常见场景下的 Redux 开发， ​ 包括配置 store、定义 reducer，不可变的更新逻辑 ​ 可以立即创建整个状态的 “切片 slice”，而无需手动编写任何 action creator 或者 action type 自带了一些最常用的 Redux 插件， ​ 例如用于异步逻辑 Redux Thunk， ​ 用于编写选择器 selector 的函数 Reselect （可缓存select数据） 在 Redux 中,**切片(Slice)**指的是使用 createSlice API 创建的 reducer 和 action 的组合。它是 Redux Toolkit 中的一个核心概念。 createSlice 接收一个配置对象参数,里面包含: 初始 state reducers:包含不同 reducer 的对象 extraReducers:处理 action 的 reducer 函数 切片让我们可以把 reducer 与 action 打包在一起 创建简化了编写 reducer 的流程 自动生成 action 类型 ⚙️ CRA新建一个react项目 create-react-app myapp --template typescript ⚙️ 安装react-redux react-toolkit npm install @reduxjs/toolkit react-redux 项目基本结构 新建状态管理主文件 12345678910111213// store.tsimport { configureStore } from &quot;@reduxjs/toolkit&quot;import counterReducer from &quot;./slice/counterSlice&quot; // 由切片导入的reducerexport const store = configureStore({ reducer: { counter: counterReducer }})// 根据store本身推断出推断 `RootState` 和 `AppDispatch`类型export type RootState = ReturnType&lt;typeof store.getState&gt;export type AppDispatch = typeof store.dispatch 在项目入口文件，给App组件注入store 1234567891011// index.tsx//....import { store } from './redux/store'const root = ReactDOM.createRoot( document.getElementById('root') as HTMLElement);root.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;); 创建切片 之前利用 都要分别写各自actionCreator和各自的reducer， 现在只用一个切片即可管理 😇 React Toolkit 创建的 Slice 状态state本身是 immutable 的，所以可以放心的直接加工使用 123456789101112131415161718192021222324252627282930313233// src/redux/slice/counterSlice.tsimport { createSlice } from &quot;@reduxjs/toolkit&quot;import { PayloadAction } from &quot;@reduxjs/toolkit&quot;interface ICounterState { value: number}const initialState: ICounterState = { value: 1}// 创建切片export const counterSlice = createSlice({ name: 'counter', initialState, reducers: { increment: (state) =&gt; { state.value += 1 }, decrement: (state) =&gt; { state.value -= 1 }, incrementByAmount: (state, action: PayloadAction&lt;number&gt;) =&gt; { state.value += action.payload }, }})// Action creators 会在各自的reducer函数中自动创建， 这里直接导出export const { increment, decrement, incrementByAmount } = counterSlice.actions// 💡注意&gt; 默认导出的是reducerexport default counterSlice.reducer 尝试在App.tsx组件中使用 123456789101112131415161718192021import React from 'react'import { useDispatch, useSelector } from 'react-redux'import { AppDispatch, RootState } from './redux/store'import { decrement, increment, incrementByAmount } from './redux/slice/counterSlice'const App: React.FC = () =&gt; { const count = useSelector((state: RootState) =&gt; state.counter.value) const disptach = useDispatch&lt;AppDispatch&gt;() return ( &lt;div className=&quot;App&quot;&gt; {count} &lt;button onClick={() =&gt; disptach(increment())}&gt;点击我+1&lt;/button&gt; &lt;button onClick={() =&gt; disptach(decrement())}&gt;点击我-1&lt;/button&gt; &lt;button onClick={() =&gt; disptach(incrementByAmount(100))}&gt;点击我+100&lt;/button&gt; &lt;/div&gt; );}export default App; ✅成功","link":"/posts/redux-toolkit%E5%AD%A6%E4%B9%A0/"},{"title":"一键速通菲区Spotify","text":"prerequisite 菲区电话卡、菲区梯子🪜 流程 Spotify换区（挂上🇵🇭🪜） 某宝下单菲律宾电话卡（推荐Globe卡￥20+） 话费充值（推荐易付宝， Google Play下载） 登录进入手机端Spotify，选择套餐通过话费充值 切记💡 第三步，必须在手机端中操作，账号登录成功后不要挂任何🪜，网络直连就行 Other 也可以试试GCash支付，需要实名。 应填写真实的信息（护照等），不然一个月之内检测被封。（谷歌搜有相应的教程）","link":"/posts/%E4%B8%80%E9%94%AE%E9%80%9F%E9%80%9A%E8%8F%B2%E5%8C%BASpotify/"},{"title":"博客网站搭建","text":"一个前端开发者没有一个博客像什么话呢？ 因为这个网上搜寻了一番，如何搭建一个博客。 虽然也没什么好写的，而且分享的东西也只不过是别人嘴里吐出来的话罢了。（管他的， im just a 菜鸡🤡 大部分人用的hexo这个静态站点生成器，而且也有很多现成的模版 嘻嘻，最终被我发现了Frame这个主题。虽然开箱即用的功能没其他主题多，胜在这完美的UI，简约高级！！！ 加了一些新功能 国际化（虽然也just用在了主页 评论 disqus 文章TOC 还有一些小修改。。。 最后也跟着网上的步骤直接部署在github page上，后也在用vercel一键部署，但是vercel被大陆block了，并且url也带着.vercel，真的有点丑 后面又想着自己弄一个域名 秉持着能白嫖就白嫖的理念🤣 ​ 域名平台肯定是想用：久闻盛名的免费域名平台freenom，好景不长，早已关闭了申请通道 ​ 最后搜到了namesoli这个平台。第一年，在使用了优惠🐴后.top域名首年只要人民币7块 ​ 在加个cdn就完美了 ​ 提到cdn肯定就想到某慈善家cloudflare ，直接选择free plan加速我想部署的vercel项目，利用边缘服务器，直接在大陆也可访问咯，但是感觉速度还是不如githubpage 归根来说就是直接 hexo github vercel namesoli cloudflare 一把子梭哈，时刻羡慕米国人可以直接用上这么好的技术。。。。😇 参考网站 NameSilo域名解析和DNS服务器修改教程","link":"/posts/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"},{"title":"滑动验证","text":"最近在写一个注册表单的需要一个滑动验证模块。 👨‍💻网上搜寻一番，发现了一个组件比较好用vue3-puzzle-vcode 配合ELement-Plus: dialog 和 form 组件使用 Login组件控制Register表单组件显示 1234567891011121314151617//login.vue&lt;script lang=&quot;ts&quot; setup&gt;import { ref } from 'vue'import Register from '@/components/Register.vue'const registerDiaVisible = ref(false)const openRegisterDia = () =&gt; { registerDiaVisible.value = true}&lt;/script&gt;&lt;template&gt;...&lt;Register v-model:registerDiaVisible=&quot;registerDiaVisible&quot; /&gt;...&lt;/template&gt; Register组件 （表单校验成功后，打开滑动验证组件，再次成功调用onSuccess） 注意调整滑动验证组件的z-index，默认el-dialog组件层级高于Vcode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;script lang=&quot;ts&quot; setup&gt;import { formPost } from '@/api/request'import { ElMessage, FormInstance } from 'element-plus'import { reactive, ref } from 'vue'import { RegisterForm } from '@/ts/interfaces/login.interface'import Vcode from 'vue3-puzzle-vcode'const props = defineProps&lt;{ registerDiaVisible: boolean}&gt;()const emit = defineEmits&lt;{ 'update:registerDiaVisible': [registerDiaVisible: boolean]}&gt;()const handleCancel = () =&gt; { emit('update:registerDiaVisible', false)}//表单绑定的响应式对象const formData = reactive({ nickName: '', realName: '', pwd: ''})// 表单的引用对象const formRef = ref()// 表单校验const rules = reactive({ nickName: [ { required: true, message: '请输入昵称', trigger: 'blur' }, { min: 3, max: 10, message: '请输入3-10位昵称', trigger: 'blur' } ], realName: [ { required: true, message: '请输入用户名', trigger: 'blur' }, { min: 3, max: 10, message: '请输入3-10位用户名', trigger: 'blur' } ], pwd: [ { required: true, message: '请输入密码', trigger: 'blur' }, { min: 3, max: 10, message: '请输入3-10位密码', trigger: 'blur' } ]})const onClose = () =&gt; { isShow.value = !isShow.value}const onSuccess = () =&gt; { // 滑动验证成功, 发送请求 formPost&lt;RegisterForm, string&gt;({ url: '/user/register', data: { ...formData } }) .then(res =&gt; { isShow.value = !isShow.value ElMessage.success(res.data) }) .catch(err =&gt; { isShow.value = !isShow.value ElMessage.error(err.msg) })}const onSubmit = async (formEl: FormInstance | undefined) =&gt; { if (!formEl) return formEl.validate((valid, fields) =&gt; { if (valid) { isShow.value = !isShow.value } else { console.log('error submit!', fields) } })}const isShow = ref(false)&lt;/script&gt;&lt;template&gt; &lt;el-dialog title=&quot;用户注册&quot; v-model=&quot;props.registerDiaVisible&quot; :before-close=&quot;handleCancel&quot; &gt; &lt;el-form :rules=&quot;rules&quot; :model=&quot;formData&quot; ref=&quot;formRef&quot;&gt; &lt;el-form-item label=&quot;昵称:&quot; label-width=&quot;120&quot; prop=&quot;nickName&quot;&gt; &lt;el-input v-model=&quot;formData.nickName&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;姓名:&quot; label-width=&quot;120&quot; prop=&quot;realName&quot;&gt; &lt;el-input v-model=&quot;formData.realName&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码:&quot; label-width=&quot;120&quot; prop=&quot;pwd&quot;&gt; &lt;el-input v-model=&quot;formData.pwd&quot; show-password /&gt; &lt;/el-form-item&gt; &lt;div&gt; &lt;el-button @click=&quot;handleCancel&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit(formRef)&quot;&gt; 确 定 &lt;/el-button&gt; &lt;/div&gt; &lt;/el-form&gt; &lt;/el-dialog&gt; &lt;Vcode :show=&quot;isShow&quot; @success=&quot;onSuccess&quot; @close=&quot;onClose&quot; /&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;:global(.vue-puzzle-vcode) { z-index: 10000;}&lt;/style&gt; final","link":"/posts/%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81/"},{"title":"模块化 + webpack打包","text":"「模块化」是思想 模块化的演变过程 都是依靠script标签加载模块，不能代码控制加载 文件划分方式（全靠约定） 每一个文件是一个独立模块，存入的状态数据和功能函数 script src引用 使用函数和全局变量 缺点： 污染全局变量、命名冲突、管理模块之前依赖关系 命名空间方式 将每个模块封装到一个对象中，依靠name属性命名模块 缺点：没有私有空间，可以在外被修改、依赖关系 IIFE 将模块用IIFE封装，将所需要暴露的数据挂载在全局对象window…上 ​ 通过闭包的方式，私有变量、参数传递，依赖关系（Jquery $） 模块化规范 模块化规范的出现 CommonJS node提出 同步加载 一个文件就是一个模块 每个模块都是有一个单独的作用域 通过module.exports导出模块、require函数载入模块 AMD(Asynchronous Module Definition) 异步模块定义规范 社区提出 Require.js实现了AMD规范 模块加载器 123456789101112131415/* 定义一个模块 */// 参数 定义模块名、引用依赖文件、函数（依赖文件导出的成员）define('muduleName',['jquery', './moduleA'],function($, moduleA){ // 导出成员 return { $('body').animate({margin:'20px'}) moduleA() }})/* 载入一个模块 */require(['moduleName'],function(module){ module.start()})//自动创建script标签 淘宝推出Sea.js 实现的CMD模块，旨在用CommonJS的方式写AMD，后续被require.js兼容 模块化标准规范 浏览器：ES Module、node：CommonJS ES Module 特性（2014年） 通过给script标签添加type=&quot;module&quot;，以ESM标准执行JS代码 自动开启严格模式 每个module单独私有作用域 通过CORS方式请求外部的JS模块（外部必须支持CORS，要加入CORS响应头） 延迟执行脚本 defer ES Module 导入和导出 导出导入都可 as 重命名， export 12export { a, b } //这个{} 不是对象，而是固定写法export default xxx //xxx可以是一个变量或者值， import 引用文件路径 不能省略.js文件后缀、也不能直接省略访问index.js，后续通过打包工具可以这样做 不能直接载入文件名（from 'moduleA.js'），因为这样会被识别成第三方库 可以载入相对路径(不能省略./)、绝对路径、完整的url路径（引用cdn模块） 只导入不取值 import {} form './moduleA.js' import './moduleA.js' //简写方式 &lt;!--code￼2--&gt; 动态加载模块（import函数） 普通import from 只能作用于最顶层作用域 1import('./moduleA.js') 同时默认和分别导出时 //导出 export {a, b} export default '1234' //导入 import {a, b, default as str} from './moduleA.js' import str, {a, b} from './moduleA.js' //简写 &lt;!--code￼4--&gt; ES Module 浏览器环境兼容 这种方式只适合开发阶段，生产阶段不用。动态解析脚本，性能差 最好的方式还是在执行前，就将代码编译好 有些浏览器不支持直接解析es6 es-module-loader代码读出来，交给babel转换 不支持promise，用promise-ployfill 借助script标签的nomodule属性，只在不支持的浏览器运行转换脚本 123456&lt;script nomodule src=&quot;https://unpkg.com/browser-es-module-loader@0.4.1/dist/babel-browser-build.js&quot;&gt;&lt;/script&gt;&lt;script nomodule src=&quot;https://unpkg.com/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;module&quot;&gt; console.log('我是一个模块')&lt;/script&gt; ES Module 在Node中使用 在node环境下，esm文件后缀为.mjs ,不太推荐使用 官方内置模块做了兼容，可以默认全部导入，也可以分别导入 第三方库一般都是默认导出，所以不能import {xx} from ‘.module.js’ ES Module 在Node中与 CommonJS模块交互 esm可以载入cjs模块 123456789101112// esm.ejs// 只能默认导入import mod from './cjs.js'console.log(mod)// ********************* ////cjs.js/* module.exports = { foo: 'cjs中的foo'} */exports.foo = 'cjs中的foo' cjs不能载入esm模块（在原生node环境中） nvm use 版本号 ES Module在Node新版本中的支持 package.json 新增&quot;type&quot;:&quot;module&quot; 字段，node中.js文件模块就设定为ESM 此时还需用CommonJS模块，后缀名为.cjs ES Module 在Node中 Babel兼容方案 Babel js编译器，使用新特性代码 =(编译成)=》当前环境支持的代码 用preset插件集合 下载所需模块yarn add @babel/node @babel/core @babel/preset-env --dev(作为开发依赖) 运行 yarn babel-node xxx.js --presets=preset-env (还有其他preset) 如果不想每次运行都添加–presets=xxx。那么在文件下新建.babelrc文件，中添加 { &quot;presets&quot;:[&quot;@babel/preset-env&quot;] } &lt;!--code￼7--&gt; 运行 yarn babel-node xx.js 模块化打包工具 ESM 存在环境兼容问题 模块文件过多，网络请求频繁，影响工作效率 所有前端资源(html, css…)都需要模块化 新特性代码编译 模块化JS打包 支持不同类型的资源模块 模块打包工具（Module Bundler） webpack parcel rollup 打包工具的模块化是指对前端整体的模块化，并不单指JS的模块化 webpack 模块加载器loader （代码转换） 代码拆分 code splitting 资源模块 assets module，以模块化的方式引入任何资源文件 yarn init --yes yarn add webpack webpack-cli --dev yarn webpack (默认 打包src下的index.js文件) 配置文件 默认打包 src/index.js webpack.config.js 运行在node环境中的CommonJS模块 12345678const path = require('path')module.exports = { entry: './src/main.js', //指定入口文件 output: { filename: 'bundle.js', //指定打包后的文件名 path: path.join(__dirname, 'output') //必须为绝对路径 }} 工作模式 正常运行webpack出现警告⚠️ WARNING in configuration The ‘mode’ option has not been set, webpack will fallback to ‘production’ for this value. Set ‘mode’ option to ‘development’ or ‘production’ to enable defaults for each environment. You can also set it to ‘none’ to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ prodcuction 生产默认模式 yarn webpack ​ 自动优化打包结果 开发模式 yarn webpack --mode development 优化打包速度，添加调试过程中辅助 none 模式 yarn webpack --mode none 最原始 或者在webpack.config.js文件添加mode: 'development'属性，就不需要在yarn webpack --mode 参数 资源模块加载 webpack默认只处理js文件 不同类型的资源文件，需要不同类型的加载器loader 加载css资源 yarn add css-loader 将css文件转为js文件模块 yarn add style-loader 将css-loader转换的css文件以style标签追加到页面上 123456789101112131415161718192021//webpack.config.jsconst path = require('path')module.exports = { mode: 'none', entry: './src/main.css',//打包css文件 output: { filename: 'bundle.js', path: path.join(__dirname, 'output') }, module: { rules: [ { test: /.css$/, //打包文件后缀 use: [ 'style-loader', 'css-loader' ]//use模块是从后往前直行，左移css-loader要卸载后面 } ] }} loader是webpack的核心特性，通过不同的loader加载不同类型资源 导入import资源模块 打包入口—&gt; 运行入口 js驱动驱动整个前端业务 js文件作为打包的入口 ，然后在js模块中通过import引入css文件 //main.js import './xxx.css' import './yyy.css' 根据代码的需要动态导入资源 逻辑合理，js需要资源文件 确保上线资源文件不缺失 代码更易维护，减少网络请求 loader 编译转换压缩 Webpack静态资源优化，分析依赖关系是否必须，tree-shaking，优化代码 文件资源加载器 file-loader yarn add file-loader 拷贝物理文件 12345678910111213output: { filename: 'bundle.js', path: path.join(__dirname, 'output'), //默认是dist // publicPath: 'output/' //默认 },module: { rules: [ { test: /.jpeg$/, use: 'file-loader' //配置file-loader } ] } 根据配置文件的匹配到对应的文件加载器 文件加载器将导入的文件拷贝到输出的目录， 将这个拷贝的文件路径作为这个模块的返回值返回，文件就被发布出来， 可以通过模块的导出成员拿到这个资源的访问路径 url-loader DataUrls 这个就已经代表了文件 将小型文件（如图片、音频等）直接嵌入到 HTML、CSS 或 JavaScript 文件中，而不必再通过网络请求获取这些文件 通过url-loader实现DataUrls yarn add url-loader 123456789101112131415//webpack.config.jsmodule: { rules: [ { test: /.jpeg$/, //use: 'url-loader', use: { loader: 'url-loader', options:{ limit: 10 * 1024 //10KB,只处理&lt;=10KB，的文件,超过就单独提取存放 } } } ] } url-loader不会像file-loader在输出文件夹，而是生成导出文件（在打包文件中） 小文件使用DataUrls的方式，减少请求次数 大文件单独提取存放，提高加载速度需要同时安装file-loader和url-loader模块 常用加载器分类 编译转换类 文件操作类 代码检查类 统一代码风格，提高代码质量 webpack与ES2015 babel-loader 因为打包需要，处理export和import 利用babel中的预设插件编译转换代码 yarn add babel-loader @babel/core @babel/preset-env 1234567891011121314//webpack.config.jsmodule: { rules: [ { test:/.js$/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } }, ] } 模块加载方式 非必要，不要混用标准 遵循ESM的import声明 遵循CJS的require函数，（CJS require ESM的默认导出模块，需要require().default） 遵循AMD的define和require函数 Loader加载的非JS也会触发资源加载（处理的结果打包到输出目录） ​ 样式代码的@import指令 url函数 ​ @import url(reset.css); ​ background-image: url(background.jpeg); ​ html中的src属性 Footer.html 1234&lt;footer&gt; &lt;!-- &lt;img src=&quot;footer.jpeg&quot;&gt; --&gt; &lt;a href=&quot;footer.jpeg&quot;&gt;download&lt;/a&gt;&lt;/footer&gt; html文件默认导出是字符串，需要接收 12import footerHtml from './footer.html'document.write(footer.html) 再配合html-loader（默认只能加载img src） 123456789101112131415161718192021//webpack.config.jsmodule: { rules: [ { test: /.html$/, use: 'html-loader' }, options: { // attrs: ['img:src', 'a:href'] //已经被废弃 sources: { list: [ &quot;...&quot;,// 所有默认支持的标签和属性，这个一定要加上，不然就只会检测a标签了 { tag: &quot;a&quot;, attribute: 'href', type: 'src' } ] } } } Loader核心工作原理 入口文件（js文件 ） 通过require import 推断解析文件所依赖的模块，分别解析每个模块 生成依赖树，递归依赖树，找到结点的依赖文件，根据配置文件rules属性，找到对应loader，最后打包在bundle.js文件 Loader机制是webpack核心 Loader本质上是一个导出函数的Javascript模块，Webpack调用这个函数，将文件内容传递给它，返回转换后的结果。这个函数需要返回一个Javascript模块，Webpack会将它打包到最终的输出中。 管道（Pipeline）机制 开发一个Loader loader负责资源文件从输入到输出的转换 webpack中对于同一个资源可一次使用多个loader，但是最后loader处理的result必须是一段js代码 打包过后，webpack直接将loader return的js代码拼接在打包后的js文件中 简单实现一个 显示markdown loader 123//aboutme.md# 一个markdown文件 xxxxx 12345//main.js 打包入口文件//导入md文件import aboutMd from './aboutme.md' //一般md文件导入会是一段html字符串console.log(aboutMd) loader return输出必须是一段js代码，其实就是将return的结果直接拼接在打包完成的js文件中 1234567891011//markdown-loader.jsmodule.exports = source =&gt;{ const marked = require('marked') //借助marked const html = marked.parse(source) //return `module.exports = ${JSON.stringify(html)}` //return输出必须是一段js代码 // return `export default ${JSON.stringify(html)}` //esm导出 //!!!!借助html-loader 解析html return html} 123456789101112//webpack.config.jsmodule: { rules: [ { test: /.md$/, use: [//use数组，从后往前执行 'html-loader',//!!!!借助html-loader 解析html './markdown-loader' ] } ]} 插件Plugin机制 增强webpack自动化能力 处理除了loader处理的资源加载以外自动化工作 e.g. 清除上次打包的dist文件夹 ​ 将拷贝的静态文件输出至目录 ​ 压缩输出代码 ​ … 实现大多数前端工程化 clean-webpack-plugin 清除输出目录 新打包只会覆盖重名文件，而其他文件则会一直积累在输出目录 yarn add clean-webpack-plugin --dev 第三方库 1234567//webpack.config.jsconst { CleanWebpackPlugin } = require('clean-webpack-plugin')module.exports = { plugins:[ new CleanWebpackPlugin() ]} html-webpack-plugin webpack输出HTML文件 html-webpack-plugin是一个webpack插件，用于生成HTML文件。它可以根据你的配置自动生成一个HTML文件，并将打包生成的js、css等文件自动引入到HTML文件中。 自动使用bundle.js的html 最后只用发布dist目录，不需要另外再同时发布一个html文件 yarn add html-webpack-plugin --dev 1234567891011121314//webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = { plugins:[ //new HtmlWebpackPlugin() //在输出目录生成index.html new HtmlWebpackPlugin({ title: 'webpack plugin sample', meta: { viewport: 'width=device-width' }, template:'./src/index.html' //模板文件 }) ]} 123456789101112131415&lt;!-- 模板文件 ejs模板 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 输出多个html页面，直接多new HtmlWebpackPlugin({filename:'hello'}) copy-webpack-plugin 静态资源 将静态文件打包copy到输出目录 ,一般不在开发环境中使用 yarn add copy-webpack-plugin --dev 1234567891011//webpack.config.jsconst CopyWebpackPlugin = require('copy-webpack-plugin')module.exports = { plugins:[ new CopyWebpackPlugin({ patterns: [ {from: 'public', to: ''} //从那个文件到输出文件夹 ] }) ]} 自定义插件 Plugin通过钩子机制实现 一个具有 apply 方法的 JavaScript 对象 通过在生命周期的钩子挂载函数实现扩展 123456789101112131415161718192021//webpack.config.js// 用于处理删除打包bundle.js 的前面的注释class MyPlugin(){ apply(compliler){ compiler.hooks.emit.tap('MyPlugin', conpilation =&gt; { // compilation 此次打包的上下文 for(const file in compilation.assets){ //console.log(filename) //打包目录的某个文件 if(file.endsWith('.js')){ const content = compilation.assets[file].source() //某个文件内容 const withoutComments = contents.replace(/\\/\\*\\*+\\*\\//g, '') compliation.assets[file] = { //覆盖一下里面的方法 source: ()=&gt; withoutComments, size: ()=&gt; withoutComments.length } } } }) }} 增强开发体验 手动启动服务，过于原始 需求 http server启动（接近） 自动编译+自动刷新 source map支持 自动编译+刷新 watch工作模式 监听文件变化，自动重新打包 ​ 专注编码 ​ yarn webpack --watch 编译后自动刷新浏览器 ​ BrowserSync 123npm install -g browser-syncbrowser-sync start --server --files &quot;css/*.css&quot; //一个基本用途是，监听某个 css 文件//&quot;**/*&quot; //监听所有文件的变化 browser-sync 文件夹名 --files &quot;**/*&quot; watch 与 browser-sync结合麻烦，效率低 webpack-dev-server 对开发者提供一个良好的服务器 自动编译+刷新 yarn add webpack-dev-server --dev yarn webpack-dev-server 启动 添加 --open 自动打开浏览器窗口 将打包结果写入内存，并没有生成dist目录，不需要读写磁盘，提高效率 webpack-dev-server静态资源访问 Dev-server默认只会serve打包输出文件 只要是通过webpack打包输出的文件都能被访问到 之前通过clean-webpack-plugin插件实现将静态资源打包到输出文件夹， 但是在开发环境一般不要使用插件， 因为我们频繁修改代码，拷贝静态文件，将影响开发 所以一般是在上线的阶段前，使用一次这个插件 webpack.devServer.static 123456789//webpack.config.jsmodule.exports = { devServer: { //contentBase: './public', //wepack5已经移除 static: { directory: path.join(__dirname, 'public') //指定当前项目静态资源文件夹 }//可以托管多个静态文件夹 }} webpack-dev-server 代理API服务 CORS 跨域资源共享，服务端开启 并不是任何情况服务端都必须支持CORS， 前后端同源部署，没必要开启CORS 代理API服务 代理 https://api.github.com 123456789101112131415161718192021222324//webpack.config.jsmodule.exports = { devServer: { static: { directory: path.join(__dirname, 'public') //指定当前项目静态资源文件夹 } }, // !!!代理 proxy: { '/api': { // 对当前`/api/users`的请求 --会代理到--&gt; `https://api.github.com/api/users` target: 'https://api.github.com', // 如果不希望传递/api，则需要重写路径 pathRewrite: { '^/api': '' }, //`/api/users`的请求 --会代理到--&gt; `https://api.github.com/users` // 不能使用localhost:8080 作为请求GitHub的主机名 /* 服务器有多个网站，服务器通过主机名判断该请求那个网站 */ changeOrigin: true } } }} 使用 123456// src/main.js// 代理请求`https://api.github.com/users`//http://localhost:8080/api/users 同源请求，不用担心跨域问题fetch('/api/users').then(res=&gt;res.json()).then(res=&gt;{ console.log(res)}) sourceMap 运行代码与源代码不同 需要调试应用，定位错误 调试和报错都是基于转换后的代码运行的 sourceMap映射源代码与转换后代码的关系 sourceMap解决了源代码和运行代码不一致所产生的问题 拿jquery距举例 123456789&lt;body&gt;&lt;!-- 引入的是压缩后的jq包 --&gt;&lt;script src='jquery.min.js'&gt;&lt;/script&gt;&lt;script&gt; // 使用 var $body = $(document.body) console.log($body)&lt;/script&gt;&lt;/body&gt; 12345//jquery.min.jsxxxxxxxxxxxxxxxxxxxxxx//# sourceMappingURL=jquery.min.map //浏览器会自动识别，用于在浏览器开发工具中调试和定位代码时提供源文件的映射关系 12//jquery.js //js没被压缩的源文件xxxxxxxxxxx 12//jquery.min.map //sourceMap文件xxxxxxxx 之后在浏览器调试，虽然文件引入使用的是压缩后的体积，但是因为有sourcemap文件就能直接定位到源文件 webpack配置sourceMap source-map模式 1234//webpack.config.jsmodule.exports = { devtool: 'source-map'} yarn webpack 在dist目录生成sourcemap文件 webpack支持多种soucemap方式，每种方式的效率和效果都不相同 eval模式 映射到转换后的代码 速度fastest 将模块打包后的代码放入eval函数执行，配合 #sourceURL=路径方式说明对应文件路径，浏览器执行就到源代码是哪个文件，从而定位文件 并没有生成sourceMap文件 打包过后的模块代码 定位文件信息，而不知道行列（） 模式对比 eval 使用eval函数+sourceURL执行模块，只有行信息 cheap 只有行信息，没有具体列信息 带有module，没有经过loader es转换（例如babel-loader）的信息 Inline sourceMap以dataURl模式嵌入到转换后的模块中 hidden 生成了sourcemap文件，但是并没有注释引入到文件中，（第三方包，） nosources 调试工具看不到源代码，但是提供了行列信息。生产环境保护源代码，不会被暴露 选择sourcemap 开发环境 cheap-module-eval-source-map 生产环境 none 调试是开发阶段的问题，没有信息选择nosources-source-map HMR (hot module replacement)模块热更新 自动刷新页面任何操作状态都会丢失 提前写死编辑器内容 额外代码实现刷新前保存，刷新后读取 最好：页面不刷新，模块可以更新代码模块 应用执行过程中，实时替换某个模块，应用运行状态不改变 最强大的功能之一，极大提高了工作效率 集成在webpack-dev-server 开启hmr hot yarn webpack-dev-server --hot 或者 12345678910//webpack.config.jsconst webpack = require('webpack')module.exports = { devServer: { hot: true }, plugins: [ new webpack.HotModuleReplacementPlugin() ]} webpack的HMR并不能开箱即用 样式文件可以的原因是，经过loader处理，style-loader处理了样式文件热更新 使用框架开发vue react，每种文件有规律，有通用的替换办法，脚手架创建的项目都继承了HMR方案 但是webpack的HMR需要手动处理模块热替换逻辑 更新被我们手动处理了，就不会触发自动刷新，反之就会刷新页面 js模块hmr 不同的js模块有不同的逻辑，所以需要自定义 1234567891011121314151617181920212223//main.js 打包入口js文件import CreateEditor from './editor.js' //为一个创建编辑器的模块const editor = createEditor()document.body.appendChild(editor)//##########处理hmr，与上面业务代码无关，并且下面代码并不会被打包############if(module.hot){ //module.hot 由插件webpack.HotModuleReplacementPlugin()带来，原生module并不存在 /** * //注册某个模块更新过后的处理函数 * @param {string} './editor.js' - 监视模块依赖路径 * @param {callback} - 处理更新的逻辑回调函数 */ let lastEditor = editor module.hot.accept('./editor.js', () =&gt; { let value = lastEditor.innerHTML const newEditor = createEditor() newEditor.innerHTML = value document.body.appendChild(newEditor) lastEditor = newEditor })} 图片hmr 直接在module.hot.accept更新图片路径就行 hotonly 假如说hmr处理逻辑有误，就会导致页面自动刷新，看不到报错信息 那就最好使用hotonly，维持原状，不会自动刷新页面 yarn webpack-dev-server --hot only 或者 12345678910//webpack.config.jsmodule.exports = { devServer: { //hotOnly: true, webpack5废弃 hot: 'only' }， plugins:[ new webpack.hmrp() ]} module.hot 是webpack.HotModuleReplacementPlugin() 插件带来的， 处理热更新的逻辑也不会被打包 生产环境优化 生产环境跟开发环境差异大，生产环境注重运行效率，开发环境注重开发效率 不同的mode 配置：none, production, development 为不同的环境创建不同的配置 不同的环境的配置 配置文件根据环境不同导出不同配置 一个环境对应一个配置文件 环境变量参数配置 webpack-config.js 导出模块module.exports可以导出一个函数 参数 env 代表cli传递的环境变量 参数 argv 代表cli传递的所有参数 ​ 比如：yarn webpack-dev-server --env production 此时env.prodution === true 返回 一个配置 1234567891011121314151617181920212223242526272829//webpack.config.jsmodule.exports = (env, argv) =&gt; { const config = { mode: 'none', devtool: 'cheap-module-eval-source-map' entry: './src/main.js', output: { filename: 'bundle.js', path: path.join(__dirname, 'dist') } // ...等其他开发阶段的配置 } // 此时环境为生产环境 if(env.production) { config.mode = 'production', config.devtool = 'nosources-source-map', config.plugins = [ ...config.plugins, new CleanWebpackPlugin(), new CopyWebpackPlugin({ patterns: [ { from: &quot;public&quot;, to: &quot;&quot; } ], }) ] }return config} 不同环境对应不同配置 三个配置（开发、生产、公共） 123//webpack.common.jsmodule.exports = {//xxx} yarn add webpack-merge --dev 专门用于合并导出配置项的函数 1234567//webpack.prod.js 生产环境的webapck配置const common = require('./webpack.common.js')const { merge } = require('webpack-merge') // 合并配置项函数module.exports = merge(common, { mode:'production', // xxxx}) 1//webpack.dev.js 开发环境的webpack配置 （与prod差不多） 执行不同开发环境的webpack配置，加上--config参数 yarn webpack --config webpack.prod.js 执行开发环境的webpack配置 或 在package.json，写入npm 脚本 123456{ &quot;script&quot;:{ &quot;start&quot; : &quot;webpack --config webpack.dev.js&quot;, &quot;build&quot; : &quot;webpack --config webpack.prod.js&quot; }} webpack自带的优化 DefinePlugin 为代码注入全局成员 默认启用，代码注入一个process.env.NODE_ENV常量，判断当前运行环境 1234567891011//webpack.config.jsconst webpack = require('webpack')module.exports = { plugins:[ new webpack.DefinePlugin({ /*注入一个API_BASE_URL常量*/ // API_BASE_URL: '&quot;http://example.com&quot;' //js代码片段 API_BASE_URL: JSON.stringify('http://example.com') //或者用这个方式 }) ]} 12//main.jsconsole.log(API_BASE_URL) //直接调用 Tree Shaking shake掉代码中未引用的部分，『 未引用代码dead-code 』 生产模式自动开启 yarn webpack--mode production treeshaking 并不是webpack某一个配置选项 是一组功能搭配使用的效果 1234567//webpack-cofig.jsmodule.exports = { optimization: { usedExports: true, //只导出使用了的模块 minimize: true //压缩代码 }} 合并模块函数 也是optimization的一个属性 concatenateModules，将所有的模块合并输出到一个函数中（scope hoisting 作用域提升） 默认在生产环境启用，其他环境禁用 treeshaking 前提是使用ESM组织代码，由webpack打包的代码使用ESM 为了转换代码新特性，使用babel-loader，有可能会将ESM-&gt;CJS（取决于是否使用了esm转换插件） @babel/preset-env 插件集合带有了esm转换插件 但是在最新的babel-loader中，使用preset-env插件会自动auto识别当前环境的模块化方式，不会强制转换esm 想要强制转换为commojs 123456789101112131415161718module.exports = { module: { rules: [ { test: /.js$/, use: { loader: 'babel-loader', options: { presets: [ ['@babel/preset-env', { modules: 'commonjs' }] //['@babel/preset-env', { modules: false}] //不会转换模块 ] } } } ] }} sideEffects 副作用 通过配置表示代码是否有副作用，更好的帮助treeshaking 模块执行的时候，除了导出成员，做出其他的事情 一般用于NPM模块包标记是否有副作用 这个包是否会对包以外的对象产生影响，比如是否修改了 window 上的属性，是否复写了原生对象 Array, Object 方法。 使用前提：确保代码没有副作用 开启sideEffects 123456789101112131415161718//package.json{ &quot;sideEffects&quot; : false //标记表示这个包没有副作用}{ &quot;sideEffects&quot; : [ &quot;./src/components/extends.js&quot;, //标记哪个文件有副作用 &quot;*.css&quot; //css模块也有副作用 ]}//webpack.config.jsmodule.exports = { optimization: { sideEffects: true //开启sideEffects优化功能 }} 分包/代码分割Coding Splitting 打包到同一个bundle文件太大了，并不是每个模块都是在启动时必要的 分包，按需加载 HTTP1.1 并不能对同一个域名下发起很多并行请求 每次请求有延迟 请求Header浪费带宽流量 多打包入口 multi entry 多页应用程序 一个页面对应一个打包入口，公共部分单独提取 1234567891011121314151617181920212223242526272829//webpack.config.jsmodule.exports = { entry: { //两个打包入口，对象形式 home: './src/homepage/home.js', info: './src/info/info.js' }, output:{ filename: '[name].bundle.js' //[name]占位符，匹配entry的键，进而有几个entry就有几个output }, optimization: { splitChunks: { chunks: 'all' //将所有模块的公共部分再提取出来 } }, plugins: [ new HtmlWebpackPlugin({ title: 'homepage', filename: 'home.html', template: './src/homepage/home.html', chunks: ['home'] //指定哪个打包的模块才能插入到这个html页面中 }), new HtmlWebpackPlugin({ title: 'info', filename: 'info.html', template: './src/info/info.html', chunks: ['info'] //指定哪个打包的模块才能插入到这个html页面中 }), ]} HtmlWebpackPlugin默认将所有的打包文件都插入到html使用，要使用chunks配置项制定单独的js打包模块 动态导入 Dynamic Import 所有动态导入的模块会自动分包 import('./xx.js').then(module=&gt;{ console.log(module) }) import('./yy.js').then(module=&gt;{ console.log(module) }) //自动分成两个包 &lt;!--code￼48--&gt; &lt;!--code￼49--&gt; 提取css文件 之前都是直接将css文件打包在同一个bundle中， 通过插件MiniCssExtractPlugin ,提取css文件，实现按需加载 之前是通过css-loader解析模块化css文件，再使用style-loader通过style标签注入到页面中 现在通过MiniCssExtactPlugin.loader配合css-loader将css文件**link**引入 yarn add mini-css-webpack-plugin --dev 1234567891011121314151617const MiniCssExtractPlugin = require('mini-css-webpack-plugin')module.exports = { module: { rules: [ { test: /.css$/, use: { MiniCssExtractPlugin.loader, 'css-loader' } } ] }, plugins: [ new MiniCssExtractPlugin() ]} 超过150KB的css文件就最好不要提取出来， 避免过多的请求 压缩css文件 在开启生产环境模式时，webpack会自动开启代码压缩， 而webpack本身只能压缩js文件 使用**OptimizeCssAssetsWebpackPlugin**压缩css文件 yarn add optimize-css-assets-webpack-plugin --dev 如果将这个插件配置在plugins属性中，那么在任何情况都会工作 配置在minimizer配置，那么只在压缩的过程中才启用这个插件， 在生产环境，这时候需要配置额外的terser-webpack-plugin 压缩打包js代码 webpack希望我们将压缩相关插件写在optimization.minimizer属性中 1234567891011121314151617//webpack.config.jsconst MiniCssExtractPlugin = require('mini-css-extract-plugin') //提取css代码const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-plugin')const TerserWebpackPlugin = require('terser-webpack-plugin')module.exports = { optimiztion: { minimizer: [ new OptimizeCssWebpackPlugin(),//压缩css代码 new TerserWebpackPlugin() //压缩js代码 ] }, plugins: [ new MiniCssExtractPlugin()//提取css文件 ] } 输出文件名Hash Substitutions 在部署前端资源文件是，启用服务器的静态资源缓存 对于用户的浏览器而言，可以缓存住应用当中的静态文件 后续就不足要请求服务器获取资源 假如说将文件过期时间设置较长，在过程中应用发生了更新，重新部署后，没有及时更新客户端 生产环境下，文件名用添加Hash值 资源文件发生改变，文件名也跟着改变， 对于客户端，全新的文件名就是全新的请求，没有缓存的问题 filename: '[name].[hash].bundle.css' 三种模式： hash 项目级别，所有的打包文件共用一个hash。一个文件修改，所有文件的hash都变 trunkhash 一个entry对应一个hash contenthash 单文件级别的hash 所依赖的文件改变，文件也会改变相对应hash改变。","link":"/posts/webpack/"},{"title":"简单实现Toast组件","text":"一个模版文件Toast.vue 一个渲染挂载导出方法文件index.ts 通过Toast.success(‘xxxx’) 调用 这里UI使用Flowbite的Toast组件（需要配合tailwindcss） 供给渲染的模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;script lang=&quot;ts&quot; setup&gt;import { ref } from 'vue'interface Props { visible: boolean type: string message: string}const props = withDefaults(defineProps&lt;Props&gt;(), { visible: false, type: '', message: ''})const status = props.type === 'success' ? 'success' : 'danger'const toast = ref&lt;HTMLDivElement&gt;()const handleClose = () =&gt; { toast.value!.style.display = 'none'}&lt;/script&gt;&lt;template&gt; &lt;Transition name=&quot;toast&quot; enter-active-class=&quot;transition ease-out duration-300&quot; leave-active-class=&quot;transition ease-in duration-300&quot; &gt; &lt;div class=&quot;fixed inset-0 h-0&quot; v-if=&quot;props.visible&quot;&gt; &lt;div :id=&quot;`toast-${status}`&quot; class=&quot;absolute top-5 left-1/2 -translate-x-1/2 flex items-center w-full max-w-xs p-4 mb-4 text-gray-500 bg-white rounded-lg shadow dark:text-gray-400 dark:bg-gray-800&quot; role=&quot;alert&quot; ref=&quot;toast&quot; &gt; &lt;div v-if=&quot;props.type === 'success'&quot; class=&quot;inline-flex items-center justify-center flex-shrink-0 w-8 h-8 text-green-500 bg-green-100 rounded-lg dark:bg-green-800 dark:text-green-200&quot; &gt; &lt;svg class=&quot;w-5 h-5&quot; aria-hidden=&quot;true&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot; &gt; &lt;path d=&quot;M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5Zm3.707 8.207-4 4a1 1 0 0 1-1.414 0l-2-2a1 1 0 0 1 1.414-1.414L9 10.586l3.293-3.293a1 1 0 0 1 1.414 1.414Z&quot; /&gt; &lt;/svg&gt; &lt;span class=&quot;sr-only&quot;&gt; Check icon &lt;/span&gt; &lt;/div&gt; &lt;div v-else-if=&quot;props.type === 'error'&quot; class=&quot;inline-flex items-center justify-center flex-shrink-0 w-8 h-8 text-red-500 bg-red-100 rounded-lg dark:bg-red-800 dark:text-red-200&quot; &gt; &lt;svg class=&quot;w-5 h-5&quot; aria-hidden=&quot;true&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot; &gt; &lt;path d=&quot;M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5Zm3.707 11.793a1 1 0 1 1-1.414 1.414L10 11.414l-2.293 2.293a1 1 0 0 1-1.414-1.414L8.586 10 6.293 7.707a1 1 0 0 1 1.414-1.414L10 8.586l2.293-2.293a1 1 0 0 1 1.414 1.414L11.414 10l2.293 2.293Z&quot; /&gt; &lt;/svg&gt; &lt;span class=&quot;sr-only&quot;&gt; Error icon &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;ml-3 text-sm font-normal&quot;&gt; &lt;!-- {/* 不同 */} --&gt; {{ props.message }} &lt;/div&gt; &lt;button type=&quot;button&quot; class=&quot;ml-auto -mx-1.5 -my-1.5 bg-white text-gray-400 hover:text-gray-900 rounded-lg focus:ring-2 focus:ring-gray-300 p-1.5 hover:bg-gray-100 inline-flex items-center justify-center h-8 w-8 dark:text-gray-500 dark:hover:text-white dark:bg-gray-800 dark:hover:bg-gray-700&quot; data-dismiss-target=&quot;#toast-success&quot; aria-label=&quot;Close&quot; @click=&quot;handleClose&quot; &gt; &lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt; &lt;svg class=&quot;w-3 h-3&quot; aria-hidden=&quot;true&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;none&quot; viewBox=&quot;0 0 14 14&quot; &gt; &lt;path stroke=&quot;currentColor&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;m1 1 6 6m0 0 6 6M7 7l6-6M7 7l-6 6&quot; /&gt; &lt;/svg&gt; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Transition&gt;&lt;/template&gt;&lt;style scoped&gt;.toast-enter-from,.toast-leave-to { opacity: 0; transform: translateY(-30px);}&lt;/style&gt; 导出toast方法，提供给Vue进行挂载 index.ts 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//@ts-nocheckimport { createApp, h } from 'vue'import ToastComponent from './template/Toast.vue'interface ToastProps { visible: boolean type: 'success' | 'error' message: string}const ToastContainer = createApp({ render() { return h(ToastComponent, this.toastProps) }, data() { return { toastProps: { visible: false, type: '', message: '' } as unknown as ToastProps } }})const toast = ToastContainer.mount(document.createElement('div'))document.body.appendChild(toast.$el)const Toast = { success(message: string) { toast.toastProps = { visible: true, type: 'success', message } setTimeout(() =&gt; { toast.toastProps.visible = false }, 3000) }, error(message: string) { toast.toastProps = { visible: true, type: 'error', message } setTimeout(() =&gt; { toast.toastProps.visible = false }, 3000) }}export default Toast 👨‍💻使用 12Toast.success('hello')Toast.error('world')","link":"/posts/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0Toast%E7%BB%84%E4%BB%B6/"},{"title":"表格导出为excel","text":"配合xlsx模块 + fileSaver模块 ⚙️ 下载 yarn add xlsx file-saver 🔦 使用 ​ tableData格式 [ { xxx: yyy }, …] 123456789101112131415161718192021222324import * as XLSX from 'xlsx'import FileSaver from 'file-saver'const excelTable = tableData.map(item =&gt; { //格式化一下表格数据 return { '系统编号': item.id, '账单时间': item.billTime, '类型': item.natureName=== '收入'?'收入':'支出', '金额': item.natureName=== '收入'?item.amountMoney:-item.amountMoney, '备注': item.remarks } }) const worksheet = XLSX.utils.json_to_sheet(excelTable) const workbook = XLSX.utils.book_new() XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1') const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' }) const blob = new Blob([excelBuffer], { type: 'application/vnd.ms-excel' }) setTimeout(() =&gt; { FileSaver.saveAs(blob, '账单') // 下载文件 文件名 }, 500) 本来是想利用WebWorker在另一线程中处理数据，在vite中还没配置好，on the way~","link":"/posts/%E8%A1%A8%E6%A0%BC%E5%AF%BC%E5%87%BA%E4%B8%BAexcel/"},{"title":"面试1","text":"主要围绕简历展开 自我介绍 ​ 从未准备过，每次都是“面试官你好，我是来自xx学校xx学院的学生，学习前端xx年了”，然后就戛然而止。。。 项目 实习项目简介 实习负责板块介绍 难点，遇到什么问题 对于技术上手快吗 计网 Ajax 工作方式 http请求响应过程 杂项 JWT 前端axios拦截 后端加密解密~ vue react 区别 会不会后端（❓ 是否接受加班 反问 公司产品（自研？ 工作地点 &amp; 加班 。。。","link":"/posts/%E9%9D%A2%E8%AF%951/"},{"title":"vue3数据绑定之-sync","text":"啊啊啊啊学了这么久vue3还不知道sync已经在vue3中被剔除了！！！ 在vue2中我们利用v-bind值给子组件，子组件props接受父组件传来的值 子组件想直接通过props修该父组件传来的值，是不被允许的，这违背了单项数据流的原则 那要子组件想要修改父组件的值，需要通过自定义事件 由父组件定义回调，子组件emit触发回调函数通知父组件修改改，（这里就不展开述说了） 在vue2中提供了一个v-bind修饰符.sync，旨在传递一个值给子组件，而子组件可以更改这个值 而在vue3中这个sync被v-model替代了 传递给子组件的，vmodel绑定的这个值一定得是响应式的","link":"/posts/vue3%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B9%8B-sync/"},{"title":"乐山","text":"寒假终于有机会出游（蹭的）（特别感谢我哥和我嫂子）🫰 三天两晚，乐山城区、苏稽古镇、金口河 （不得不说来乐山旅游的人真的太多多多了，城区每家店子人都爆满 吃的板眼儿多得遭不住 🆘​ 炸串（排队排队） 咔饼 豆腐脑（不能接受勾了芡的食品） 甜皮鸭 404忘记拍照了… 苏稽翘脚牛肉单拎出来，太好吃了 favorito~ 坐船看了乐山大佛，逛了苏稽古镇，当然最impressive的还是金口河大峡谷。。。 人类真的特别特别渺小","link":"/posts/gallery-%E4%B9%90%E5%B1%B1/"},{"title":"大理","text":"永远怀念那一个自由的夏天 洱海傍晚 我最好的一张摄影作品🫣（just shot on the mobile device） 喜洲稻田 洱海午后 其他 I think this is the life, but august always slipped away into moment in time 🎯","link":"/posts/gallery-%E5%A4%A7%E7%90%86/"},{"title":"新加坡","text":"去新加坡看了泰勒斯威夫特时代巡回演唱会哦！！","link":"/posts/gallery-%E6%96%B0%E5%8A%A0%E5%9D%A1/"},{"title":"杂项","text":"highlight ​🈂️​ 2 1console.log('111')","link":"/posts/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Computer Network","slug":"Computer-Network","link":"/tags/Computer-Network/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Preparation","slug":"Preparation","link":"/tags/Preparation/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"¡importante!","slug":"¡importante","link":"/tags/%C2%A1importante/"},{"name":"new found","slug":"new-found","link":"/tags/new-found/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"utils","slug":"utils","link":"/tags/utils/"},{"name":"insights","slug":"insights","link":"/tags/insights/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"website","slug":"website","link":"/tags/website/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"enhanced","slug":"enhanced","link":"/tags/enhanced/"},{"name":"Interview","slug":"Interview","link":"/tags/Interview/"}],"categories":[{"name":"gallery","slug":"gallery","link":"/categories/gallery/"}]}