<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cookie &amp; Session</title>
    <url>/posts/CookieSession/</url>
    <content><![CDATA[<p>HTTP无状态（<u>一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接</u>），引入<code>cookie</code> 、<code>session</code>维持和跟踪用户状态。</p>
<br />
<blockquote>
<p><code>Session</code></p>
<p>​	用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId</p>
<p>​	cookie每次请求都把SessionId自动带到服务器</p>
<p>​		当一个用户提交了表单时，浏览器会将用户的SessionId自动附加在HTTP头信息中，（这是浏览器的自动功能，用户不会察觉到），当服务器处理完这个表单后，将结果返回给SessionId所对应的用户。</p>
</blockquote>
<br />
<ul>
<li>
<h3 id="存储位置不同"><a class="markdownIt-Anchor" href="#存储位置不同"></a> 存储位置不同:</h3>
<ul>
<li>
<p>Cookie数据存放在客户的<strong>浏览器</strong>上</p>
</li>
<li>
<p>Session数据放在<strong>服务器</strong>上</p>
</li>
</ul>
</li>
<li>
<h3 id="安全性不同"><a class="markdownIt-Anchor" href="#安全性不同"></a> 安全性不同:</h3>
<ul>
<li>
<p>Cookie不是很安全,别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p>
</li>
<li>
<p>Session存放在服务器上,比较安全</p>
</li>
</ul>
</li>
<li>
<h3 id="大小限制不同"><a class="markdownIt-Anchor" href="#大小限制不同"></a> 大小限制不同:</h3>
<ul>
<li>Cookie大小有<strong>限制</strong>,最大<u>4K</u>左右</li>
</ul>
<ul>
<li>Session大小一般可设置<u>1M到几十M</u>,根据服务器的内存大小而定</li>
</ul>
</li>
<li>
<h3 id="有效期不同"><a class="markdownIt-Anchor" href="#有效期不同"></a> 有效期不同:</h3>
<ul>
<li>
<p>Cookie的有效期需要程序员<strong>自己设置</strong></p>
</li>
<li>
<p>Session的有效期默认到<strong>浏览器关闭</strong>时失效</p>
</li>
</ul>
</li>
<li>
<h3 id="作用范围不同"><a class="markdownIt-Anchor" href="#作用范围不同"></a> 作用范围不同:</h3>
<ul>
<li>Cookie被客户端记录,每次请求时都会携带,对于服务器请求数量多的情况下会增加请求数据量</li>
</ul>
<ul>
<li>Session只保存在服务器端,不会增加请求数据量</li>
</ul>
</li>
<li>
<h3 id="实现机制不同"><a class="markdownIt-Anchor" href="#实现机制不同"></a> 实现机制不同:</h3>
<ul>
<li>
<p>Cookie通过检查客户浏览器的cookie来确定客户身份</p>
</li>
<li>
<p>Session通过给客户浏览器分配一个<strong>特定的ID</strong>来识别客户身份。服务器通过匹配session ID来管理session</p>
</li>
</ul>
</li>
</ul>
<pre class="mermaid">graph TD
A[客户端发起请求] --> B{请求是否包含sessionId?}
B -- 包含 --> C[使用已存在的Session]
B -- 不包含 --> D[创建一个新的Session]
D --> E[生成一个唯一的sessionId]
D --> F[为Session分配资源]
E --> G[将sessionId返回给客户端]
G --> H[客户端保存sessionId]
C --> I[使用已存在的Session资源]
I --> J[处理请求]
J --> K[响应请求]
K --> L[结束]
F --> L[结束]</pre>
]]></content>
      <tags>
        <tag>Computer Network</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Event Loop</title>
    <url>/posts/EventLoop/</url>
    <content><![CDATA[<p>JS单线程，为了不阻塞线程，很多代码通过回调的方式异步执行</p>
<p>JS代码执行顺序被打乱，就需要一种机制–事件循环，协调各个事件的执行顺序</p>
<h3 id="浏览器"><a class="markdownIt-Anchor" href="#浏览器"></a> 浏览器</h3>
<ol>
<li>同步代码，一行一行在Call Stack中执行（压栈弹栈）</li>
<li>遇到异步代码，记录下代码，等时机到了将代码入队Callback Queue中</li>
<li>当同步代码执行为空，Call Stack为空，Event Loop开始工作</li>
<li>Event Loop轮询查找Callback Queue中是否有可执行代码
<ol>
<li>有，将代码送入Call Stack执行</li>
<li>没有，将继续轮询查找</li>
</ol>
</li>
</ol>
<p><font color=red>调用栈为空触发Event Loop执行先后顺序：微任务、DOM渲染、宏任务</font></p>
<p>微任务： Promise, async/await</p>
<p>宏任务： 定时器、Ajax、DOM事件</p>
<img src="https://s2.loli.net/2023/10/07/nFwAxKGfkaDUp8b.png" alt="浏览器事件循环" style="width:70%;" />
<h3 id="node"><a class="markdownIt-Anchor" href="#node"></a> Node</h3>
<p>Node异步API</p>
<table>
<thead>
<tr>
<th>定时器</th>
<th>I/O操作</th>
<th>node独有</th>
</tr>
</thead>
<tbody>
<tr>
<td>setTimeout<br />setInterval</td>
<td>文件读写<br />数据库操作<br />网络请求…</td>
<td>process.nextTick<br />setImmediate</td>
</tr>
</tbody>
</table>
<p>设计上，事件循环优先处理执行I/O事件</p>
<img src="https://s2.loli.net/2023/10/07/Y7yhcei5f86PaS4.png" alt="Node事件循环" style="width:70%;" />
<p>process.nextTick不属于事件循环一部分，优先于事件循环执行</p>
<p>从Timer到Check为一个Tick</p>
<blockquote>
<p><code>setImediate(()=&gt;&#123;&#125;)</code>、与<code>setTimeout(()=&gt;&#123;&#125;, 0)</code> 中执行时机不确定？</p>
<p>setTimeout(, 0) —&gt; <code>浏览器 4ms</code>,<code> node 1ms</code></p>
<p>解决： 将两者放在I/O操作回调中，能保证setImmediate回调先执行</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Create-React-App项目Template</title>
    <url>/posts/Create-React-App%E9%A1%B9%E7%9B%AETemplate/</url>
    <content><![CDATA[<p><a href="https://github.com/ye1223/CRA-template.git">💡项目地址</a><br />
<br /></p>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── .husky</span><br><span class="line">├── .vscode</span><br><span class="line">├── public</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.tsx</span><br><span class="line">│   ├── index.tsx</span><br><span class="line">│   └── react-app-env.d.ts</span><br><span class="line">├── prettier.config.js</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── package.json</span><br><span class="line">└── yarn.lock</span><br><span class="line">├── README.md</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="初始化项目"><a class="markdownIt-Anchor" href="#初始化项目"></a> 初始化项目</h3>
<p>​	<code>yarn add create-react-app [app-name] --template typescript</code></p>
<h3 id="prettier"><a class="markdownIt-Anchor" href="#prettier"></a> prettier</h3>
<p>​	<code>yarn add -D prettier</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//prettier.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">   <span class="attr">semi</span>: <span class="literal">false</span>, <span class="comment">// 在每条语句的末尾不使用分号</span></span><br><span class="line">   <span class="attr">trailingComma</span>: <span class="string">&#x27;es5&#x27;</span>, <span class="comment">// 允许在ES5中有效的尾随逗号</span></span><br><span class="line">   <span class="attr">singleQuote</span>: <span class="literal">true</span>, <span class="comment">// 使用单引号而不是双引号</span></span><br><span class="line">   <span class="attr">printWidth</span>: <span class="number">80</span>, <span class="comment">// 指定打印行的最大长度</span></span><br><span class="line">   <span class="attr">tabWidth</span>: <span class="number">3</span>, <span class="comment">// 设置每个缩进级别的空格数</span></span><br><span class="line">   <span class="attr">useTabs</span>: <span class="literal">false</span>, <span class="comment">// 使用空格而不是制表符进行缩进</span></span><br><span class="line">   <span class="attr">bracketSpacing</span>: <span class="literal">true</span>, <span class="comment">// 在对象字面量中添加空格</span></span><br><span class="line">   <span class="attr">jsxBracketSameLine</span>: <span class="literal">false</span>, <span class="comment">// 在JSX中把&#x27;&gt;&#x27;放在最后一行的末尾</span></span><br><span class="line">   <span class="attr">arrowParens</span>: <span class="string">&#x27;avoid&#x27;</span>, <span class="comment">// 当箭头函数只有一个参数时不使用圆括号</span></span><br><span class="line">   <span class="attr">endOfLine</span>: <span class="string">&#x27;lf&#x27;</span>, <span class="comment">// 行尾序列使用LF（\n）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="husky"><a class="markdownIt-Anchor" href="#husky"></a> <strong>husky</strong></h3>
<p>​	<code>yarn add -D husky</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;prettier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prettier --write \&quot;src/**/*.&#123;js,jsx,ts,tsx,json,css,scss,md&#125;\&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>​	<strong>启用 Git 钩子</strong>： <code>npx husky install</code></p>
<p>​	<strong>添加 pre-commit 钩子</strong>：<code>npx husky add .husky/pre-commit &quot;yarn prettier&quot;</code></p>
<h3 id="路径别名"><a class="markdownIt-Anchor" href="#路径别名"></a> 路径别名</h3>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// ...其他配置...</span></span><br><span class="line">  <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;*&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<br />
<strong> 静候补充... </strong>]]></content>
  </entry>
  <entry>
    <title>GPTPlus速通</title>
    <url>/posts/GPTPlus%E9%80%9F%E9%80%9A/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JS类型转换</title>
    <url>/posts/JS%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>JS是动态类型语言，我们在定义一个变量其实并没有指定这个变量到底属于那种类型，只有到程序执行阶段才确定当前数据类型。</p>
<p>而<font color=red>各种<strong>运算符</strong>对数据类型是有要求的</font>，所以就会触发类型转换机制（no matter 人为 or 隐式触发）</p>
<h2 id="显示转换"><a class="markdownIt-Anchor" href="#显示转换"></a> 显示转换：</h2>
<p>​	通过JS内置的函数<strong>明确转换的数据类型</strong></p>
<ul>
<li>
<p>Number</p>
</li>
<li>
<p>parseInt(string, ?进制) 比Number宽松，一位一位解析遇到不能解析的停止</p>
</li>
<li>
<p>String</p>
</li>
<li>
<p>Boolean</p>
</li>
</ul>
<h2 id="隐式转换"><a class="markdownIt-Anchor" href="#隐式转换"></a> 隐式转换：</h2>
<p>​	运算操作符两边数据类型不一致（比较运算符、算术运算符）</p>
<ul>
<li>
<p>转为Boolean (需要布尔值的地方，借助的<code>Boolean()</code>函数)</p>
<ul>
<li>falsely变量：<code>undefined</code>、<code>null</code>、<code>false</code>、<code>+/-0</code>、<code>NAN</code>、<code>&quot;&quot;</code></li>
</ul>
</li>
<li>
<p>转为String （复合类型—&gt;原始类型----&gt;字符串）</p>
<ul>
<li>常发生在，如 <code>&quot;5&quot; + xxx</code> 的加法运算中</li>
</ul>
</li>
<li>
<p>转为Number</p>
<ul>
<li>除了加法运算符号，其他都有可能</li>
</ul>
</li>
</ul>
<h2 id="other"><a class="markdownIt-Anchor" href="#other"></a> other</h2>
<blockquote>
<p><code>=== </code>在不进行类型转换情况下，双方的类型与值都相等</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Preparation</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/posts/TCP/</url>
    <content><![CDATA[<p><strong style="color:red;">在不可靠的网络链路中，进行可靠的链接/断开</strong></p>
<p><strong>全双工（Full Duplex）</strong></p>
<ol>
<li>双向传输:TCP连接的两端都可以同时发送和接收数据包。</li>
<li>双向流量控制:发送方和接收方都可以通过滑动窗口机制控制数据流量,防止对方缓冲区溢出。</li>
<li>双向确认:发送的数据包可以得到对方的确认应答ACK。接收方也可以通过ACK告知发送方自己已经正确接收了数据。</li>
<li>双向重传:如果任意一方没有收到确认或数据包丢失,都可以触发重传机制,直到数据正确发送。</li>
<li>全双工通信:TCP的全双工特性使得双方可以同时进行发言而不会相互干扰,就像电话通话一样。</li>
</ol>
<blockquote>
<p><code>ACK</code> 和<code>FIN</code> 是 TCP 协议中两个重要的控制标志(control flag)</p>
<p><code>ACK(Acknowledgement) </code>确认号，表示确认号,确认接收端已正确接收到前面的数据</p>
<p><code>FIN (Finish)</code> 结束标志，表示发送端已经发送完数据,可以关闭连接了。</p>
</blockquote>
<h2 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手🤝</h2>
<img src="https://i.imgur.com/bJWYomc.png" alt="三次挥手示意图" style="width:50%" />
<h2 id="传输"><a class="markdownIt-Anchor" href="#传输"></a> 传输</h2>
<p>一包数据可能被拆为多包数据发送</p>
<p><strong>丢包问题？乱序问题？</strong></p>
<p>TCP为每个链接建立了一个<mark>发送缓冲区</mark></p>
<img src="https://s2.loli.net/2023/09/11/ACj3KLUHcNiVIMs.png" style="width:50%;" alt="传输示意图" />
<blockquote>
<p>一问一答的方式发送接收（发送端一次也可以发送多包数据，接收端只用回复一次ACK）</p>
</blockquote>
<blockquote>
<p>发送端可以切割发送，接收端利用序列号和长度重组出完整的数据</p>
</blockquote>
<blockquote>
<p>丢失了某个数据包，接收端可以要求发送端重传。</p>
<p>接收端向发送端发送ACK=xxx，发送端重传，接收端收到再<strong>补齐</strong>数据</p>
</blockquote>
<h2 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手👋🏻</h2>
<p>这里以客户端取消l为例</p>
<img src="https://s2.loli.net/2023/09/11/nrxG86lYUf7CqMX.png" alt="四次挥手示意图" style="width:50%;" />
<p>Client等待一段时间，目的为了确保ACK成功发送给Server，否则Server重新发送FIN给client，再重新执行</p>
]]></content>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>HTTP summary</title>
    <url>/posts/http/</url>
    <content><![CDATA[<h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> <mark>HTTP</mark></h2>
<p><strong>Hyper Text Transfer Protocol</strong></p>
<img src="https://s2.loli.net/2023/09/08/7HasE3ePGXuqtYn.png" alt="image-20230908155626605" style="width:50%;" />
<ul>
<li><strong style="color:red;">Stateless</strong> : every Request is <strong>INDEPENDENT</strong>
<ul>
<li>regard each request as a single transaction</li>
<li>use <code>cookie</code>  <code>session</code> <code>localStorage</code> … to enhance user experience( <u>memorize the state from the user</u> )</li>
</ul>
</li>
</ul>
<h2 id="https"><a class="markdownIt-Anchor" href="#https"></a> <mark>HTTPS</mark></h2>
<p><strong>Hyper Text Transfer Protocol <u>Secure</u></strong></p>
<ul>
<li>Data sent is <strong>encrypt</strong>
<ul>
<li><strong>SSL</strong> – Secure Sockets Layer</li>
<li><strong>TLS</strong> –  Transfer Layer Security</li>
</ul>
</li>
<li>install certificate on web host to use HTTPs</li>
</ul>
<h2 id="message"><a class="markdownIt-Anchor" href="#message"></a> Message</h2>
<img src="https://s2.loli.net/2023/09/08/u6OS2icBACHrtFf.png" alt="image-20230908164003822" style="width:50%;" />
<h3 id="headers"><a class="markdownIt-Anchor" href="#headers"></a> Headers</h3>
<ul>
<li>General
<ul>
<li>Request URL、Request Method、Status Code、Remote Address、Referrer Policy</li>
</ul>
</li>
<li>Request
<ul>
<li>Cookies、Accept-xxx、Content-Type、Content-Length、Auhurization、User-Agent、Referrer</li>
</ul>
</li>
<li>Response
<ul>
<li>Server、Set-Cookie、Content-Type、Content-Length、Date</li>
</ul>
</li>
</ul>
<h2 id="status-code"><a class="markdownIt-Anchor" href="#status-code"></a> Status Code</h2>
<table>
<thead>
<tr>
<th>Status Code</th>
<th>Means</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>request received / processing</td>
</tr>
<tr>
<td>2xx</td>
<td>Success received, understood, accepted</td>
</tr>
<tr>
<td>3xx</td>
<td>Further action must be taken / redirect</td>
</tr>
<tr>
<td>4xx</td>
<td>Client error</td>
</tr>
<tr>
<td>5xx</td>
<td>Server error</td>
</tr>
</tbody>
</table>
<ul>
<li>200 - OK</li>
<li>201 - OK created</li>
<li>301 - Move to new URL</li>
<li>304 - Not Modified (Cached version)</li>
<li>400 - Bad Request （❌ not sending correct data）</li>
<li>401 - Unauthorized （missing token）</li>
<li>404 - Not Found (resources do not exsist)</li>
<li>500 - Internal Server Error</li>
</ul>
<h2 id="http2"><a class="markdownIt-Anchor" href="#http2"></a> HTTP2</h2>
<p><code>multiplexing</code></p>
<img src="https://s2.loli.net/2023/09/08/sf8H6glXiCnzEA2.png" alt="image-20230908164925817" style="width:50%;" />
]]></content>
      <tags>
        <tag>Computer Network</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>computed与watch</title>
    <url>/posts/computed%E4%B8%8Ewatch/</url>
    <content><![CDATA[<h3 id="计算属性computed"><a class="markdownIt-Anchor" href="#计算属性computed"></a> <strong>计算属性computed</strong></h3>
<p>​	<u>适合用在模板渲染中，某个值是<strong>依赖了其它的响应式对象</strong>甚至是<strong>计算属性</strong>计算而来</u></p>
<ul>
<li><font color=red>支持缓存</font>，只有依赖数据发生改变，才会重新进行计算</li>
<li><mark>不支持异步</mark>，当computed内有异步操作时无效，无法监听数据的变化</li>
<li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li>
<li>如果computed属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个<code>get</code>和一个<code>set</code>方法，当数据变化时，调用set方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;计算属性示例&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;原始数据: &#123;&#123; originalData &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;计算属性: &#123;&#123; computedProperty &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;updateData&quot;&gt;更新数据&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      originalData: 5</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    computedProperty() &#123;</span><br><span class="line">      // 计算属性，依赖于原始数据</span><br><span class="line">      return this.originalData * 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateData() &#123;</span><br><span class="line">      // 更新原始数据，会触发计算属性重新计算</span><br><span class="line">      this.originalData += 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="侦听属性watch"><a class="markdownIt-Anchor" href="#侦听属性watch"></a> 侦听属性watch</h3>
<p>​	<u>适用于观测某个值的变化去<strong>完成一段复杂的业务逻辑</strong>（例如执行异步或开销较大的操作）</u></p>
<ul>
<li><font color=red>不支持缓存</font>，数据变，直接会触发相应的操作；</li>
<li>watch<mark>支持异步</mark>；</li>
<li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li>
<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>
<li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：新值和旧值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;监听的数据: &#123;&#123; watchedData &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;changeData&quot;&gt;改变数据&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      watchedData: &#x27;初始值&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeData() &#123;</span><br><span class="line">      this.watchedData = &#x27;新值&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    watchedData(newVal, oldVal) &#123;</span><br><span class="line">      // 在数据变化时触发的操作</span><br><span class="line">      console.log(&#x27;新值：&#x27;, newVal);</span><br><span class="line">      console.log(&#x27;旧值：&#x27;, oldVal);</span><br><span class="line">      // 这里可以执行您想要的其他操作</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>js红宝书</title>
    <url>/posts/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/</url>
    <content><![CDATA[<h3 id="script标签"><a class="markdownIt-Anchor" href="#script标签"></a> <code>&lt;script&gt;</code>标签</h3>
<ul>
<li>
<p>一些属性</p>
<ul>
<li>defer 推迟</li>
<li>async 异步  期间不要动DOM</li>
<li>intergrity 检查安全</li>
</ul>
</li>
<li>
<p>src GET 跨域</p>
</li>
<li>
<p>引入外部文件文件，行内代码写了没用</p>
</li>
</ul>
<blockquote>
<p>MIME 代码块中的脚本语言内容类型</p>
</blockquote>
<ul>
<li><code>&lt;noscript&gt;&lt;/noscript&gt;</code></li>
</ul>
<h3 id="严格模式es5增加"><a class="markdownIt-Anchor" href="#严格模式es5增加"></a> 严格模式（ES5增加）</h3>
<p>遵守的是es3的语法</p>
<p>开启严格模式，脚本开头写上<code>&quot;use strict&quot;;</code> ，也可写在函数内部开头，单独开启严格模式</p>
<h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3>
<p>​	<code>var</code>变量提升hoist ，函数作用域,全局声明成为window对象属性</p>
<p>​	<code>let</code>，块级作用域，暂存性死区（temporal dead zone)</p>
<p>​	<code>let</code>和<code>var</code> 只是指出变量在相关作用域如何让存在</p>
<p>​	<code>const</code> 适用于for-in(对象属性名)、for-of（数组）</p>
<h5 id="声明风格"><a class="markdownIt-Anchor" href="#声明风格"></a> 声明风格</h5>
<p>​		不使用<code>var</code>，<code> const</code>优先，<code>let</code>次之</p>
<h3 id="34-数据类型"><a class="markdownIt-Anchor" href="#34-数据类型"></a> 3.4 数据类型</h3>
<p>​	<strong>Undefined、Null、Boolean、Number、String、Symbol、Object</strong></p>
<p>​	<strong>typeof 操作符</strong></p>
<p>​		typeof null =&gt; onject (null被认为是空对象的引用)</p>
<p>​	<strong>Number</strong><br />
​		八进制: 0111 在严格模式下报错、0o111可以</p>
<p>​		<code>1.</code> 和 1.0 为整数，1.1、1.2浮点数</p>
<p>​		ES会将小数点后至少包括<u>6个0</u>的浮点值转换成科学计数法</p>
<p>​	<strong>String</strong></p>
<p>​		ECMAScript中的字符串是<strong>不可变的immutable</strong></p>
<p>​		<code>toString</code>  返回自身的一个副本</p>
<p>​			除了<font color=red><code>null</code></font> 和<font color=red> <code>undefined</code></font>都有<code>toString</code>方法。对于数值类型可以传参(转换<u>进制数</u>)</p>
<p>​		对于变量未知类型的，转为字符串，利用**<code>String()</code>转型函数**</p>
<p>​		<strong>模板字面量 ``</strong></p>
<p>​			保留换行字符，跨行定义字符串</p>
<p>​			字符串插值 ``${js表达式}` ，调用了toString方法强制转换为字符串</p>
<p>​			标签函数<code>(模板字面量隔开形成的字符串数组，...模板字面量的值)</code></p>
<p>​			原始字符串<code>String.raw</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`\u00A9`</span>) <span class="comment">//© (输出转义后的符号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property">raw</span><span class="string">`\u00A9`</span>) <span class="comment">//\u00A9 (输出原始的字符串</span></span><br></pre></td></tr></table></figure>
<p>​		<strong>Symbol</strong></p>
<p>​			在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同</p>
<p>​			全局符号：</p>
<p>​				symbol.for()执行幂等操作，第一次操作会检查全局运行时注册表，是否存在对应的symbol.for()</p>
<p>​				查询全局注册表<code>Symbol.keyFor(参数)</code>  (参数必须为symbol类型，否则抛出typeError)</p>
<p>​					查询成功返回symbol值，否则返回undefined</p>
<p>​			作为对象<code>[属性]</code>使用</p>
<p>​				defineProperty添加symbol类的值作为属性（在node下不能）</p>
<p>​			内置符号（不可写，不可枚举，不可配置）</p>
<p>​				<code>Symbol.iterator</code> for-of循环会使用这个属性</p>
<p>​				<code>Symbol.asyncIterator</code> for-await-of使用，异步迭代器</p>
<p>​				<code>Symbol.hasInstance</code>定义在Function的原型身上</p>
<p>​				<code>Symbol.isConcatSpreadable</code>（默认值undefined） <strong>控制Array.prorotype.concat是否“打平”连接</strong></p>
<p>​					对于数组对象(默认打平），设置为falsely变量，不会打平连接，会让整个对象追加到数组末尾</p>
<p>​					对于类数组对象（默认不打平），设置为truely变变量，会打平连接，到数组实例</p>
<p>​			<strong>Object</strong></p>
<p>​				ECMAScript只要求给构造函数提供参数时使用括号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span> <span class="comment">//合法，但不推荐</span></span><br></pre></td></tr></table></figure>
<p>​				<code>hasOwnProperty</code></p>
<p>​				<code>valueof()</code> 定义在对象里的方法。 return的值，</p>
<p>​						显示获取：<code>obj.valueOf()</code></p>
<p>​						隐式获取：<code>++obj </code> 对obj进行<strong>数学运算</strong>，直接调用的<code>valueOf()</code>方法</p>
<h3 id="35-操作符"><a class="markdownIt-Anchor" href="#35-操作符"></a> 3.5 操作符</h3>
<p>​	一元操作符</p>
<p>​		自增、自减、+、-</p>
<p>​			<code>+</code> 拼接字符串，<code>-</code> 先<code>Number()</code>转换，在减法操作</p>
<p>​	位操作符</p>
<p>​		ECMAScript 数值 以IEEE 745 64位格式存储</p>
<p>​		位操作，将值转为32位整数，再进行操作，最后再把结果转为64位</p>
<p>········</p>
<h3 id="36-语句"><a class="markdownIt-Anchor" href="#36-语句"></a> 3.6 语句</h3>
<p>​	<code>for-in</code> 严格迭代语句，遍历对象的<u>可枚举</u><u>非symbol类型</u>属性</p>
<p>​	<code>for-of</code> 严格迭代语句，遍历可迭代对象</p>
<p>​	标签语句 配合continue和break使用</p>
<p>​	<code>with</code>语句，将代码的作用域设定为特殊的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = process.<span class="property">pid</span></span><br><span class="line"><span class="keyword">const</span> b = process.<span class="property">ppid</span></span><br><span class="line"><span class="keyword">const</span> c = process.<span class="property">title</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="title function_">with</span>(<span class="params">process</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pid, ppid, title)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//严格模式不支持with，影响性能，难于调试，不推荐使用</span></span><br></pre></td></tr></table></figure>
<p>​	switch 全等操作符，不会强制转换类型</p>
<h2 id="第四章-变量-作用域与内存"><a class="markdownIt-Anchor" href="#第四章-变量-作用域与内存"></a> 第四章 变量、作用域与内存</h2>
<h3 id="41-原始值与引用值"><a class="markdownIt-Anchor" href="#41-原始值与引用值"></a> 4.1 原始值与引用值</h3>
<p>​	原始值（基础数据类型值）</p>
<p>​	引用值，保存在内存中的对象</p>
<p>​	ECMAScript函数参数传递是<strong>按值传递</strong>，（传递的是值的副本而非值本身）</p>
<p>​	确定类型：</p>
<p>​		<strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p>
<p>​		<code>typeof</code>…etc</p>
<h3 id="42-执行上下文与作用域"><a class="markdownIt-Anchor" href="#42-执行上下文与作用域"></a> 4.2 执行上下文与作用域</h3>
<p>​	<code>var</code>的函数作用域声明：变量会添加到<strong>最近的上下文</strong>，<em>作用域提升</em></p>
<p>​	<code>with</code>语句中var声明的变量为在<strong>全局</strong>作用域中</p>
<p>​	<code>let</code>、<code>const</code>  {}块级作用域</p>
<blockquote>
<p>使用<code>const</code>变量有助于JS引擎(谷歌V8引擎)优化，<strong>编译时</strong>就将所有实例替换成<strong>实际的值</strong>，而不会通过查询表进行变量查找</p>
</blockquote>
<p>​	标识符查找：沿作用域链查找</p>
<h3 id="43-垃圾回收️"><a class="markdownIt-Anchor" href="#43-垃圾回收️"></a> 4.3 垃圾回收♻️</h3>
<p>​	基本思路：确定那个变量不会再使用，然后释放他占用的空间。（<strong>周期性自动运行</strong>）</p>
<p>​	主要标记策略</p>
<p>​		<strong>标记清理</strong>：</p>
<p>​			标记内存中的所有变量 ➡️ 去掉上下文或者上下文引用的变量的标记 ➡️ （这时候再被加上标记的变量就是待删除的了，任何上下文的变量都访问不到它们了）回收</p>
<pre><code>	**引用计数**(❗️导致循环引用)
</code></pre>
<p>​			变量声明并赋引用值，引用数为1；</p>
<p>​			如果同一个值又被赋值给另一个，引用数+1；</p>
<p>​			该引用值被其他值覆盖，则引用数-1。</p>
<p>​			当引用值为0时，就会被垃圾回收</p>
<p>​	将变量设为<code>null</code>，切断变量与其之前引用值之间的关系。</p>
<p>​	<strong>性能</strong>：</p>
<p>​		现代垃圾回收程序根据<strong>运行时的环境</strong>来决定何时运行（以前IE是达到设定的阈值，就执行回收）</p>
<p>​		也有浏览器提供方法可以<u>主动触发垃圾回收</u>（❌）</p>
<p>​		提升性能：</p>
<p>​			使用<code>const let</code>声明变量：相对于函数作用域的<code>var</code>，块级作用域<strong>可能</strong>会更早终止，会让垃圾回收程序接介入，尽早回收内存</p>
<p>​			隐藏类和删除操作<code>delete</code></p>
<p>​				V8引擎将JS<strong>代码</strong>编译成实际的<strong>机器码</strong>会利用”隐藏类”，<strong style="color:red">能够共享隐藏类的对象性能更高</strong></p>
<p>​					<strong>动态<font color=blue>添加、删除</font>属性导致不共享一个隐藏类</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;iam foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个实例共用一个相同的隐藏类，因为两个实例共享一个共同的构造函数</span></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//‼️但是如此修改（这种操作的频率和隐藏类的大小对性能产生明显影响</span></span><br><span class="line">f2.<span class="property">name</span> = <span class="string">&#x27;iamf2&#x27;</span><span class="comment">//Foo实例对应两个 不同 的隐藏类。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//✅解决方案： 先创建再补充</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样对应相同的隐藏类</span></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;iamf1&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//‼️但是，使用delete关键字动态删除属性导致，不再共享一个隐藏类</span></span><br><span class="line"><span class="keyword">delete</span> f1.<span class="property">name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//✅解决方案 把不想要的属性设置为null</span></span><br><span class="line">f1.<span class="property">name</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>​		内存泄漏</p>
<p>​			意外声明全局变量</p>
<p>​			定时器回调引用外部变量</p>
<p>​			使用闭包</p>
<p>​		<strong>静态分配与对象池</strong></p>
<h2 id="第五章-基本引用类型"><a class="markdownIt-Anchor" href="#第五章-基本引用类型"></a> 第五章 基本引用类型</h2>
<h3 id="51-date"><a class="markdownIt-Anchor" href="#51-date"></a> 5.1 Date</h3>
<blockquote>
<p>UTC 协调世界时 GMT格林威治平时</p>
</blockquote>
<p>​</p>
<p>​	<code>Date.parse(创建的是本地日期)</code>  <code>Date.UTC(创建的是GMT日期)</code>  将一个表示日期的字符串解析为对应的时间戳（毫秒数）</p>
<p>​	new Date(传入时间字符串) ，根据字符串格式隐式调用上面两个构造函数</p>
<p>​	Date类重写了toLocaleString toString valueOf(返回时间戳)</p>
<h3 id="52-正则"><a class="markdownIt-Anchor" href="#52-正则"></a> ❓5.2 正则</h3>
<h3 id="53-原始值包装类型"><a class="markdownIt-Anchor" href="#53-原始值包装类型"></a> 5.3 原始值包装类型</h3>
<blockquote>
<p>ECMAScript提供了3种特殊的引用类型，<code>Boolean</code> <code>String</code> <code>Number</code></p>
</blockquote>
<p>​	正常来说原始值本身不是对象，按逻辑上不应该有方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;some text&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="title function_">substring</span>(<span class="number">2</span>)) <span class="comment">//me text</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>包装类型让原始值拥有对象行为</p>
<p>​	创建一个String类型实例</p>
<p>​	调用实例上的方法</p>
<p>​	销毁实例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示创建原始值包装类型(不推荐)</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;i am a string&#x27;</span>)<span class="comment">//构造函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s) <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;i am a string&#x27;</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s) <span class="comment">//string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="title class_">String</span>(<span class="string">&#x27;i am a string&#x27;</span>) <span class="comment">//转型函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s) <span class="comment">//string</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object工厂方法创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> os = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&#x27;i am a string&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建的是一个String实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> os, os <span class="keyword">instanceof</span> <span class="title class_">String</span>)<span class="comment">// object true</span></span><br></pre></td></tr></table></figure>
<h4 id="number"><a class="markdownIt-Anchor" href="#number"></a> number</h4>
<p>​		toFixed方法，返回的字符串保留几位小数（0~20位+，超过，四舍五入）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">2</span>))<span class="comment">//10.00</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="number">10.005</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>))<span class="comment">//10.01</span></span><br></pre></td></tr></table></figure>
<p>​	toPrecision返回最合理的数值(1-21小数位)</p>
<h4 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h4>
<p>​	JS 一个字符16位</p>
<p>​	与模式匹配相关的方法: match search replace split</p>
<h3 id="54-单例内置对象"><a class="markdownIt-Anchor" href="#54-单例内置对象"></a> 5.4 单例内置对象</h3>
<h4 id="global"><a class="markdownIt-Anchor" href="#global"></a> Global</h4>
<p>​	eval函数（⛔️XSS攻击）</p>
<p>​		这个函数就是个完整的ECMAScript解释器</p>
<p>​		定义在eval函数中的变量和函数，不存在函数提升</p>
<p>​		开启严格模式够，外部访问不到eval函数里的数据</p>
<h3 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h3>
<h2 id="第六章-集合引用类型"><a class="markdownIt-Anchor" href="#第六章-集合引用类型"></a> 第六章 集合引用类型</h2>
<h3 id="61-object"><a class="markdownIt-Anchor" href="#61-object"></a> 6.1 Object</h3>
<p>​	字面量{}形式创建一个对象，并不会new Object()</p>
<h3 id="62-array"><a class="markdownIt-Anchor" href="#62-array"></a> 6.2 Array</h3>
<p>​	字面量[]形式创建一个数组，也不会new Array()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20</span>) <span class="comment">//定义数组长度为20</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Array.from()</td>
<td>将<strong>伪数组</strong>转为真数组</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Array.of()</td>
<td>将一系列参数转为数组</td>
<td><code>Array.of( 1, 2, 3)</code> ➡️ [1, 2, 3]</td>
</tr>
</tbody>
</table>
<h4 id="数组空位"><a class="markdownIt-Anchor" href="#数组空位"></a> 数组空位</h4>
<p>​		字面量一串<strong>逗号形式</strong>创建空位</p>
<p>​			<img src="JS红宝书.assets/image-20230616144658231.png" alt="image-20230616144658231" style="zoom:50%;" /></p>
<p>​		ES6新增的方法和迭代器，将空位当成存在的元素，值为<code>undefined</code></p>
<p>​			<img src="JS红宝书.assets/image-20230616145322099.png" alt="image-20230616145322099" style="zoom:50%;" /></p>
<p>​		ES6之前的方法， 忽略空位（具体的行为因方法而异）</p>
<p>​			<code>map</code>跳过空位，<code>join</code>将空位视为空字符串</p>
<p>​		<img src="JS红宝书.assets/image-20230616145451935.png" alt="image-20230616145451935" style="zoom:50%;" /></p>
<h4 id="数组索引"><a class="markdownIt-Anchor" href="#数组索引"></a> 数组索引</h4>
<p>​		<font color=red>数组的length不是只读的</font>，利用这个特性删除数组末尾元素（当然也可添加数组空位）</p>
<p>​		<img src="JS红宝书.assets/image-20230616145938663.png" alt="image-20230616145938663" style="zoom:50%;" /></p>
<h4 id="检测数组"><a class="markdownIt-Anchor" href="#检测数组"></a> 检测数组</h4>
<p>​		在一个全局上下文中，使用<code>instanceof</code>。</p>
<blockquote>
<p>多个 iframe多个全局上下文。然后每个里面都有 Array 这个对象。他们并不相等。</p>
<p>本质来讲 <code>instanceof</code> 是去找 prototype 之类的，看看是否有继承。</p>
</blockquote>
<p>​		<strong><code>Array.isArray()</code></strong></p>
<h4 id="迭代器方法"><a class="markdownIt-Anchor" href="#迭代器方法"></a> 迭代器方法</h4>
<p>​		<code>arr.keys()</code> 返回数组索引的迭代器</p>
<p>​		<code>values() </code>返回数组元素的迭代器</p>
<p>​		<code>entries()</code> 返回 索引/值 对的迭代器</p>
<p>​	<em><strong><u>alert期待字符串</u></strong></em></p>
<h4 id="排序方法"><a class="markdownIt-Anchor" href="#排序方法"></a> <strong>排序方法</strong></h4>
<p>​		<code>sort</code> ，事先对数组中的没项元素都使用的<code>String转型函数</code></p>
<p>​			升序：compare(val1, val2) val1 &gt; val2 return 1</p>
<p>​			降序：compare(val1, val2) val1 &gt; val2 return -1</p>
<h4 id="操作方法"><a class="markdownIt-Anchor" href="#操作方法"></a> 操作方法</h4>
<p>​	<code>concat</code> <code>splice</code></p>
<h4 id="搜索方法"><a class="markdownIt-Anchor" href="#搜索方法"></a> 搜索方法</h4>
<p>​	<code>indexof</code> <code>lastIndexOf</code> <code>includes</code></p>
<p>​	<code>find</code> <code>findIndex</code></p>
<h4 id="迭代方法"><a class="markdownIt-Anchor" href="#迭代方法"></a> 迭代方法</h4>
<p>​	<code>every</code> <code>some</code></p>
<p>​	<code>filter</code> <code>map</code> <code>forEach</code></p>
<h4 id="归并方法"><a class="markdownIt-Anchor" href="#归并方法"></a> 归并方法</h4>
<p><code>reduce</code> <code>reduceRight</code></p>
<h3 id="63-定型数组"><a class="markdownIt-Anchor" href="#63-定型数组"></a> 6.3 定型数组</h3>
<h3 id="64-map-set"><a class="markdownIt-Anchor" href="#64-map-set"></a> 6.4 Map Set</h3>
<p>​	定义时都接受一个可迭代对象初始化映射</p>
<p>​	使用<code>forEach</code>，<code>for-of</code>迭代值</p>
<h3 id="65-weakmap-weakset"><a class="markdownIt-Anchor" href="#65-weakmap-weakset"></a> 6.5 weakMap weakSet</h3>
<blockquote>
<p>​	weakMap存储键值对的<strong>键</strong>必须为引用类型数据</p>
</blockquote>
<p>如果键的指向为空，自动称为垃圾回收的目标</p>
<p>weakMap实现真正的私有变量</p>
<p>都不可迭代值</p>
<h3 id="68-迭代与扩展操作"><a class="markdownIt-Anchor" href="#68-迭代与扩展操作"></a> 6.8 迭代与扩展操作</h3>
<p>​	定义的默认迭代器（<code>Array</code> <code>定型数组</code> <code>Map</code> <code>Set</code>）</p>
<p>​	支持for-of顺序迭代、兼容扩展操作符</p>
<blockquote>
<p>浅复制：只会复制对象的引用</p>
</blockquote>
<h2 id="第七章-迭代器与生成器"><a class="markdownIt-Anchor" href="#第七章-迭代器与生成器"></a> 第七章 迭代器与生成器</h2>
<p>​	迭代：按顺序反复执行一段程序</p>
<p>​	循环是迭代的基础</p>
<h3 id="迭代器模式"><a class="markdownIt-Anchor" href="#迭代器模式"></a> 迭代器模式</h3>
<p>​	开发者无需知道如何迭代就能实现迭代操作</p>
<p>​	实现可迭代iterable接口的对象，都能被事件iterator接口的结构消费</p>
<p>​	<strong>内置iterable接口的类型：<code>Stirng</code> <code>Array </code> <code>Map</code> <code>Set</code> <code>arguments对象</code> <code>NodeList等DOM集合类型</code></strong></p>
<p>​	<strong>接受可迭代对象的原生语言特性</strong></p>
<p>​		<code>for-of </code> <code>数组解构</code> <code>扩展操作符</code></p>
<p>​		<code>Array.from</code> <code>new Set/Map</code></p>
<p>​		<code>Promise.all / race</code> <code>yeild*操作符</code></p>
<p><em>给对象添加可迭代的iterable接口，</em></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">list</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> &#123; length &#125; = <span class="variable language_">this</span>.<span class="property">list</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: count === length ? <span class="literal">true</span> : <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">list</span>[count++] &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">          	<span class="comment">//提前终止，调用return方法</span></span><br><span class="line">          	<span class="keyword">return</span>() &#123;</span><br><span class="line">            	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exiting Early!&#x27;</span>)</span><br><span class="line">           	 	<span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">         	 	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收迭代器实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iter = obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()) <span class="comment">//调用next方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不同迭代器实例之间没有联系</p>
<p>迭代器不与对象某时刻的快照绑定，也可根据实际情况动态变化</p>
<p>迭代器维护一个指向可迭代对象的引用，⛔️<strong>阻止</strong>垃圾回收可迭代对象</p>
</blockquote>
<h4 id="提前终止迭代器"><a class="markdownIt-Anchor" href="#提前终止迭代器"></a> <strong>提前终止迭代器</strong></h4>
<p>​	如上<code>return</code>方法指定迭代器提前关闭时执行的逻辑</p>
<p>​		<strong>for-of 循环 在 break continue return throw时，触发提前终止逻辑</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="keyword">if</span>(val === <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Exiting Early!</span></span><br></pre></td></tr></table></figure>
<p>​		 <strong>解构操作并未消费所有的值时</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [item1, item2] = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item1, item2)</span><br><span class="line"><span class="comment">// Exiting Early!</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果迭代器没有关闭，可以从上次离开的地方继续迭代（数组的迭代器不能关闭）</p>
<p>return() 方法是可选的</p>
<p>仅仅给一个不可关闭的迭代器器增加一个return方法并不能让他关闭。调用return方法并不会强制迭代器进入关闭状态。</p>
</blockquote>
<h3 id="生成器模式"><a class="markdownIt-Anchor" href="#生成器模式"></a> 生成器模式</h3>
<blockquote>
<p>临时的可迭代对象称为生成器</p>
</blockquote>
<p>​	生成器拥有在<u>函数块</u>内<strong>暂停</strong>和<strong>恢复代码</strong>执行的能力 <font color=gray>可以用于自定义迭代器和实现协程</font></p>
<h4 id="定义生成器"><a class="markdownIt-Anchor" href="#定义生成器"></a> 💬定义生成器</h4>
<p>​	函数名前加『 *』，箭头函数不可用于定义生成器函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="comment">//函数表达式方式 对象方法 类方法 类静态方法。。。</span></span><br></pre></td></tr></table></figure>
<p>​	调用生成器函数产生生成器对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g)<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<div style="text-align:center; padding: 0 100px; overflow: hidden;">
  <div style="float: left; font-weight: bold;">开始暂时处于暂停执行状态，生成器对象也实现了iterator接口，具有next方法</div>
  <img src="JS红宝书.assets/image-20230617162726562.png" alt="image-20230617162726562" style="zoom:50%; display:block; float: right;" />
</div>
<p>初次调用next()方法指明开始调用生成器</p>
<p>value属性是生成器返回值，默认undefined</p>
<h4 id="yeild中断执行"><a class="markdownIt-Anchor" href="#yeild中断执行"></a> 🛑yeild中断执行</h4>
<p>yeild关键字只能在生成器函数中使用</p>
<h4 id="作为可迭代对象使用"><a class="markdownIt-Anchor" href="#作为可迭代对象使用"></a> 作为可迭代对象使用</h4>
<p>生成器显示调用next方法用处不大。</p>
<p>将生成器对象作为可迭代对象使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">genneratorFn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> <span class="title function_">genneratorFn</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="yeild实现输入输出"><a class="markdownIt-Anchor" href="#yeild实现输入输出"></a> yeild实现输入输出</h4>
<p>yeild产出的值传给g.next()</p>
<p>g.next()传入的参数，作为是yeild的返回值</p>
<h4 id="产生可迭代对象"><a class="markdownIt-Anchor" href="#产生可迭代对象"></a> 产生可迭代对象</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">yeild *[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>yeild* 其实也就是将可迭代对象序列化为一串可以单独产出的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genneratorFnA</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])&#123;</span><br><span class="line">        <span class="keyword">yield</span> val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价！！！</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">genneratorFnB</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="作为默认迭代器使用"><a class="markdownIt-Anchor" href="#作为默认迭代器使用"></a> ✅作为默认迭代器使用</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()&#123;</span><br><span class="line">        <span class="keyword">yield</span>* <span class="variable language_">this</span>.<span class="property">list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> val <span class="keyword">of</span> f)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提前终止生成器"><a class="markdownIt-Anchor" href="#提前终止生成器"></a> 提前终止生成器</h4>
<p><code>return() </code>强制生成器进入关闭状态</p>
<img src="JS红宝书.assets/image-20230617170419253.png" alt="image-20230617170419253" style="zoom:50%;" />
<p><code>throw()</code> 将一个错误注入到生成器中</p>
<table>
<thead>
<tr>
<th>如果生成器没处理这个错误，生成器会closed</th>
<th>生成器内部处理了这个错误生成器就不会关闭，而且会恢复执行<br />（只是跳过了这个值）</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="JS红宝书.assets/image-20230617170721610.png" alt="image-20230617170721610" style="zoom:50%;" /></td>
<td><img src="JS红宝书.assets/image-20230617171023335.png" alt="image-20230617171023335" style="zoom:50%;" /></td>
</tr>
</tbody>
</table>
<h2 id="第八章-对象-类与面向对象编程"><a class="markdownIt-Anchor" href="#第八章-对象-类与面向对象编程"></a> 第八章 对象、类与面向对象编程</h2>
<h3 id="81-对象"><a class="markdownIt-Anchor" href="#81-对象"></a> 8.1 对象</h3>
<h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4>
<p>​	构造函数、字面量形式</p>
<h4 id="对象属性"><a class="markdownIt-Anchor" href="#对象属性"></a> 对象属性</h4>
<h5 id="数据属性默认都为true"><a class="markdownIt-Anchor" href="#数据属性默认都为true"></a> 数据属性（默认都为true)</h5>
<table>
<thead>
<tr>
<th style="text-align:left"><code>Configurable</code></th>
<th><span style="font-weight: normal;">属性可由delete删除</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>Enumerable</code></strong></td>
<td>是否可由<code>for-in</code>枚举</td>
</tr>
<tr>
<td style="text-align:left"><strong><code> Writable</code></strong></td>
<td>是否可被修改</td>
</tr>
<tr>
<td style="text-align:left"><strong><code> Value</code></strong></td>
<td>包含实际值，默认undefined</td>
</tr>
</tbody>
</table>
<p>​	<strong>使用<code>Object.defineProperty</code>对对象属性属性修改（不配置值，默认为fasle）</strong></p>
<img src="JS红宝书.assets/image-20230617174454670.png" alt="image-20230617174454670" style="zoom:50%;" />
<p>(严格模式下： 尝试对configurable: false; witable: false；的值修改，会抛出错误。)</p>
<p>不能对同一个属性，定义多次Object.defineProperty()</p>
<h5 id="访问器属性"><a class="markdownIt-Anchor" href="#访问器属性"></a> 访问器属性</h5>
<p><code>getter</code> <code> setter</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="attr">_name</span>: <span class="string">&#x27;levy_init&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;尝试修改name&#x27;</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_name</span> = newVal</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">        <span class="attr">_name</span>: <span class="string">&#x27;levyy&#x27;</span>,</span><br><span class="line">        <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;尝试修改name&#x27;</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_name</span> = newVal</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>Object.defineProperties</code> 对一个对象的多个属性一次性进行描述符规定</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">_name</span>: <span class="string">&#x27;levy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">21</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="读取属性特性"><a class="markdownIt-Anchor" href="#读取属性特性"></a> 读取属性特性</h4>
<p>​	读取对象某一个： <code>Object.getOwnProperty(obj, 'aProperty')</code></p>
<p>​	读取对象全部属性的特性：<code>Object.getOwnProperties(obj)</code> //其实也是对每个属性调用了上面的方法，在一个新对象返回</p>
<h4 id="合并对象混入"><a class="markdownIt-Anchor" href="#合并对象混入"></a> 合并对象（混入）</h4>
<p><code>Object.assign()</code>浅复制，只复制可枚举(PropertyIsEnumerable)、自身(hasOwnPropery)属性</p>
<p>不复制属性的getter setter</p>
<blockquote>
<p>没有回滚之前赋值的状态，尽力赋值</p>
</blockquote>
<h4 id="相等判断"><a class="markdownIt-Anchor" href="#相等判断"></a> 相等判断</h4>
<p><code>Object.is()</code></p>
<img src="JS红宝书.assets/image-20230617185929270.png" alt="image-20230617185929270" style="zoom:50%;float:left;" />
<h4 id="增强语法"><a class="markdownIt-Anchor" href="#增强语法"></a> 增强语法</h4>
<p>属性值简写、可计算属性、方法简写、对象解构</p>
<h3 id="82-创建对象"><a class="markdownIt-Anchor" href="#82-创建对象"></a> 8.2 创建对象</h3>
<blockquote>
<p>ES6 Class Extends也是基于ES5原型链继承的语法糖</p>
</blockquote>
<h4 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">//显式创建对象</span></span><br><span class="line">    o.<span class="property">name</span> = name</span><br><span class="line">    o.<span class="property">age</span> = age</span><br><span class="line">    o.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o <span class="comment">//return 对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">createPerson</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h4 id="构造函数模式"><a class="markdownIt-Anchor" href="#构造函数模式"></a> 构造函数模式</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>new操作符</p>
<ol>
<li>内存中创建一个新对象</li>
<li>这个新对象的内部的[[Prototype]]属性赋值为构造函数的prototype属性</li>
<li>构造函数内部的this被赋值为这个新对象（this指向新对象）</li>
<li>执行构造函数内部代码（给新对象添加属性）</li>
<li>如果构造函数返回<strong>非空对象</strong>，则返回该对象；否则，返回刚创建的对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myNew</span> = (<span class="params">constructor, ...args</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">    o.<span class="property">__proto__</span> = constructor.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    <span class="keyword">const</span> res = constructor.<span class="title function_">apply</span>(o, args)</span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? res : o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​	构造函数如果不传参可以不用写括号</p>
<h5 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h5>
<p>​	不同实例上的方法不是同一个，方法都是做同样的事，没必要定义两个不同的Function实例。</p>
<p>​	解决可以把方法定义在构造函数外部，构造函数内部方法直接引用</p>
<h4 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式"></a> 原型模式</h4>
<p>在构造函数原型定义的属性方法可以被实例共享</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;小小&#x27;</span></span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>, p.<span class="property">sayName</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化写法：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小小&#x27;</span>,</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Person</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span> <span class="comment">//原生constructor不可枚举，用这种方式定义</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>isPrototypeOf 检查原型</code> 原型链</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(p) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><code>Object.getPrototypeOf()</code> 获取原型对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>更改原型对象</strong></p>
<p>​	<code>Object.setPrototypeOf()</code> 影响性能</p>
<p>​	<code>Object.create</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(a, b)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(a) === b) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span> === b) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title class_">Object</span>.<span class="title function_">create</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(c) === a)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">__proto__</span> === a)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>实例可以通过原型链查找属性</p>
<p>确定属性在自身还是是原型链上的 <code>hasOwnProperty()</code></p>
<p><code>in</code> 操作符是在自身以及原型链上查找</p>
<p><code>Object.keys()</code> 遍历实例可枚举属性</p>
<p><code>Object.getOwnPropertyNames()</code> 遍历实例无论是否可枚举属性（除了Symbol ）</p>
<p><code>Object.getOwnPropertySymbols()</code></p>
<p>遍历顺序</p>
<p>for-in Object.keys() 无序</p>
<h4 id="对象迭代"><a class="markdownIt-Anchor" href="#对象迭代"></a> 对象迭代</h4>
<p><code>Object.values() </code> <code>Object.entries() </code></p>
<p>浅复制对象、不迭代Symbol</p>
<h3 id="83-继承"><a class="markdownIt-Anchor" href="#83-继承"></a> 8.3 继承</h3>
<p><a href="https://juejin.cn/post/6844903696111763470">参考掘金</a></p>
<h4 id="原型链继承"><a class="markdownIt-Anchor" href="#原型链继承"></a> 原型链继承</h4>
<p>每个构造函数有一个<font color=red>原型</font>对象prototype， 这个<font color=red>原型</font>对象有个属性constructor指向构造函数本身。</p>
<p>而这个构造函数实例有一个内部指针<code>__proto__</code>，指向这个<font color=red>原型</font></p>
<p>那如果这个原型是另一个类型的实例，就意味着这和<font color=red>原型</font>本身有个指针指向<font color=blue>另一个原型</font>，相应另一个原型也有个指针指向另一个构造函数。</p>
<p>这样形成了实例与原型之前的<strong>原型链</strong></p>
<h4 id="盗用构造函数"><a class="markdownIt-Anchor" href="#盗用构造函数"></a> 盗用构造函数</h4>
<h4 id="组合继承"><a class="markdownIt-Anchor" href="#组合继承"></a> 组合继承</h4>
<h4 id="原型式继承"><a class="markdownIt-Anchor" href="#原型式继承"></a> 原型式继承</h4>
<h4 id="寄生式继承"><a class="markdownIt-Anchor" href="#寄生式继承"></a> 寄生式继承</h4>
<h4 id="寄生组合继承"><a class="markdownIt-Anchor" href="#寄生组合继承"></a> 寄生组合继承</h4>
<p>寄生式继承父类原型，然后将返回的对象赋值给子类原型</p>
<h4 id="混入式继承"><a class="markdownIt-Anchor" href="#混入式继承"></a> 混入式继承</h4>
<h4 id="class-继承"><a class="markdownIt-Anchor" href="#class-继承"></a> Class 继承</h4>
<h3 id="84-类"><a class="markdownIt-Anchor" href="#84-类"></a> 8.4 类</h3>
<p>定义方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Foo</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Foo1</span> = <span class="keyword">class</span> <span class="title class_">FooName</span>&#123; <span class="comment">//表达式类名FooName可选</span></span><br><span class="line">        <span class="title function_">identify</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo1</span>.<span class="property">name</span> ,<span class="title class_">Foo2</span>.<span class="property">name</span>) <span class="comment">//name字段获取类名</span></span><br><span class="line">          	<span class="comment">// class后定义了类名就是指定类名FooName，否则类名就是Foo1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>类是一种特殊的函数<code>typeof</code>，但是并不会有作用域提升</p>
<p>类声明受块级作用域影响，而函数生命则受函数作用域影响</p>
<h4 id="constructor构造函数"><a class="markdownIt-Anchor" href="#constructor构造函数"></a> <code>constructor</code>构造函数</h4>
<p>构造函数默认返回this，<strong>构造函数返回的对象用作实例化的对象</strong></p>
<p>如果这个构造函数返回的不是this对象，而是其他对象，那么通过<code>instanceof</code>操作符不会检测出这个对象与这个类有关。</p>
<blockquote>
<p>因为在<code>new</code>操作时，会自动绑定this，如果</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">override</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (override) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo1 <span class="keyword">instanceof</span> <span class="title class_">Foo</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> foo2 = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo2 <span class="keyword">instanceof</span> <span class="title class_">Foo</span>)<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>类中定义的方法成为原型方法</p>
<p><strong><em>类块</em>中定义的方法都会定义在类的原型上</strong></p>
<p>静态类方法</p>
<p>迭代器、生成器</p>
<h4 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h4>
<p><code>extends</code> 继承一个类或者一个普通的构造函数</p>
<p>super只能在<strong>派生类构造函数和静态方法</strong>中使用</p>
<p>调用super()函数会调用父类构造函数，并将返回的实例赋值给this</p>
<p>给父类传参，super()手动传参</p>
<p>在类构造函数中不能在super()之前调用this</p>
<p>在派生类中显示定义了构造函数，必须要调用super或者返回一个对象</p>
<h4 id="抽象基类"><a class="markdownIt-Anchor" href="#抽象基类"></a> 抽象基类</h4>
<p>供其它类继承，却不被实例化</p>
<p>利用new.target实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>) <span class="comment">//返回Foo类</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Foo</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Foo 不能直接被实例化&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>() <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<h2 id="第九章-代理与反射"><a class="markdownIt-Anchor" href="#第九章-代理与反射"></a> 第九章 代理与反射</h2>
<h3 id="91-代理"><a class="markdownIt-Anchor" href="#91-代理"></a> 9.1 代理</h3>
<p>用作目标对象的替身，但独立于对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handlerObj) <span class="comment">//参数两者缺一不可</span></span><br></pre></td></tr></table></figure>
<p><code>Proxy.proptotype</code> 为undefined，所以不能使用<code>instanceof</code>操作符</p>
<p><code>===</code>严格相等可以用来区分代理和目标</p>
<h4 id="捕获器"><a class="markdownIt-Anchor" href="#捕获器"></a> 捕获器</h4>
<p><code>get</code></p>
<p>​	接受参数（目标对象，要查询的属性，代理对象)</p>
<p>重建被捕获的原始行为：</p>
<p>使用捕获器，被代理的属性如果同时not Configurable and not Writable，则TypeError报错</p>
<blockquote>
<p>反射API Reflect</p>
<p>delete函数属性—&gt;Refelect.deleteProperty</p>
<p>name in obj —&gt; Reflect.has(obj, ‘name’)</p>
</blockquote>
<p>可撤销代理</p>
<p><strong>撤销函数</strong>和<strong>代理对象</strong>是同时在实例化时生成的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构 代理对象和撤回函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; =<span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;1234&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>)<span class="comment">//1234</span></span><br><span class="line"><span class="title function_">revoke</span>() <span class="comment">//撤销代理</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy)<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<h4 id="实用反射reflect-api"><a class="markdownIt-Anchor" href="#实用反射reflect-api"></a> 实用反射Reflect API</h4>
<p>反射API不局限于捕获程序处理</p>
<p>代替Object上的方法（错误必须try catch捕获 到 反射API返回布尔值）</p>
<blockquote>
<p>反射方法return 的值称为“状态标记”的布尔值</p>
</blockquote>
<p>代替一些操作符</p>
<table>
<thead>
<tr>
<th>Reflect.</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>in</td>
</tr>
<tr>
<td>set</td>
<td>= 赋值操作符</td>
</tr>
<tr>
<td>has</td>
<td>in 或者 with()</td>
</tr>
<tr>
<td>deleteProperty</td>
<td>delete</td>
</tr>
<tr>
<td>Construct</td>
<td>new</td>
</tr>
</tbody>
</table>
<p>使用<code>Reflect.apply</code>调用函数(被调用函数，this指向，[实参…])</p>
<h4 id="构建多层拦截网"><a class="markdownIt-Anchor" href="#构建多层拦截网"></a> 构建多层拦截网</h4>
<p>​	代理另一个代理</p>
<h4 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h4>
<p>一种编程模式</p>
<h5 id="跟踪属性访问"><a class="markdownIt-Anchor" href="#跟踪属性访问"></a> 跟踪属性访问</h5>
<h5 id="隐藏属性"><a class="markdownIt-Anchor" href="#隐藏属性"></a> 隐藏属性</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">TrapTarget, property</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hiddenProperties.<span class="title function_">includes</span>(property))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">has</span>(<span class="params">target, property</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hiddenProperties.<span class="title function_">includes</span>(property))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">age</span>) <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> proxy) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sex&#x27;</span> <span class="keyword">in</span> proxy)<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h5 id="属性验证"><a class="markdownIt-Anchor" href="#属性验证"></a> 属性验证</h5>
<p>​	赋值操作触发<code>set</code>，根据情况决定赋值</p>
<h5 id="函数与构造函数参数验证"><a class="markdownIt-Anchor" href="#函数与构造函数参数验证"></a> 函数与构造函数参数验证</h5>
<h5 id="数据绑定和可观察对象"><a class="markdownIt-Anchor" href="#数据绑定和可观察对象"></a> 数据绑定和可观察对象</h5>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs</title>
    <url>/posts/nodejs/</url>
    <content><![CDATA[<h1 id="pre"><a class="markdownIt-Anchor" href="#pre"></a> pre</h1>
<ol>
<li><strong>运行时（Runtime)</strong><br />
&quot;运行时&quot;就是程序运行的时候，也就是<strong>指令加载到内存并由CPU执行</strong>的时候。</li>
</ol>
<p>与之相对应的是“编译时”，其指代码编译的时候，也就是C代码编译成可执行文件的时候，此时指令没有被CPU执行。</p>
<ol start="2">
<li>
<p><strong>运行时库（Runtime Library）</strong><br />
运行时库就是程序运行的时候所需要依赖的库。</p>
</li>
<li>
<p><strong>运行时环境（Runtime environment）</strong><br />
运行环境（英语：Runtime environment）又称“运行时系统”（run-time system），指一种把半编译的运行码在目标机器上运行的环境。</p>
</li>
</ol>
<hr />
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>Nodejs 只是一个js<strong>运行时环境</strong></p>
<p>访问系统内核，访问本地文件，链接服务器…</p>
<p>nodejs在<strong>浏览器之外</strong>运行<strong>v8引擎</strong></p>
<p><strong>跨平台</strong></p>
<p>适合干IO密集型应用，不适合CPU密集型（单线程）</p>
<blockquote>
<p>CPU 密集型： 图像、音频处理需要大量的数据结构+算法</p>
</blockquote>
<hr />
<h1 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h1>
<p>node <code>global</code></p>
<p>浏览器 <code>window</code></p>
<p><code>globalThis</code>根据环境自动判断</p>
<p>ECMAScript中有的全局，如Math…</p>
<ul>
<li>
<p><code>__dirname</code> 当前文件所在目录(绝对路径)</p>
</li>
<li>
<p><code>__filename</code> 当前文件路径（绝对路径）</p>
</li>
<li>
<p><code>__extname</code> 文件后缀</p>
</li>
<li>
<p><code>Buffer</code></p>
</li>
<li>
<p><code>process</code>  处理进程</p>
<ul>
<li><code>process.argv</code> 获取参数数组</li>
<li><code>process.cwd()</code> 目录</li>
<li><code>process.exit()</code> 终止进程</li>
<li><code>process.on('exit', ()=&gt;&#123;console.log('退出')&#125;)</code> 监听事件</li>
</ul>
</li>
</ul>
<hr />
<p><code>nodejs</code>应用在（<font color=red>长期运行!!</font><code>httpserver返回++counter</code>）<strong>单个进程</strong>中运行，无需为每个请求创建新的线程</p>
<p>（相比，Apache，每一个请求创建一个线程）</p>
<p>单线程，并发量为1</p>
<p>采用了<strong>非阻塞</strong>的开发范式（事件循环机制） + v8引擎加持，轻松应对<strong>高并发</strong></p>
<blockquote>
<p>主线程是单线程，io是libuv维护的线程池</p>
</blockquote>
<br/>
<p>当函数调用栈内有函数运行时，js不能处理其他请求</p>
<br/>
<p>异步模块（多线程）和事件循环（监听 派发，不占用单独线程）</p>
<p>循环不停监听异步模块处理进度，等处理完成后，派发函数调用栈执行</p>
<br/>  
<p>最快的速度清空函数调用栈，把耗时的操作全部做异步处理</p>
<p>node将【异步操作和对应的回调函数】封装成一个请求对象，交给底层的异步模块处理</p>
<p>异步操作有结果之后，回调函数进入事件循环等待执行，</p>
<p>事件循环在调用栈清空时，按照某个优先级顺序将回调函数推入到调用栈执行</p>
<hr />
<h1 id="node异步api"><a class="markdownIt-Anchor" href="#node异步api"></a> node异步API</h1>
<ol>
<li>定时器： <code>setTimeOut</code> <code> setInterval</code> （最小1ms，浏览器4ms）</li>
<li>I/O操作： 文件读写，数据库操作，网络请求</li>
<li>node独有的，<code>process.nextTick</code>、<code>setImmediate</code></li>
</ol>
<br/>
<blockquote>
<p>nextTick(<strong>优先级比事件循环队列更高</strong>)</p>
<p>微任务（promise）</p>
<p>timer</p>
<p>–&gt;poll（当执行到这里时卡住，检查timer或者check队列有误需要 执行的）</p>
<p>check</p>
</blockquote>
<p>Poll 阻塞，从设计上，是想优先处理IO事件的</p>
<p>Settimeout(,0)与setimmdeiate 放入io中使用，定时器，总会先执行check队列的操作</p>
<br/>
<blockquote>
<p>Timer -&gt; check运行一周称为一个<code>Tick</code></p>
<p>nextTick先于下一个Tick执行</p>
</blockquote>
<p><strong>异步代码进入异步模块以非阻塞的形式执行，对应的异步函数会在对应的异步代码执行完成后，派发到不同的队列中</strong></p>
<h2 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h2>
<p>为了健壮性：捕获并处理每一个错误</p>
<ul>
<li>
<p>同步代码 try catch</p>
</li>
<li>
<p>异步代码</p>
<ul>
<li>Promise (catch)</li>
<li>async await trycatch</li>
</ul>
</li>
</ul>
<h2 id="异步编程-流程控制"><a class="markdownIt-Anchor" href="#异步编程-流程控制"></a> 异步编程 流程控制</h2>
<p>回调函数 --&gt; Promise —&gt; async await</p>
<br/>
<p>node官方的库</p>
<p>遵循，错误优先风格</p>
<br/>
<p>回调函数，需要顺序执行，就要嵌套的写，但是导致回调地狱</p>
<br/>
<blockquote>
<p>平行</p>
<p>顺序</p>
</blockquote>
<h1 id="module"><a class="markdownIt-Anchor" href="#module"></a> module</h1>
<p>module并不是全局变量，每一个模块有他相应的模块</p>
<br/>
<p>核心模块（随着node）</p>
<p>第三方模块</p>
<p>自定义模块（引用路径）</p>
<br/>
<p>运行时加载 cmj，知道运行时候再报错</p>
<p>编译时加载 esm</p>
<p><code>import from</code> 写在模块顶层</p>
<p><code>import()</code> （异步，返回promise）</p>
<br/>
<p><code>V8</code></p>
<p>预编译阶段 （ESM</p>
<p>-分配内存空间</p>
<p>-确定作用域链…</p>
<p>执行阶段 （CMJ</p>
 <br/>
<hr />
<h1 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> Buffer</h1>
<p>js字符串不可变，所有对字符串的操作都要生成一个新的字符串</p>
<br/>
<p><code>fs</code>模块读取，不生命文件类型，默认返回的都是文件二进制缓冲区</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer1 = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">5</span>) <span class="comment">//申请五个字节</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer1.<span class="title function_">toString</span>())</span><br><span class="line">buffer1.<span class="title function_">write</span>(<span class="string">&#x27;string&#x27;</span>) <span class="comment">//多写入的部分不会写入</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer1, buffer1.<span class="title function_">toString</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;a string&#x27;</span>))</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="stream"><a class="markdownIt-Anchor" href="#stream"></a> stream</h1>
<p><img src="https://s2.loli.net/2023/09/03/JmQjx7fKbWprE1C.png" alt="image-20230601204439944.png" /></p>
<br/>
<p>i/o操作</p>
<p>端到端数据交换</p>
<br/>
<p>加载 缓冲区 处理</p>
<p>流模式 加载一点处理一点</p>
<br/>
<p><img src="https://s2.loli.net/2023/09/03/LGmBcjDfOF5giHV.png" alt="image-20230601204653589.png" /></p>
<br/>
<p><img src="https://s2.loli.net/2023/09/03/iLAFjDZa3q7Sxd5.png" alt="image-20230618200922252.png" /></p>
<hr />
<h1 id="seo"><a class="markdownIt-Anchor" href="#seo"></a> SEO</h1>
<ul>
<li>
<p>TDK</p>
<ul>
<li>title</li>
<li>description (meta)</li>
<li>Key(meta)</li>
</ul>
</li>
<li>
<p>语义化标签</p>
</li>
<li>
<p><code>&lt;a/&gt;</code> href</p>
</li>
<li>
<p><code>&lt;img/&gt;</code> href alt</p>
</li>
<li>
<p>一个页面一个h1 和 main标签</p>
</li>
<li>
<p>…</p>
</li>
</ul>
<p>借助第三方库jsdom（jsdom模拟浏览器环境的库，可以在 Node.js 中使用 DOM API），服务端渲染</p>
]]></content>
  </entry>
  <entry>
    <title>npm</title>
    <url>/posts/npm/</url>
    <content><![CDATA[<p><code>node package manager</code>  基于命令行的工具</p>
<p>安装、卸载、更新、发布</p>
<p><strong>version</strong> <strong>版本号x,y,z</strong></p>
<p>主 次 补丁</p>
<dl>
<dt>^ 锁定从左边数第一个非0的</dt>
<dd>锁定主版本or次版本</dd>
</dl>
<p>latest 最新版本</p>
<h1 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h1>
<p>dependecies</p>
<p>devDependencies 开发依赖</p>
<p>peerDependencies 对等依赖，（插件不能凭空运行，需要依赖某一模块）</p>
<h1 id="一些常用命令"><a class="markdownIt-Anchor" href="#一些常用命令"></a> 一些常用命令</h1>
<ul>
<li><code>npm config list</code> 查看npm配置信息</li>
</ul>
<img src="https://s2.loli.net/2023/09/02/cZmUGLrlnh74v9Y.png" alt="image-20230902172055264" style="width:50%;" />
<ul>
<li><code>npm get registry</code>  查看镜像源</li>
<li><code>npm set registry xxxx</code>设置镜像源</li>
<li><code>npm ls (-g)</code> 当前（全局）安装的可执行文件</li>
</ul>
<h1 id="npm-install-原理"><a class="markdownIt-Anchor" href="#npm-install-原理"></a> npm install 原理</h1>
<p>安装依赖存放于根目录<code>node_modules</code>文件夹</p>
<p>排序: .bin @系列 abcd排序</p>
<p>广度优先，扁平化（理想情况下）处理下载</p>
<blockquote>
<p>非理想： node_modules下a b 模块依赖不同版本的c模块，会给b模块下再建立一个node_modules文件夹</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/09/02/ybEQgwSzVoL2kA3.png" alt="img" /></p>
<blockquote>
<p>pakage-lock.json</p>
<p>锁定版本号</p>
<p>缓存： intergrity + verion + name 生成唯一的key，这个key在缓存文件中,</p>
<p><code>npm config list</code> 查看中的cache</p>
<p>index-v5 索引目录，记录content-v2的索引位置，对应的 intergrity + verion + name由算法生成的哈希值</p>
<p>对应得上，就将这个加密的包解压到node_modules中</p>
</blockquote>
<table>
<thead>
<tr>
<th>pakage-lock.json pakage.json</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>不一致</td>
<td>按照pakage中的版本下载，并更新lock中的版本号</td>
</tr>
<tr>
<td>一直</td>
<td>先找缓存，没有再下载资源</td>
</tr>
</tbody>
</table>
<h1 id="npm-run"><a class="markdownIt-Anchor" href="#npm-run"></a> npm run</h1>
<p>可执行命令都存在node_modules下的<code>.bin</code>文件夹中</p>
<ol>
<li>
<p>当前项目node_modules/.bin 中查找</p>
</li>
<li>
<p>全局的node_modules查找</p>
</li>
<li>
<p>环境变量中查找</p>
</li>
<li>
<p>报错</p>
</li>
</ol>
<p>也是有生命周期的</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;predev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node 1.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node 2.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;postdev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node 3.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>运行 <code>npm run dev</code>, 自动执行了 1.js 2.js 3.js</p>
<blockquote>
<p>比如一个打包命令，之前可以做一个清理的任务，最后做一个发布的工作，比如写一个CI脚本顺便把代码提交了</p>
<p>Vue-cli也是用了生命周期pretest: ‘yarn clean’</p>
</blockquote>
<h1 id="npx"><a class="markdownIt-Anchor" href="#npx"></a> npx</h1>
<p>npm高版本自带的命令行工具</p>
<p><strong>运行node_modules/.bin 下的可执行文件</strong></p>
<blockquote>
<p>之前通过package.json 中的scripts 配合npm run实现，现在可通过npx运行不需要安装这个依赖包运行命令</p>
</blockquote>
<ul>
<li>
<p>避免全局安装</p>
<ul>
<li>当前项目node_modules/.bin —&gt; 全局modules/.bin —&gt; 官网下载，用完删除（需要联网），减少内存占用</li>
</ul>
</li>
<li>
<p>总是使用最新版本</p>
</li>
<li>
<p>执行任意npm包</p>
</li>
</ul>
<blockquote>
<p>在一个项目中，<code>npm i vite</code></p>
<p>没有全局安装，直接运行vite肯定是不行的，</p>
<p>此时配合npx， <code>npx vite</code> 在项目中的node_modules/.bin中查找运行</p>
</blockquote>
<h2 id="与npm区别"><a class="markdownIt-Anchor" href="#与npm区别"></a> 与npm区别</h2>
<p>npx侧重执行命令</p>
<p>npm侧重安装或卸载某个模块，不具备执行某个模块的功能</p>
<h1 id="发布npm包"><a class="markdownIt-Anchor" href="#发布npm包"></a> 发布npm包</h1>
<ul>
<li><code>npm addUser</code>（创建npm账号）</li>
<li><code>npm login</code> 登录( 使用<strong>官方的源</strong>，而不是第三方镜像源)</li>
<li><code>npm publish</code>  发布（同版本号不能重新发布，包名唯一）</li>
</ul>
<h1 id="构建npm私服"><a class="markdownIt-Anchor" href="#构建npm私服"></a> 构建npm私服</h1>
<ul>
<li>部署到内网集群，离线使用</li>
<li>安全性</li>
<li>提高包下载速度</li>
</ul>
<p>利用<code>verdaccio</code>库</p>
<img src="https://s2.loli.net/2023/09/02/PZQCziu4qrKAsRk.png" alt="image-20230902172055264" style="width:50%;" />
<ul>
<li><code>npm i verdaccio -g</code></li>
<li><code>verdaccio --listen 5000</code> 开启服务</li>
<li>发包流程与之前的差不多
<ul>
<li>
<img src="https://s2.loli.net/2023/09/02/zYhy9muZv8cWD3H.png" alt="image-20230902172055264" style="width:50%;" /></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>React小记</title>
    <url>/posts/react%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="react库和框架的区别是什么"><a class="markdownIt-Anchor" href="#react库和框架的区别是什么"></a> React库和框架的区别是什么？</h2>
<ul>
<li>页面组件化</li>
<li>数据驱动</li>
</ul>
<p>MVC V层</p>
<blockquote>
<p>react库</p>
<p>​	react.js是一个开放的js工具库，用于基于UI自检构建用户界面</p>
</blockquote>
<blockquote>
<p>react框架</p>
<p>​	通过脚手架工具搭建的一套完善的前端环境，包括：路由、状态管理、数据获取、第三方的UI组件库和第三方Hooks库(ahooks react-use)</p>
</blockquote>
<h2 id="严格模式"><a class="markdownIt-Anchor" href="#严格模式"></a> 严格模式</h2>
<p>​	检查组件是否为<strong>纯函数</strong></p>
<p>​	及早的发现useEffect中的错误</p>
<p>​	警告过时的API</p>
<h2 id="eslint"><a class="markdownIt-Anchor" href="#eslint"></a> ESLint</h2>
<p>​	代码规范插件</p>
<blockquote>
<p>npm run lint</p>
<p>vite-plugin-eslint （vite构建下）</p>
</blockquote>
<h2 id="prettier"><a class="markdownIt-Anchor" href="#prettier"></a> Prettier</h2>
<p>​	代码格式化插件</p>
<h2 id="react模块"><a class="markdownIt-Anchor" href="#react模块"></a> react模块</h2>
<p>​	核心功能</p>
<p>​	组件</p>
<h2 id="react-dom"><a class="markdownIt-Anchor" href="#react-dom"></a> react-dom</h2>
<p>​	操作浏览器DOM</p>
<p>​	<code>react-dom/client</code> 客户端渲染使用</p>
<p>​	<code>react-dom/server </code>服务端渲染使用</p>
<blockquote>
<p>分离不同代码库，可跨平台使用</p>
<p>比如 编写<code>react-native</code>应用，当然不用使用<code>react-dom</code>模块</p>
</blockquote>
<p>利用<strong>编译器</strong>编译成中间这种<code>reactElement</code>对象格式(虚拟DOM)，再利用<code>react-dom</code>库完成</p>
<p><img src="https://s2.loli.net/2023/07/25/cHAiE6MDN71R9pW.png" alt="image-20230719112407499.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/94UeQaLNsGli1JP.png" alt="image-20230719140934815.png" /></p>
<h2 id="fragment"><a class="markdownIt-Anchor" href="#fragment"></a> fragment</h2>
<p><code>&lt;&gt;&lt;/&gt;</code> 简写，这种方式不能写key</p>
<h2 id="classnames-控制样式"><a class="markdownIt-Anchor" href="#classnames-控制样式"></a> classnames 控制样式</h2>
<p><img src="https://s2.loli.net/2023/07/25/no2bQfZGqpJ3rz4.png" alt="image.png" /></p>
<h2 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h2>
<p>​	合成事件：处理事件有差异（onmouse<u>enter</u> 实际使用的是<u>over</u>）</p>
<p>​	事件委托：委托到容器’root’元素</p>
<p><img src="https://s2.loli.net/2023/07/25/4doOvBUxuV2z8fc.png" alt="image-20230719143026471.png" /></p>
<p>​	传参处理</p>
<p>​		箭头函数</p>
<p>​		高阶函数</p>
<h2 id="条件渲染"><a class="markdownIt-Anchor" href="#条件渲染"></a> 条件渲染</h2>
<p>​	条件分支if else switch case</p>
<p>​	三目 ? :</p>
<p>​	逻辑运算符 || ?? &amp;&amp;</p>
<blockquote>
<p>不会渲染的值：null、undefined、boolean、‘’ 、对象、函数</p>
<p>利用JSON.stringify() 或者 {undefied +‘’}(拼接空串)</p>
</blockquote>
<p>​</p>
<h2 id="数组渲染"><a class="markdownIt-Anchor" href="#数组渲染"></a> 数组渲染</h2>
<blockquote>
<p>​	<font color=red>jsx默认对数组进行join()操作</font></p>
</blockquote>
<p>​	循环语句</p>
<p>​	<img src="https://s2.loli.net/2023/07/25/Gc83QLyR5SVbFKW.png" alt="image-20230719144614400.png" /></p>
<p>​	数组方法（map）</p>
<blockquote>
<p>必须写key</p>
<p>帮助react推断发生了什么，从而得以正确的更新DOM树</p>
<p>跟踪列表每一项的身份， 唯一标识</p>
</blockquote>
<h2 id="组件的u点标记u写法"><a class="markdownIt-Anchor" href="#组件的u点标记u写法"></a> 组件的<u>点标记</u>写法</h2>
<h3 id="对象形式"><a class="markdownIt-Anchor" href="#对象形式"></a> 对象形式</h3>
<p>​		组件写为对象的方法</p>
<p>​		可解构使用</p>
<p><img src="https://s2.loli.net/2023/07/25/ZSJRGjxKWVdFlE9.png" alt="image-20230719145530569.png" /></p>
<h3 id="函数形式更好的进行组件分类"><a class="markdownIt-Anchor" href="#函数形式更好的进行组件分类"></a> 函数形式（更好的进行组件分类</h3>
<p>​	将组件直接挂载在上级组件上</p>
<p>​		<img src="https://s2.loli.net/2023/07/25/mMoLItqRXs6hyA5.png" alt="image-20230719145906028.png" /></p>
<h2 id="组件通信方式"><a class="markdownIt-Anchor" href="#组件通信方式"></a> 组件通信方式</h2>
<p>props传递值</p>
<p>​	整体接收， 解构接收</p>
<p>props传递事件</p>
<p>通过扩展运算符{…}批量上传</p>
<h2 id="组件组合方式"><a class="markdownIt-Anchor" href="#组件组合方式"></a> 组件组合方式</h2>
<blockquote>
<p>插槽</p>
</blockquote>
<p>利用props的children属性</p>
<p><img src="https://s2.loli.net/2023/07/25/fgLQPnTCZsOKjov.png" alt="image-20230719151126002.png" /></p>
<p>​	指定顺序</p>
<p><img src="https://s2.loli.net/2023/07/25/l326jsNfERpq4n8.png" alt="image-20230719151821461.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/35jOCBYAGLvbMSr.png" alt="image-20230719153233192.png" /></p>
<h2 id="props默认值"><a class="markdownIt-Anchor" href="#props默认值"></a> props默认值</h2>
<p>​	利用es6的默认值方式</p>
<p><img src="https://s2.loli.net/2023/07/25/35jOCBYAGLvbMSr.png" alt="image-20230719153233192.png" /></p>
<p>​	react的defaultProps</p>
<p><img src="https://s2.loli.net/2023/07/25/7Mbkav82tCNFzhP.png" alt="image-20230719153301244.png" /></p>
<h2 id="props类型限定"><a class="markdownIt-Anchor" href="#props类型限定"></a> props类型限定</h2>
<p>​	使用ts</p>
<p>​	使用第三方proptypes</p>
<h2 id="组件纯函数"><a class="markdownIt-Anchor" href="#组件纯函数"></a> 组件纯函数</h2>
<p>​	只负责自己的任务，不会在更改函数调用前就已存在的对象和变量。（不能修改这个函数组件作用域外的对象和变量）</p>
<blockquote>
<p>​	<strong>严格模式</strong>检测当前组件是否为纯函数，对这函数调用两次，检测值是否变化</p>
</blockquote>
<p>​	输入相同，则输出相同。纯函数总是返回相同的结果。</p>
<blockquote>
<p>​	不管调用多次，函数都输出同一个值，对于<strong>测试</strong>更方便。<strong>增强健壮性</strong></p>
</blockquote>
<h2 id="组件的状态"><a class="markdownIt-Anchor" href="#组件的状态"></a> 组件的状态</h2>
<p>瞬间变化的数据被称为状态（state），状态可以<strong>进行数据驱动</strong></p>
<p>useState hooks 提供 <u>状态</u> 和 <u>修改状态</u>的方法</p>
<p>​	普通变量 无法重新渲染JSX</p>
<p>​	state状态，重新触发函数组件，并且具备<strong>组件的<font color=red>记忆</font></strong>。</p>
<blockquote>
<p>​	普通纯函数函数， 多次调用执行结果</p>
</blockquote>
<h3 id="状态是如何改变视图的"><a class="markdownIt-Anchor" href="#状态是如何改变视图的"></a> 状态是如何改变视图的</h3>
<p>渲染与提交的过程</p>
<p>1️⃣触发一次渲染</p>
<p>​	💡组件的初次渲染，createRoot.render</p>
<p>​	🔦内部状态更新，触发渲染送入队列</p>
<p>2️⃣渲染您的组件</p>
<p>​	💡在进行初次渲染，react调用根组件<code>&lt;App/&gt;</code></p>
<p>​	🔦内部状态更新，会渲染对应的函数组件</p>
<p>3️⃣提交到DOM上</p>
<p>​	💡初次渲染，appendChild DOM API</p>
<p>​	🔦内部状态更新，更新差异的DOM节点</p>
<h3 id="多状态如何正确记忆"><a class="markdownIt-Anchor" href="#多状态如何正确记忆"></a> 多状态如何正确记忆？</h3>
<p>同一个组件的每次渲染中，useState都依托于一个稳定的调用顺序</p>
<p>在react内部，每个组件保存了一个数组， 按照索引记忆usestate位置。<code>[&#123;索引，useState对&#125;]</code></p>
<blockquote>
<p>所以不要将useState写到一些分支逻辑中，会打乱useState顺序</p>
</blockquote>
<p>配合eslint检查，语法是否合规</p>
<h3 id="状态的快照"><a class="markdownIt-Anchor" href="#状态的快照"></a> 状态的快照</h3>
<p>本次作用域中的状态不会改变</p>
<p><img src="https://s2.loli.net/2023/07/25/uh6UXZsLEilwmjY.png" alt="image-20230719163835286.png" /></p>
<p>点击后，触发三次setcount，但是当前作用域的count都为0</p>
<p>快照的陷阱，异步的时候造成错觉，其实异步逻辑中的状态还是依赖于这次函数作用域</p>
<p><img src="https://s2.loli.net/2023/07/25/65ayv4H7KrhLoli.png" alt="image-20230719164801330.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/9IhUgbs7ZVlW3Hz.png" alt="image-20230719165254304.png" /></p>
<blockquote>
<p>词法作用域，只看定义，不看调用</p>
</blockquote>
<h3 id="状态队列与自动批处理"><a class="markdownIt-Anchor" href="#状态队列与自动批处理"></a> 状态队列与自动批处理</h3>
<p>自动批处理</p>
<p>​	等事件处理函数中的所有代码都运行完毕再处理你的state更新</p>
<p>​	队列都执行完毕后，在进行ui更新</p>
<p>更新函数的写法</p>
<p><img src="https://s2.loli.net/2023/07/25/iCsuQxMSc71oygb.png" alt="image-20230719170017902.png" /></p>
<p>形参c来自于react内部，所以这里并不是保存的count快照，连续调用三次后，得到3</p>
<blockquote>
<p>更新函数在内部还是以回调的形式，但没使用形参</p>
</blockquote>
<h3 id="严格遵守状态不可变"><a class="markdownIt-Anchor" href="#严格遵守状态不可变"></a> 严格遵守状态不可变</h3>
<p><strong>默认</strong>情况下，修改的状态跟上一次相同的情况下，是不会重新触发渲染</p>
<h3 id="引用数据类型"><a class="markdownIt-Anchor" href="#引用数据类型"></a> 引用数据类型</h3>
<p>拷贝</p>
<p>​	数组，使用相关方法</p>
<p>​	扩展运算符</p>
<p>​	深克隆（将没改变的数据也是克隆了一份）</p>
<p>​	immer useimmer 可以直接对数据进行修改</p>
<h3 id="惰性初始化状态的值"><a class="markdownIt-Anchor" href="#惰性初始化状态的值"></a> 惰性初始化状态的值</h3>
<p>当状态的值组要通过复杂计算才能得到的话，可以对其进行惰性初始化</p>
<blockquote>
<p>只在初始化的时候执行一次</p>
</blockquote>
<h3 id="状态提升解决共享问题"><a class="markdownIt-Anchor" href="#状态提升解决共享问题"></a> 状态提升解决共享问题</h3>
<p>父组件管理状态，子组件props</p>
<h3 id="状态的重置处理问题"><a class="markdownIt-Anchor" href="#状态的重置处理问题"></a> 状态的重置处理问题</h3>
<p>当组件被销毁会时，所对应的状态也会被重置</p>
<p>当<strong>组件位置</strong>没有发生变化，状态会被保留</p>
<p><img src="https://s2.loli.net/2023/07/25/hZIvLofTXFxWDYz.gif" alt="状态重置1.gif" /></p>
<blockquote>
<p>组件渲染位置发生变化，状态不被保留</p>
<p><img src="https://s2.loli.net/2023/07/25/7rkxUmafhFbcqGS.gif" alt="状态-不同位置.gif" /></p>
</blockquote>
<p>不同的结构体，给组件添加<strong>key属性</strong></p>
<blockquote>
<p><font color=red>diff算法，同层级的元素是否发生改变</font></p>
</blockquote>
<h3 id="利用状态产生计算变量"><a class="markdownIt-Anchor" href="#利用状态产生计算变量"></a> 利用状态产生计算变量</h3>
<p>根据<strong>状态会重新渲染组件</strong>的特性，利用当前<strong>状态快照</strong>生成对应的计算变量</p>
<p><img src="https://s2.loli.net/2023/07/25/BQFsjgh3nrIdA6k.gif" alt="chrome-capture-2023-6-20.gif" /></p>
<h2 id="受控组件与非受控组件"><a class="markdownIt-Anchor" href="#受控组件与非受控组件"></a> 受控组件与非受控组件</h2>
<p>通过props控制的组件成为受控，通过state控制的组件称为非受控组件</p>
<p>react表单内置了受控组件的行为</p>
<p>​	value + onChange</p>
<p>​	checked + onChange</p>
<p>input标签并不是原始的标签</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          console.log(e.target.value);</span></span><br><span class="line"><span class="language-xml">          setValue(e.target.value)</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="hooks"><a class="markdownIt-Anchor" href="#hooks"></a> Hooks</h1>
<p>react中以use开头的函数被称为Hook钩子，Hooks被称为use函数的集合，也就是钩子的集合</p>
<p>Hooks就是一堆功能函数，（像插件</p>
<p>分为： 内置、自定义、第三方</p>
<h2 id="useref"><a class="markdownIt-Anchor" href="#useref"></a> useRef</h2>
<p>使用ref引用一个值，具备记忆功能</p>
<p>改变ref不会触发重新渲染组件</p>
<p><img src="https://s2.loli.net/2023/07/25/iyCeFSGRxWDZXlr.png" alt="image-20230720100818798.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/XSUFWpV4CJlBMT3.png" alt="image-20230720101032139.png" /></p>
<p>定时器案例：timer用ref存储，始终引用的同一个值</p>
<h3 id="useref进行dom操作"><a class="markdownIt-Anchor" href="#useref进行dom操作"></a> useref进行dom操作</h3>
<p>​	如：让元素获取焦点，滚动到他或测量尺寸位置</p>
<h3 id="回调写法在逻辑中操作dom"><a class="markdownIt-Anchor" href="#回调写法在逻辑中操作dom"></a> 回调写法，在逻辑中操作dom</h3>
<p><img src="https://s2.loli.net/2023/07/25/vtEOLCYA8DgBTfR.png" alt="image-20230720102321632.png" /></p>
<h3 id="forwardref"><a class="markdownIt-Anchor" href="#forwardref"></a> forwardRef</h3>
<p>给<strong>组件</strong>设置ref需要forwardRef<strong>转发</strong></p>
<p>forwardRef让您的组件通过ref向父组件公开DOM节点</p>
<p>直接转发ref给子组件报错</p>
<p><img src="https://s2.loli.net/2023/07/25/kVQnM81xyLu7oDC.png" alt="image-20230724150124791.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/B5Kh6kOrXaLWQdm.png" alt="image-20230724151308635.png" /></p>
<h3 id="useimperativehandle"><a class="markdownIt-Anchor" href="#useimperativehandle"></a> useImperativeHandle</h3>
<p>自定义由ref暴露出来的句柄</p>
<p><img src="https://s2.loli.net/2023/07/25/HSitNEdGyln4KzI.png" alt="image-20230724153237639.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/7h8YMuCK4WTOwyz.png" alt="image-20230724153456747.png" /></p>
<h2 id="纯函数处理useeffect"><a class="markdownIt-Anchor" href="#纯函数处理useeffect"></a> 纯函数处理useEffect</h2>
<p>纯函数：</p>
<p>副作用：</p>
<p>​	函数在执行过程中对外部造成的影响成为副作用，如ajax、dom操作、与外部系统同步</p>
<p>​	事件可以处理副作用，onclick事件等</p>
<p>​	处理副作用，借助useEffect钩子</p>
<p>useEffect触发时机，<strong>jsx渲染后触发</strong></p>
<p>依赖项，<a href="http://xn--Object-hs2j6622blval8d.is">内部通过Object.is</a>() 方法判定</p>
<p>​	当依赖项为空，指挥初始渲染</p>
<p>​	ESLint会检查依赖项是否正确，包括props state 计算变量</p>
<h3 id="函数写在useeffect中"><a class="markdownIt-Anchor" href="#函数写在useeffect中"></a> 函数写在useEffect中</h3>
<p>useCallback</p>
<p>函数始终是同一个</p>
<p>每次重新渲染函数，函数指向地址发生改变</p>
<h3 id="useeffect清理工作"><a class="markdownIt-Anchor" href="#useeffect清理工作"></a> useEffect清理工作</h3>
<p>严格模式，检测有无做清理工作</p>
<p>初始化数据时，注意清理操作，</p>
<p>​	更简洁的方法是使用第三方，ahooks的useRequest</p>
<h2 id="useeffectevent"><a class="markdownIt-Anchor" href="#useeffectevent"></a> useEffectEvent</h2>
<p><img src="https://s2.loli.net/2023/07/25/uKlfrvej4UA2OqJ.png" alt="image-20230724162726502.png" /></p>
<h2 id="uselayouteffect-同步执行状态更新"><a class="markdownIt-Anchor" href="#uselayouteffect-同步执行状态更新"></a> useLayoutEffect 同步执行状态更新</h2>
<p>useEffect是在渲染之后，更新之前</p>
<p>如过需要在useEffect中处理DOM，并且改变页面的样式，就需要使用useLayoutEffect，</p>
<h2 id="useinsertioneffect-dom更新前触发"><a class="markdownIt-Anchor" href="#useinsertioneffect-dom更新前触发"></a> useInsertionEffect DOM更新前触发</h2>
<p>此时拿不到dom元素</p>
<p>在css-in-js库中使用的多</p>
<h2 id="usereducer"><a class="markdownIt-Anchor" href="#usereducer"></a> useReducer</h2>
<p>局部的状态管理，抽离逻辑</p>
<h2 id="useimmerreducer"><a class="markdownIt-Anchor" href="#useimmerreducer"></a> useImmerReducer</h2>
<p>immer类型数据</p>
<h2 id="context向组件深层次传递数据"><a class="markdownIt-Anchor" href="#context向组件深层次传递数据"></a> Context向组件深层次传递数据</h2>
<blockquote>
<p>reducer配合context实现状态数据共享</p>
<p>更复杂的情况使用第三方库,redux mobx,zuster</p>
</blockquote>
<h2 id="memo在props不变时跳过重新渲染"><a class="markdownIt-Anchor" href="#memo在props不变时跳过重新渲染"></a> memo在props不变时跳过重新渲染</h2>
<p>达到一些性能优化</p>
<blockquote>
<p>props改变的情况下，会重新渲染组件</p>
</blockquote>
<p>没有props</p>
<p><img src="https://s2.loli.net/2023/07/25/Prz2fHX5ksuL71b.gif" alt="memo-props1.gif" /></p>
<p><img src="https://s2.loli.net/2023/07/25/bUIa1KeAVdiRzNg.gif" alt="memo-props2.gif" /></p>
<h2 id="usememo对计算结果进行缓存"><a class="markdownIt-Anchor" href="#usememo对计算结果进行缓存"></a> useMemo对计算结果进行缓存</h2>
<p>虽然使用memo，并且props <strong>数组list****值</strong>未变化，但是list的引用地址发生变化，底层使用<code>Object.is([], []) ==&gt;flase</code> 比较，则<strong>props值</strong>改变</p>
<p><img src="https://s2.loli.net/2023/07/25/G6FMPfQ1NcULiWZ.gif" alt="usememo1.gif" /></p>
<p>使用useMemo对计算数据进行缓存（类似useCallback缓存函数）</p>
<h2 id="usecallback对函数进行缓存"><a class="markdownIt-Anchor" href="#usecallback对函数进行缓存"></a> useCallback对函数进行缓存</h2>
<p>useMemo的一种特殊写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const fn = useMemo(()=&gt; () =&gt; &#123; console.log(1) &#125;)</span><br><span class="line">const fn = useCallback(() =&gt; &#123; console.log(1) &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="starttrasition-方法及并发模式"><a class="markdownIt-Anchor" href="#starttrasition-方法及并发模式"></a> StartTrasition 方法及并发模式</h2>
<p>​	react18开始，渲染是一个单一的、不间断的、同步的事务，一旦渲染开始，就不能被中断</p>
<pre><code>react18引入并发模式，允许标记更新作为一个transition，这回告诉react它们可以被中断执行。这样可以把紧急的任务先更新，不紧急的任务后更新
</code></pre>
<p><code>任务切换</code></p>
<h2 id="usetrasition-hook"><a class="markdownIt-Anchor" href="#usetrasition-hook"></a> useTrasition hook</h2>
<p>提供一个pending状态的布尔值，（配合实现一个loading效果），还有一个startTrasition方法</p>
<p><img src="https://s2.loli.net/2023/07/25/8l6byIz1rWvnd39.gif" alt="useTransition.gif" /></p>
<h2 id="usedeferredvalue-延迟"><a class="markdownIt-Anchor" href="#usedeferredvalue-延迟"></a> useDeferredValue 延迟</h2>
<p>获取该值的延迟版本</p>
<p><img src="https://s2.loli.net/2023/07/25/UoeJhxVuCiRt2DB.gif" alt="useDeferredValue.gif" /></p>
<h2 id="useid-产生唯一标识"><a class="markdownIt-Anchor" href="#useid-产生唯一标识"></a> useId 产生唯一标识</h2>
<p>id 局部前缀</p>
<p>​	xxx + id (字符串拼接)</p>
<p>id 全局前缀</p>
<p>​	createRoot 第二参</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)!, &#123;</span><br><span class="line">  <span class="attr">identifierPrefix</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="usedebugvalue"><a class="markdownIt-Anchor" href="#usedebugvalue"></a> useDebugValue</h2>
<p>在自定义hook中打印信息，devtool</p>
<h2 id="usesyncexternalstore"><a class="markdownIt-Anchor" href="#usesyncexternalstore"></a> useSyncExternalStore</h2>
<p>操作状态</p>
<p>订阅外部 store 的 React Hook。</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>redux-toolkit学习</title>
    <url>/posts/redux-toolkit%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="redux-toolkit"><a class="markdownIt-Anchor" href="#redux-toolkit"></a> Redux-Toolkit</h1>
<blockquote>
<p>摘自官网</p>
<p><strong><a href="https://redux-toolkit.js.org/">Redux Toolkit</a></strong> 是 Redux 官方强烈推荐，开箱即用的一个高效的 Redux 开发工具集。</p>
<p>简化最常见场景下的 Redux 开发，</p>
<p>​	包括配置 store、定义 reducer，不可变的更新逻辑</p>
<p>​	可以立即创建整个状态的 “切片 slice”，而<strong>无需手动编写任何 action creator 或者 action type</strong></p>
<p>自带了一些最常用的 Redux 插件，</p>
<p>​	例如用于异步逻辑 Redux Thunk，</p>
<p>​	用于编写选择器 selector 的函数 Reselect （可缓存select数据）</p>
</blockquote>
<p>在 Redux 中,**切片(Slice)**指的是使用 <strong>createSlice</strong> API 创建的 reducer 和 action 的组合。它是 Redux Toolkit 中的一个核心概念。</p>
<p>createSlice 接收一个配置对象参数,里面包含:</p>
<blockquote>
<ul>
<li>初始 state</li>
<li>reducers:包含不同 reducer 的对象</li>
<li>extraReducers:处理 action 的 reducer 函数</li>
</ul>
</blockquote>
<ul>
<li>切片让我们可以<strong>把 reducer 与 action 打包在一起</strong></li>
<li>创建<strong>简化</strong>了编写 <strong>reducer</strong> 的流程</li>
<li><strong>自动生成 action</strong> 类型</li>
</ul>
<p>⚙️ CRA新建一个react项目</p>
<p><code>create-react-app myapp --template typescript</code></p>
<p>⚙️ 安装react-redux react-toolkit</p>
<p><code>npm install @reduxjs/toolkit react-redux </code></p>
<table>
<thead>
<tr>
<th style="text-align:center">项目基本结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://s2.loli.net/2023/07/14/v4muItCeOgTFfaV.png" alt="image-20230714095149784.png" style="zoom:67%;" /></td>
</tr>
</tbody>
</table>
<ul>
<li>新建状态管理主文件</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&quot;./slice/counterSlice&quot;</span> <span class="comment">// 由切片导入的reducer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">    <span class="attr">reducer</span>: &#123;</span><br><span class="line">        <span class="attr">counter</span>: counterReducer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据store本身推断出推断 `RootState` 和 `AppDispatch`类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">RootState</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> store.<span class="property">getState</span>&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">AppDispatch</span> = <span class="keyword">typeof</span> store.<span class="property">dispatch</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在项目入口文件，给App组件<strong>注入store</strong></li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">&#x27;./redux/store&#x27;</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line">);</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>创建切片</li>
</ul>
<blockquote>
<p>之前利用 都要分别写各自actionCreator和各自的reducer， 现在只用一个切片即可管理</p>
</blockquote>
<p>😇 React Toolkit 创建的 Slice 状态state本身是 <code>immutable</code> 的，所以可以放心的直接加工使用</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/redux/slice/counterSlice.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PayloadAction</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ICounterState</span> &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">initialState</span>: <span class="title class_">ICounterState</span> = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建切片</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">    initialState,</span><br><span class="line">    <span class="attr">reducers</span>: &#123;</span><br><span class="line">        <span class="attr">increment</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">            state.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">decrement</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">            state.<span class="property">value</span> -= <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">incrementByAmount</span>: <span class="function">(<span class="params">state, action: PayloadAction&lt;<span class="built_in">number</span>&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">            state.<span class="property">value</span> += action.<span class="property">payload</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Action creators 会在各自的reducer函数中自动创建， 这里直接导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; increment, decrement, incrementByAmount &#125; = counterSlice.<span class="property">actions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 💡注意&gt; 默认导出的是reducer</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span></span><br></pre></td></tr></table></figure>
<ul>
<li>尝试在App.tsx组件中使用</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AppDispatch</span>, <span class="title class_">RootState</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./redux/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; decrement, increment, incrementByAmount &#125; <span class="keyword">from</span> <span class="string">&#x27;./redux/slice/counterSlice&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useSelector</span>(<span class="function">(<span class="params">state: RootState</span>) =&gt;</span> state.<span class="property">counter</span>.<span class="property">value</span>)</span><br><span class="line">  <span class="keyword">const</span> disptach = useDispatch&lt;<span class="title class_">AppDispatch</span>&gt;()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> disptach(increment())&#125;&gt;点击我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> disptach(decrement())&#125;&gt;点击我-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> disptach(incrementByAmount(100))&#125;&gt;点击我+100<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>✅成功</p>
<p><img src="https://s2.loli.net/2023/07/14/QKWlncjEVHUgGRN.gif" alt="屏幕录制2023-07-14-上午10.12.15" /></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/posts/test/</url>
    <content><![CDATA[<p>aaaaaaaa</p>
]]></content>
  </entry>
  <entry>
    <title>vue3数据绑定之-sync</title>
    <url>/posts/vue3%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B9%8B-sync/</url>
    <content><![CDATA[<p><s><strong><font color=red>啊啊啊啊学了这么久vue3还不知道<code>sync</code>已经在vue3中被剔除了！！！</font></strong></s></p>
<p>在vue2中我们利用v-bind值给子组件，子组件props接受父组件传来的值</p>
<p><img src="https://s2.loli.net/2023/08/04/seqYNjUDltL2Avd.png" alt="image-20230804094605352.png" /></p>
<p><img src="https://s2.loli.net/2023/08/04/Quritsa3AmvLZH1.png" alt="" /></p>
<p>子组件想直接通过props修该父组件传来的值，是不被允许的，这违背了<strong>单项数据流</strong>的原则</p>
<p><img src="https://s2.loli.net/2023/08/04/bFmpQ6fGHYwAIrn.png" alt="" /></p>
<p>那要子组件想要修改父组件的值，需要通过<strong>自定义事件</strong></p>
<p>由父组件定义回调，子组件<code>emit</code>触发回调函数通知父组件修改改，（这里就不展开述说了）</p>
<hr />
<p>在vue2中提供了一个<code>v-bind</code>修饰符<code>.sync</code>，旨在传递一个值给子组件，而子组件可以更改这个值</p>
<p><img src="https://s2.loli.net/2023/08/04/SQyuDWsB5ZbaLP6.png" alt="" /></p>
<p><img src="https://s2.loli.net/2023/08/04/P4WCG5B71k9q6cR.gif" alt="" /></p>
<p>而在vue3中这个sync被v-model替代了</p>
<blockquote>
<p>传递给子组件的，vmodel绑定的这个值一定得是响应式的</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/08/04/tegdIJlGUPpxYmV.png" alt="" /></p>
<p><img src="https://s2.loli.net/2023/08/04/yoMnjfHrslQcXFv.gif" alt="" /></p>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>一键速通菲区Spotify</title>
    <url>/posts/%E4%B8%80%E9%94%AE%E9%80%9F%E9%80%9A%E8%8F%B2%E5%8C%BASpotify/</url>
    <content><![CDATA[<h3 id="prerequisite"><a class="markdownIt-Anchor" href="#prerequisite"></a> prerequisite</h3>
<p>菲区电话卡、菲区梯子🪜</p>
<h3 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h3>
<ol start="0">
<li>
<p>Spotify换区（挂上🇵🇭🪜）</p>
</li>
<li>
<p>某宝下单菲律宾电话卡（推荐Globe卡￥20+）</p>
</li>
<li>
<p>话费充值（推荐易付宝， Google Play下载）</p>
</li>
<li>
<p>登录进入<strong>手机端Spotify</strong>，选择套餐通过<strong>话费充值</strong></p>
</li>
</ol>
<h3 id="切记"><a class="markdownIt-Anchor" href="#切记"></a> 切记💡</h3>
<ul>
<li><strong>第三步</strong>，必须在手机端中操作，账号登录成功后不要挂任何🪜，网络直连就行</li>
</ul>
<h3 id="other"><a class="markdownIt-Anchor" href="#other"></a> Other</h3>
<p>也可以试试<code>GCash</code>支付，需要实名。</p>
<p>应填写真实的信息（护照等），不然一个月之内检测被封。（谷歌搜有相应的教程）</p>
]]></content>
      <tags>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title>杂项</title>
    <url>/posts/%E6%9D%82%E9%A1%B9/</url>
    <content><![CDATA[<p><mark>highlight</mark><br />
​🈂️​</p>
<h4 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>滑动验证</title>
    <url>/posts/%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>最近在写一个注册表单的需要一个滑动验证模块。</p>
<p>👨‍💻网上搜寻一番，发现了一个组件比较好用<a href="https://github.com/javaLuo/vue-puzzle-vcode"><code>vue3-puzzle-vcode</code></a></p>
<hr />
<ul>
<li>
<h3 id="配合element-plus-dialog-和-form-组件使用"><a class="markdownIt-Anchor" href="#配合element-plus-dialog-和-form-组件使用"></a> 配合<code>ELement-Plus</code>:  dialog 和 form 组件使用</h3>
</li>
</ul>
<h4 id="login组件控制register表单组件显示"><a class="markdownIt-Anchor" href="#login组件控制register表单组件显示"></a> Login组件控制Register表单组件显示</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//login.vue</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import Register from &#x27;@/components/Register.vue&#x27;</span><br><span class="line">const registerDiaVisible = ref(false)</span><br><span class="line">const openRegisterDia = () =&gt; &#123;</span><br><span class="line">	registerDiaVisible.value = true</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">...</span><br><span class="line">&lt;Register v-model:registerDiaVisible=&quot;registerDiaVisible&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="register组件"><a class="markdownIt-Anchor" href="#register组件"></a> Register组件</h4>
<p>（表单校验成功后，打开滑动验证组件，再次成功调用onSuccess）</p>
<blockquote>
<p>注意调整滑动验证组件的<code>z-index</code>，默认<code>el-dialog</code>组件层级高于<code>Vcode</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; formPost &#125; from &#x27;@/api/request&#x27;</span><br><span class="line">import &#123; ElMessage, FormInstance &#125; from &#x27;element-plus&#x27;</span><br><span class="line">import &#123; reactive, ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import &#123; RegisterForm &#125; from &#x27;@/ts/interfaces/login.interface&#x27;</span><br><span class="line">import Vcode from &#x27;vue3-puzzle-vcode&#x27;</span><br><span class="line">const props = defineProps&lt;&#123;</span><br><span class="line">	registerDiaVisible: boolean</span><br><span class="line">&#125;&gt;()</span><br><span class="line"></span><br><span class="line">const emit = defineEmits&lt;&#123;</span><br><span class="line">	&#x27;update:registerDiaVisible&#x27;: [registerDiaVisible: boolean]</span><br><span class="line">&#125;&gt;()</span><br><span class="line"></span><br><span class="line">const handleCancel = () =&gt; &#123;</span><br><span class="line">	emit(&#x27;update:registerDiaVisible&#x27;, false)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//表单绑定的响应式对象</span><br><span class="line">const formData = reactive(&#123;</span><br><span class="line">	nickName: &#x27;&#x27;,</span><br><span class="line">	realName: &#x27;&#x27;,</span><br><span class="line">	pwd: &#x27;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 表单的引用对象</span><br><span class="line">const formRef = ref()</span><br><span class="line">// 表单校验</span><br><span class="line">const rules = reactive(&#123;</span><br><span class="line">	nickName: [</span><br><span class="line">		&#123; required: true, message: &#x27;请输入昵称&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">		&#123; min: 3, max: 10, message: &#x27;请输入3-10位昵称&#x27;, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">	],</span><br><span class="line">	realName: [</span><br><span class="line">		&#123; required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">		&#123; min: 3, max: 10, message: &#x27;请输入3-10位用户名&#x27;, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">	],</span><br><span class="line">	pwd: [</span><br><span class="line">		&#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">		&#123; min: 3, max: 10, message: &#x27;请输入3-10位密码&#x27;, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const onClose = () =&gt; &#123;</span><br><span class="line">	isShow.value = !isShow.value</span><br><span class="line">&#125;</span><br><span class="line">const onSuccess = () =&gt; &#123;</span><br><span class="line">	// 滑动验证成功, 发送请求</span><br><span class="line">	formPost&lt;RegisterForm, string&gt;(&#123;</span><br><span class="line">		url: &#x27;/user/register&#x27;,</span><br><span class="line">		data: &#123; ...formData &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">		.then(res =&gt; &#123;</span><br><span class="line">			isShow.value = !isShow.value</span><br><span class="line">			ElMessage.success(res.data)</span><br><span class="line">		&#125;)</span><br><span class="line">		.catch(err =&gt; &#123;</span><br><span class="line">			isShow.value = !isShow.value</span><br><span class="line">			ElMessage.error(err.msg)</span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const onSubmit = async (formEl: FormInstance | undefined) =&gt; &#123;</span><br><span class="line">	if (!formEl) return</span><br><span class="line">	formEl.validate((valid, fields) =&gt; &#123;</span><br><span class="line">		if (valid) &#123;</span><br><span class="line">			isShow.value = !isShow.value</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			console.log(&#x27;error submit!&#x27;, fields)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isShow = ref(false)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;el-dialog</span><br><span class="line">		title=&quot;用户注册&quot;</span><br><span class="line">		v-model=&quot;props.registerDiaVisible&quot;</span><br><span class="line">		:before-close=&quot;handleCancel&quot;</span><br><span class="line">	&gt;</span><br><span class="line">		&lt;el-form :rules=&quot;rules&quot; :model=&quot;formData&quot; ref=&quot;formRef&quot;&gt;</span><br><span class="line">			&lt;el-form-item label=&quot;昵称:&quot; label-width=&quot;120&quot; prop=&quot;nickName&quot;&gt;</span><br><span class="line">				&lt;el-input v-model=&quot;formData.nickName&quot; /&gt;</span><br><span class="line">			&lt;/el-form-item&gt;</span><br><span class="line">			&lt;el-form-item label=&quot;姓名:&quot; label-width=&quot;120&quot; prop=&quot;realName&quot;&gt;</span><br><span class="line">				&lt;el-input v-model=&quot;formData.realName&quot; /&gt;</span><br><span class="line">			&lt;/el-form-item&gt;</span><br><span class="line">			&lt;el-form-item label=&quot;密码:&quot; label-width=&quot;120&quot; prop=&quot;pwd&quot;&gt;</span><br><span class="line">				&lt;el-input v-model=&quot;formData.pwd&quot; show-password /&gt;</span><br><span class="line">			&lt;/el-form-item&gt;</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;el-button @click=&quot;handleCancel&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class="line">				&lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit(formRef)&quot;&gt;</span><br><span class="line">					确 定</span><br><span class="line">				&lt;/el-button&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		&lt;/el-form&gt;</span><br><span class="line">	&lt;/el-dialog&gt;</span><br><span class="line">	&lt;Vcode :show=&quot;isShow&quot; @success=&quot;onSuccess&quot; @close=&quot;onClose&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">:global(.vue-puzzle-vcode) &#123;</span><br><span class="line">	z-index: 10000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="final"><a class="markdownIt-Anchor" href="#final"></a> final</h3>
<p><img src="https://s2.loli.net/2023/08/07/NnqX4AMTyiCYkuJ.gif" alt="滑动验证" /></p>
]]></content>
      <tags>
        <tag>vue3</tag>
        <tag>enhanced</tag>
      </tags>
  </entry>
  <entry>
    <title>简单实现Toast组件</title>
    <url>/posts/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0Toast%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>一个模版文件Toast.vue</li>
<li>一个渲染挂载导出方法文件index.ts
<ul>
<li>通过Toast.success(‘xxxx’) 调用</li>
</ul>
</li>
</ul>
</blockquote>
<p>这里UI使用<code>Flowbite</code>的<a href="https://flowbite.com/docs/components/toast/#colors">Toast</a>组件（需要配合tailwindcss）</p>
<p><img src="https://s2.loli.net/2023/08/17/hrfHPm5M8LAZcv4.png" alt="image-20230817102433189.png" /></p>
<h2 id="供给渲染的模板"><a class="markdownIt-Anchor" href="#供给渲染的模板"></a> 供给渲染的模板</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">interface Props &#123;</span><br><span class="line">	visible: boolean</span><br><span class="line">	type: string</span><br><span class="line">	message: string</span><br><span class="line">&#125;</span><br><span class="line">const props = withDefaults(defineProps&lt;Props&gt;(), &#123;</span><br><span class="line">	visible: false,</span><br><span class="line">	type: &#x27;&#x27;,</span><br><span class="line">	message: &#x27;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const status = props.type === &#x27;success&#x27; ? &#x27;success&#x27; : &#x27;danger&#x27;</span><br><span class="line">const toast = ref&lt;HTMLDivElement&gt;()</span><br><span class="line">const handleClose = () =&gt; &#123;</span><br><span class="line">	toast.value!.style.display = &#x27;none&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;Transition</span><br><span class="line">		name=&quot;toast&quot;</span><br><span class="line">		enter-active-class=&quot;transition ease-out duration-300&quot;</span><br><span class="line">		leave-active-class=&quot;transition ease-in duration-300&quot;</span><br><span class="line">	&gt;</span><br><span class="line">		&lt;div class=&quot;fixed inset-0 h-0&quot; v-if=&quot;props.visible&quot;&gt;</span><br><span class="line">			&lt;div</span><br><span class="line">				:id=&quot;`toast-$&#123;status&#125;`&quot;</span><br><span class="line">				class=&quot;absolute top-5 left-1/2 -translate-x-1/2 flex items-center w-full max-w-xs p-4 mb-4 text-gray-500 bg-white rounded-lg shadow dark:text-gray-400 dark:bg-gray-800&quot;</span><br><span class="line">				role=&quot;alert&quot;</span><br><span class="line">				ref=&quot;toast&quot;</span><br><span class="line">			&gt;</span><br><span class="line">				&lt;div</span><br><span class="line">					v-if=&quot;props.type === &#x27;success&#x27;&quot;</span><br><span class="line">					class=&quot;inline-flex items-center justify-center flex-shrink-0 w-8 h-8 text-green-500 bg-green-100 rounded-lg dark:bg-green-800 dark:text-green-200&quot;</span><br><span class="line">				&gt;</span><br><span class="line">					&lt;svg</span><br><span class="line">						class=&quot;w-5 h-5&quot;</span><br><span class="line">						aria-hidden=&quot;true&quot;</span><br><span class="line">						xmlns=&quot;http://www.w3.org/2000/svg&quot;</span><br><span class="line">						fill=&quot;currentColor&quot;</span><br><span class="line">						viewBox=&quot;0 0 20 20&quot;</span><br><span class="line">					&gt;</span><br><span class="line">						&lt;path</span><br><span class="line">							d=&quot;M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5Zm3.707 8.207-4 4a1 1 0 0 1-1.414 0l-2-2a1 1 0 0 1 1.414-1.414L9 10.586l3.293-3.293a1 1 0 0 1 1.414 1.414Z&quot;</span><br><span class="line">						/&gt;</span><br><span class="line">					&lt;/svg&gt;</span><br><span class="line">					&lt;span class=&quot;sr-only&quot;&gt; Check icon &lt;/span&gt;</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">				&lt;div</span><br><span class="line">					v-else-if=&quot;props.type === &#x27;error&#x27;&quot;</span><br><span class="line">					class=&quot;inline-flex items-center justify-center flex-shrink-0 w-8 h-8 text-red-500 bg-red-100 rounded-lg dark:bg-red-800 dark:text-red-200&quot;</span><br><span class="line">				&gt;</span><br><span class="line">					&lt;svg</span><br><span class="line">						class=&quot;w-5 h-5&quot;</span><br><span class="line">						aria-hidden=&quot;true&quot;</span><br><span class="line">						xmlns=&quot;http://www.w3.org/2000/svg&quot;</span><br><span class="line">						fill=&quot;currentColor&quot;</span><br><span class="line">						viewBox=&quot;0 0 20 20&quot;</span><br><span class="line">					&gt;</span><br><span class="line">						&lt;path</span><br><span class="line">							d=&quot;M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5Zm3.707 11.793a1 1 0 1 1-1.414 1.414L10 11.414l-2.293 2.293a1 1 0 0 1-1.414-1.414L8.586 10 6.293 7.707a1 1 0 0 1 1.414-1.414L10 8.586l2.293-2.293a1 1 0 0 1 1.414 1.414L11.414 10l2.293 2.293Z&quot;</span><br><span class="line">						/&gt;</span><br><span class="line">					&lt;/svg&gt;</span><br><span class="line">					&lt;span class=&quot;sr-only&quot;&gt; Error icon &lt;/span&gt;</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line">				&lt;div class=&quot;ml-3 text-sm font-normal&quot;&gt;</span><br><span class="line">					&lt;!-- &#123;/* 不同 */&#125;  --&gt;</span><br><span class="line">					&#123;&#123; props.message &#125;&#125;</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line">				&lt;button</span><br><span class="line">					type=&quot;button&quot;</span><br><span class="line">					class=&quot;ml-auto -mx-1.5 -my-1.5 bg-white text-gray-400 hover:text-gray-900 rounded-lg focus:ring-2 focus:ring-gray-300 p-1.5 hover:bg-gray-100 inline-flex items-center justify-center h-8 w-8 dark:text-gray-500 dark:hover:text-white dark:bg-gray-800 dark:hover:bg-gray-700&quot;</span><br><span class="line">					data-dismiss-target=&quot;#toast-success&quot;</span><br><span class="line">					aria-label=&quot;Close&quot;</span><br><span class="line">					@click=&quot;handleClose&quot;</span><br><span class="line">				&gt;</span><br><span class="line">					&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">					&lt;svg</span><br><span class="line">						class=&quot;w-3 h-3&quot;</span><br><span class="line">						aria-hidden=&quot;true&quot;</span><br><span class="line">						xmlns=&quot;http://www.w3.org/2000/svg&quot;</span><br><span class="line">						fill=&quot;none&quot;</span><br><span class="line">						viewBox=&quot;0 0 14 14&quot;</span><br><span class="line">					&gt;</span><br><span class="line">						&lt;path</span><br><span class="line">							stroke=&quot;currentColor&quot;</span><br><span class="line">							stroke-linecap=&quot;round&quot;</span><br><span class="line">							stroke-linejoin=&quot;round&quot;</span><br><span class="line">							stroke-width=&quot;2&quot;</span><br><span class="line">							d=&quot;m1 1 6 6m0 0 6 6M7 7l6-6M7 7l-6 6&quot;</span><br><span class="line">						/&gt;</span><br><span class="line">					&lt;/svg&gt;</span><br><span class="line">				&lt;/button&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/Transition&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.toast-enter-from,</span><br><span class="line">.toast-leave-to &#123;</span><br><span class="line">	opacity: 0;</span><br><span class="line">	transform: translateY(-30px);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="导出toast方法提供给vue进行挂载"><a class="markdownIt-Anchor" href="#导出toast方法提供给vue进行挂载"></a> 导出toast方法，提供给Vue进行挂载</h2>
<p>index.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ts-nocheck</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp, h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ToastComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./template/Toast.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ToastProps</span> &#123;</span><br><span class="line">	<span class="attr">visible</span>: <span class="built_in">boolean</span></span><br><span class="line">	<span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span> | <span class="string">&#x27;error&#x27;</span></span><br><span class="line">	<span class="attr">message</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ToastContainer</span> = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">	<span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">ToastComponent</span>, <span class="variable language_">this</span>.<span class="property">toastProps</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">toastProps</span>: &#123;</span><br><span class="line">				<span class="attr">visible</span>: <span class="literal">false</span>,</span><br><span class="line">				<span class="attr">type</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">				<span class="attr">message</span>: <span class="string">&#x27;&#x27;</span> </span><br><span class="line">			&#125; <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="title class_">ToastProps</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toast = <span class="title class_">ToastContainer</span>.<span class="title function_">mount</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(toast.<span class="property">$el</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Toast</span> = &#123;</span><br><span class="line">	<span class="title function_">success</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		toast.<span class="property">toastProps</span> = &#123;</span><br><span class="line">			<span class="attr">visible</span>: <span class="literal">true</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">			message</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			toast.<span class="property">toastProps</span>.<span class="property">visible</span> = <span class="literal">false</span></span><br><span class="line">		&#125;, <span class="number">3000</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		toast.<span class="property">toastProps</span> = &#123;</span><br><span class="line">			<span class="attr">visible</span>: <span class="literal">true</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">			message</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			toast.<span class="property">toastProps</span>.<span class="property">visible</span> = <span class="literal">false</span></span><br><span class="line">		&#125;, <span class="number">3000</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Toast</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 👨‍💻使用</h2>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Toast</span>.<span class="title function_">success</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="title class_">Toast</span>.<span class="title function_">error</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/08/17/ewqEhulLyJmUCKH.gif" alt="toast.gif" /></p>
]]></content>
      <tags>
        <tag>enhanced</tag>
      </tags>
  </entry>
  <entry>
    <title>表格导出为excel</title>
    <url>/posts/%E8%A1%A8%E6%A0%BC%E5%AF%BC%E5%87%BA%E4%B8%BAexcel/</url>
    <content><![CDATA[<p><strong>配合xlsx模块 + fileSaver模块</strong></p>
<h2 id="️-下载"><a class="markdownIt-Anchor" href="#️-下载"></a> ⚙️ 下载</h2>
<p><code>yarn add xlsx file-saver</code></p>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 🔦 使用</h2>
<blockquote>
<p>​	tableData格式  [ { 	xxx: yyy 	},  …]</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">XLSX</span> <span class="keyword">from</span> <span class="string">&#x27;xlsx&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FileSaver</span> <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> excelTable = tableData.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line"> 	 <span class="comment">//格式化一下表格数据</span></span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="string">&#x27;系统编号&#x27;</span>: item.<span class="property">id</span>,</span><br><span class="line">			<span class="string">&#x27;账单时间&#x27;</span>: item.<span class="property">billTime</span>,</span><br><span class="line">			<span class="string">&#x27;类型&#x27;</span>: item.<span class="property">natureName</span>=== <span class="string">&#x27;收入&#x27;</span>?<span class="string">&#x27;收入&#x27;</span>:<span class="string">&#x27;支出&#x27;</span>,</span><br><span class="line">			<span class="string">&#x27;金额&#x27;</span>: item.<span class="property">natureName</span>=== <span class="string">&#x27;收入&#x27;</span>?item.<span class="property">amountMoney</span>:-item.<span class="property">amountMoney</span>,</span><br><span class="line">			<span class="string">&#x27;备注&#x27;</span>: item.<span class="property">remarks</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">const</span> worksheet = <span class="variable constant_">XLSX</span>.<span class="property">utils</span>.<span class="title function_">json_to_sheet</span>(excelTable)</span><br><span class="line">	<span class="keyword">const</span> workbook = <span class="variable constant_">XLSX</span>.<span class="property">utils</span>.<span class="title function_">book_new</span>()</span><br><span class="line">	<span class="variable constant_">XLSX</span>.<span class="property">utils</span>.<span class="title function_">book_append_sheet</span>(workbook, worksheet, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">	<span class="keyword">const</span> excelBuffer = <span class="variable constant_">XLSX</span>.<span class="title function_">write</span>(workbook, &#123;</span><br><span class="line">		<span class="attr">bookType</span>: <span class="string">&#x27;xlsx&#x27;</span>,</span><br><span class="line">		<span class="attr">type</span>: <span class="string">&#x27;array&#x27;</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([excelBuffer], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/vnd.ms-excel&#x27;</span> &#125;)</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="title class_">FileSaver</span>.<span class="title function_">saveAs</span>(blob, <span class="string">&#x27;账单&#x27;</span>) <span class="comment">// 下载文件 文件名</span></span><br><span class="line">	&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本来是想利用WebWorker在另一线程中处理数据，<s>在vite中还没配置好，on the way</s>~</p>
</blockquote>
]]></content>
      <tags>
        <tag>enhanced</tag>
      </tags>
  </entry>
  <entry>
    <title>乐山</title>
    <url>/posts/gallery-%E4%B9%90%E5%B1%B1/</url>
    <content><![CDATA[<p>寒假终于有机会出游（<strong>蹭的</strong>）（特别感谢我哥和我嫂子）🫰</p>
<p>三天两晚，乐山城区、苏稽古镇、金口河</p>
<p>（不得不说来乐山旅游的人真的太多多多了，城区每家店子人都爆满</p>
<br />
<p>吃的<code>板眼儿</code>多得<code>遭不住</code>  🆘​</p>
<table>
<thead>
<tr>
<th>炸串（排队排队）</th>
<th>咔饼</th>
<th>豆腐脑（不能接受勾了芡的食品）</th>
<th>甜皮鸭</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://i.imgur.com/yRpOtF2.jpg" alt="油炸" /></td>
<td><img src="https://i.imgur.com/sSO8Tub.jpg" alt="20230202_144544" /></td>
<td><img src="https://i.imgur.com/xSqXXIP.jpg" alt="20230202_143741" /></td>
<td>404忘记拍照了…</td>
</tr>
</tbody>
</table>
<p><code>苏稽翘脚牛肉</code>单拎出来，太好吃了 favorito~</p>
<p><img src="https://i.imgur.com/YsVMSwR.jpg" alt="20230203_122113" /></p>
<p>坐船看了乐山大佛，逛了苏稽古镇，当然最<strong>impressive</strong>的还是金口河大峡谷。。。</p>
<blockquote>
<p>人类真的特别特别渺小</p>
</blockquote>
<table>
<thead>
<tr>
<th><img src="https://i.imgur.com/i0uR66t.jpg" alt="20230203_160746" /></th>
<th><img src="https://i.imgur.com/C3Wh8C3.jpg" alt="20230203_150035" /></th>
<th><img src="https://i.imgur.com/3ROlK0A.jpg" alt="20230203_155615" /></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://i.imgur.com/Hp34XzF.jpg" alt="20230203_150324" /></td>
<td><img src="https://i.imgur.com/r4QpbWh.jpg" alt="20230203_144629" /></td>
<td><img src="https://i.imgur.com/63nBWhM.jpg" alt="20230203_150313" /></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
  </entry>
  <entry>
    <title>面试1</title>
    <url>/posts/%E9%9D%A2%E8%AF%951/</url>
    <content><![CDATA[<p>主要围绕简历展开</p>
<h2 id="自我介绍"><a class="markdownIt-Anchor" href="#自我介绍"></a> 自我介绍</h2>
<blockquote>
<p>​	从未准备过，每次都是“面试官你好，我是来自xx学校xx学院的学生，学习前端xx年了”，然后就戛然而止。。。</p>
</blockquote>
<h2 id="项目"><a class="markdownIt-Anchor" href="#项目"></a> 项目</h2>
<ul>
<li>
<p>实习项目简介</p>
</li>
<li>
<p>实习负责板块介绍</p>
</li>
<li>
<p>难点，遇到什么问题</p>
</li>
<li>
<p>对于技术上手快吗</p>
</li>
</ul>
<h2 id="计网"><a class="markdownIt-Anchor" href="#计网"></a> 计网</h2>
<ul>
<li>Ajax 工作方式</li>
<li>http请求响应过程</li>
</ul>
<h2 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项</h2>
<ul>
<li>JWT
<ul>
<li>前端axios拦截 后端加密解密~</li>
</ul>
</li>
<li>vue react 区别</li>
<li>会不会后端（❓</li>
<li>是否接受加班</li>
</ul>
<h2 id="反问"><a class="markdownIt-Anchor" href="#反问"></a> 反问</h2>
<ul>
<li>公司产品（自研？</li>
<li>工作地点 &amp; 加班</li>
<li>。。。</li>
</ul>
]]></content>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>大理</title>
    <url>/posts/gallery-%E5%A4%A7%E7%90%86/</url>
    <content><![CDATA[<hr />
<p style="font-style: italic; font-size: 20px; font-weight:bold;">
永远怀念那一个自由的夏天
</p>
<hr />
<br />
<h2 id="洱海傍晚"><a class="markdownIt-Anchor" href="#洱海傍晚"></a> 洱海傍晚</h2>
<div style='text-align='center''>
<img src='https://i.imgur.com/YVNCcZb.jpg' alt='洱海傍晚' style="display: block;" />
<p style='font-size: 0.8em;'>我最好的一张摄影作品🫣（just shot on the mobile device）</p>
</div>
<h2 id="喜洲稻田"><a class="markdownIt-Anchor" href="#喜洲稻田"></a> 喜洲稻田</h2>
<img src='https://i.imgur.com/QGuARFO.jpg' alt='喜洲稻田'/>
<h2 id="洱海午后"><a class="markdownIt-Anchor" href="#洱海午后"></a> 洱海午后</h2>
<img src='https://i.imgur.com/HBOvej0.jpg' alt='洱海午后'/>
<h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2>
<table>
<thead>
<tr>
<th><img src="https://i.imgur.com/nC3dGRX.jpg" alt="栓q" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://i.imgur.com/KfS295U.jpg" alt="cat-🍮" style="zoom:50%;" /></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/6FZtChd.jpg" alt="sip" style="zoom: 50%;" /></td>
</tr>
</tbody>
</table>
<blockquote>
<p>I think this is the life, but <strong>august</strong> always slipped away into moment in time 🎯</p>
</blockquote>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
  </entry>
  <entry>
    <title>&#39;tag&#39;</title>
    <url>/posts/zh-CN-tag-index/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
