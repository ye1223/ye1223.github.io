<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>How to Develop AEM Components</title>
    <url>/posts/AEM-dev/</url>
    <content><![CDATA[<h2 id="prerequisites"><a class="markdownIt-Anchor" href="#prerequisites"></a> Prerequisites</h2>
<ul>
<li>Understanding how to configure components are on AEM pages</li>
<li>Basic front-end development skills, not limited to HTML, JavaScript, Vue.js</li>
</ul>
<blockquote>
<p>[!TIP]</p>
<p><strong>Using the CLP project as an example</strong></p>
</blockquote>
<p>The top level directory structure of an AEM project is roughly like this. <strong>Frontend component development</strong> mainly focuses on the <code>ui.apps</code> and <code>ui.frontend</code> directories:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">├── all</span><br><span class="line">├── core</span><br><span class="line">├── it.tests</span><br><span class="line">├── ui.apps</span><br><span class="line">├── ui.apps.structure</span><br><span class="line">├── ui.config</span><br><span class="line">├── ui.content</span><br><span class="line">├── ui.frontend</span><br><span class="line">├── ui.tests</span><br><span class="line">├── archetype.properties</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure>
<br/>
<h2 id="uiapps"><a class="markdownIt-Anchor" href="#uiapps"></a> <code>ui.apps</code></h2>
<blockquote>
<p>Component dialogs and metadata are defined in <code>ui.apps</code></p>
</blockquote>
<p>In <code>ui.apps/src/main/content/jcr_root/apps/clphk-postlogin/components</code>, you can find declared AEM components. Their directory structure is:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">├── _cq_dialog</span><br><span class="line">│   └── .content.xml ①</span><br><span class="line">├── .content.xml ②</span><br><span class="line">└── XXXXX.html</span><br></pre></td></tr></table></figure>
<h3 id="define-component-dialog"><a class="markdownIt-Anchor" href="#define-component-dialog"></a> 🔦 Define Component Dialog</h3>
<ul>
<li>
<p><code>_cq_dialog</code> folder defines the component dialog:</p>
<ul>
<li>
<img src="https://s2.loli.net/2024/04/12/d2v5UMseGuFEKkl.png" alt="image-20240301134106075" style="zoom:30%;float:left" />
</li>
<li>
<p>The dialog pops up when clicking a component in the page editor for configuring component options.</p>
</li>
<li>
<p>①xml defines dialog structure including fields, labels, defaults etc. It follows JCR (Java Content Repository) to describe layout and functions.</p>
</li>
<li>
<pre class="highlight"><code class="xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>
<span class="tag">&lt;<span class="name">jcr:root</span> <span class="attr">xmlns:sling</span>=<span class="string">&quot;http://sling.apache.org/jcr/sling/1.0&quot;</span>
          <span class="attr">xmlns:cq</span>=<span class="string">&quot;http://www.day.com/jcr/cq/1.0&quot;</span>
          <span class="attr">xmlns:jcr</span>=<span class="string">&quot;http://www.jcp.org/jcr/1.0&quot;</span>
          <span class="attr">xmlns:nt</span>=<span class="string">&quot;http://www.jcp.org/jcr/nt/1.0&quot;</span>
          <span class="attr">jcr:primaryType</span>=<span class="string">&quot;nt:unstructured&quot;</span>
          <span class="attr">sling:resourceType</span>=<span class="string">&quot;cq/gui/components/authoring/dialog&quot;</span>
          <span class="attr">jcr:title</span>=<span class="string">&quot;...DIALOG TITLE&quot;</span>&gt;</span>
    <span class="tag">&lt;<span class="name">items</span> <span class="attr">jcr:primaryType</span>=<span class="string">&quot;nt:unstructured&quot;</span>&gt;</span>
        <span class="tag">&lt;<span class="name">tab1</span> <span class="attr">jcr:primaryType</span>=<span class="string">&quot;nt:unstructured&quot;</span>
              <span class="attr">sling:resourceType</span>=<span class="string">&quot;cq/gui/components/authoring/dialog/tabpanel&quot;</span>
              <span class="attr">jcr:title</span>=<span class="string">&quot;...TAB 1&quot;</span>&gt;</span>
            <span class="tag">&lt;<span class="name">items</span> <span class="attr">jcr:primaryType</span>=<span class="string">&quot;nt:unstructured&quot;</span>&gt;</span>
                <span class="tag">&lt;<span class="name">field1</span> <span class="attr">jcr:primaryType</span>=<span class="string">&quot;nt:unstructured&quot;</span>
                        <span class="attr">sling:resourceType</span>=<span class="string">&quot;granite/ui/components/foundation/form/textfield&quot;</span>
                        <span class="attr">fieldLabel</span>=<span class="string">&quot;...FIELD 1&quot;</span>
                        <span class="attr">name</span>=<span class="string">&quot;./field1&quot;</span>/&gt;</span>
                <span class="comment">&lt;!-- ...MORE FIELDS HERE --&gt;</span>
            <span class="tag">&lt;/<span class="name">items</span>&gt;</span>
        <span class="tag">&lt;/<span class="name">tab1</span>&gt;</span>
        <span class="comment">&lt;!-- ...MORE TABS HERE --&gt;</span>
    <span class="tag">&lt;/<span class="name">items</span>&gt;</span>
<span class="tag">&lt;/<span class="name">jcr:root</span>&gt;</span>
<span class="comment"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 🔦 Define Component</span><br><span class="line"></span><br><span class="line">- ② xml file:</span><br><span class="line"></span><br><span class="line">  - Defines AEM component metadata.</span><br><span class="line"></span><br><span class="line">  - ```xml</span><br><span class="line">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">    &lt;jcr:root xmlns:cq=&quot;http://www.day.com/jcr/cq/1.0&quot; xmlns:jcr=&quot;http://www.jcp.org/jcr/1.0&quot;</span><br><span class="line">        jcr:primaryType=&quot;cq:Component&quot;</span><br><span class="line">        jcr:title=&quot;CLP Eco Feed Vertical&quot; // Component title</span><br><span class="line">        componentGroup=&quot;CLP HK PostLogin - Develop&quot;/&gt; // Component group</span><br></pre></td></tr></table></figure></span>

</code></pre>
</li>
<li>
<img src="https://s2.loli.net/2024/04/12/RoS9EbPM3ujOIlt.png" alt="image-20240301140937620" style="zoom:40%;float:left" />
</li>
</ul>
</li>
</ul>
<h3 id="define-component-template"><a class="markdownIt-Anchor" href="#define-component-template"></a> 🔦 Define Component Template</h3>
<blockquote>
<p><a href="https://experienceleague.adobe.com/docs/experience-manager-htl/content/getting-started.html?lang=en">Reference</a></p>
</blockquote>
<p>The HTML file uses <strong>HTL</strong> (HTML Template Language) to render custom components in AEM pages (In this project, use Vue.js for joint development).</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sly</span> <span class="attr">data-sly-use.templates</span>=<span class="string">&quot;core/wcm/components/commons/v1/templates.html&quot;</span> <span class="attr">data-sly-set.hasContent</span>=<span class="string">&quot;$&#123;false&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- aquire modal data --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sly</span> <span class="attr">data-sly-use.clpecofeed</span>=<span class="string">&quot;com.clp.clphkpostlogin.core.models.CLPEcoFeed&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sly</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-dom</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- properties is defined by dialog data --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">VUE-COMPONENT</span> <span class="attr">props1</span>=<span class="string">&quot;$&#123;properties.modeltype&#125;&quot;</span> <span class="attr">props2</span>=<span class="string">&quot;$&#123;clpecofeed&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">VUE-COMPONENT</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- in Vue SFC, can get the properties from the `prop` --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sly</span> <span class="attr">data-sly-call</span>=<span class="string">&quot;$&#123;templates.placeholder @ isEmpty=!hasContent&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sly</span>&gt;</span></span><br></pre></td></tr></table></figure>
<br/>
<h2 id="uifrontend"><a class="markdownIt-Anchor" href="#uifrontend"></a> <code>ui.frontend</code></h2>
<blockquote>
<p><code>ui.frontend</code> is built with <strong>webpack</strong> + <strong>Vue</strong> in this project</p>
</blockquote>
<h3 id="write-sfc-single-file-component"><a class="markdownIt-Anchor" href="#write-sfc-single-file-component"></a> 🔦 Write SFC (Single File Component)</h3>
<ul>
<li>Write Vue components in <font color=red><u><strong><code>ui.frontend/src/main/webpack/vue/components</code></strong></u></font> (Please ensure to define <font color=blue><code>name</code> </font>attribute for reference in AEM).</li>
</ul>
<blockquote>
<p><code>componnents directory</code> structure</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- _register</span><br><span class="line">  - common # common components</span><br><span class="line">  - components aem components</span><br><span class="line">  - elementui elementui components</span><br><span class="line">- common</span><br><span class="line">- components match aem naming</span><br><span class="line">- utils common js libs</span><br><span class="line">- main.js entry</span><br></pre></td></tr></table></figure>
<p>Notes:</p>
<ol>
<li>Register needed Element UI components in <code>_register/elementui</code>.</li>
<li>Register new AEM components in <code>_register/components</code>.</li>
<li>AEM components can use registered Element UI and common components.</li>
</ol>
</blockquote>
<h3 id="register-components"><a class="markdownIt-Anchor" href="#register-components"></a> 🔦 Register Components</h3>
<ul>
<li>Export Vue components in <font color=red><u><strong><code>ui.frontend/src/main/webpack/vue/_register/component</code></strong></u></font> for <code>main.js</code> to import and mount with <code>createApp.component()</code>.</li>
</ul>
<br/>
<h2 id="preview-components"><a class="markdownIt-Anchor" href="#preview-components"></a> 💡 Preview Components</h2>
<blockquote>
<p>Please configre the component on AEM page before Preview Components</p>
</blockquote>
<h3 id="for-independent-components"><a class="markdownIt-Anchor" href="#for-independent-components"></a> For independent components</h3>
<blockquote>
<p>[!TIP]</p>
<p><strong>independent components</strong> refers to to a component that is developed and previewed <u>standalone</u>, without associations with other components. For example, no need to navigate to other components or pages.</p>
<p>No need to bundle the entire <code>ui.frontend</code>.</p>
</blockquote>
<ul>
<li>
<p>Mount defined component in <font color=red><u><strong><code>ui.frontend/src/main/webpack/templates/local.html</code></strong></u></font>:</p>
<ul>
<li>
<pre class="highlight"><code class="vue">&lt;div id=&quot;localApp&quot; class=&quot;dtt-uf dtt-uf-vc dtt-uf-dc&quot;&gt;
  &lt;div class=&quot;dtt-uf&quot;&gt;
    &lt;div data-dom&gt;
      &lt;CustomComponent /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p>Run <code>npm run local</code> and open browser to preview this component.</p>
<blockquote>
<p>“local”: “cross-env VUE_APP_MY_ENV=local webpack-dev-server --open --config ./webpack.local.js”</p>
</blockquote>
</li>
</ul>
<h3 id="for-associated-components"><a class="markdownIt-Anchor" href="#for-associated-components"></a> For associated components</h3>
<blockquote>
<p>[!TIP]</p>
<p>Need to bundle the <strong><em>entire</em></strong> <code>ui.frontend</code>.</p>
</blockquote>
<h4 id="option-1-maven-build"><a class="markdownIt-Anchor" href="#option-1-maven-build"></a> Option 1: Maven build</h4>
<p><u><strong>Universal but Time-Consuming Solutions</strong></u></p>
<ul>
<li>
<p>In project directoty, run <strong><code>mvn clean install -PautoInstallSinglePackage</code></strong>. Then preview in <strong>AEM system</strong>.</p>
<blockquote>
<p><strong>Production environment</strong></p>
<p>For debug logs during development:</p>
<p>​ Comment out Terser plugin in <code>webpack</code> prod config that removes <code>console.log</code>.</p>
<p>​ Or use <code>window.console.log</code>.</p>
</blockquote>
</li>
</ul>
<h4 id="option-2-aem-sync-plugin-in-vscode"><a class="markdownIt-Anchor" href="#option-2-aem-sync-plugin-in-vscode"></a> Option 2: AEM Sync plugin in VsCode</h4>
<ul>
<li>
<p>Install <code>AEM Sync</code> plugin in VsCode.</p>
</li>
<li>
<p>In <code>ui.frontend</code> directoty, run <code>npm run dev</code>. Plugin will sync build to AEM. Preview in launched server.</p>
<blockquote>
<p>“dev”: “webpack -d --env dev --config ./webpack.dev.js &amp;&amp; clientlib --verbose”</p>
</blockquote>
<blockquote>
<p><strong>Development environment</strong></p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>AEM</title>
    <url>/posts/AEM/</url>
    <content><![CDATA[<p>AEM - Adobe Experience Manager</p>
]]></content>
  </entry>
  <entry>
    <title>CSS只显示两行</title>
    <url>/posts/CSS%E5%8F%AA%E6%98%BE%E7%A4%BA%E4%B8%A4%E8%A1%8C/</url>
    <content><![CDATA[<p><strong><code>-webkit-line-clamp</code></strong> CSS 属性可以把<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Block">块容器</a>中的内容限制为指定的行数。</p>
<p>它只有在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 属性设置成 <code>-webkit-box</code> 或者 <code>-webkit-inline-box</code> 并且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-orient"><code>box-orient</code></a> 属性设置成 <code>vertical</code>时才有效果。</p>
<p>在大部分情况下，也需要设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 属性为 <code>hidden</code>，否则，里面的内容不会被裁减，并且在内容显示为指定行数后还会显示省略号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  display: -webkit-box;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  -webkit-line-clamp: 2;  /* 两行 */</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">   word-break: break-all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果<br />
<img src="https://s2.loli.net/2024/02/01/ljaoHIB9rkU4uXn.png" alt="css只展示两行png.png" /></p>
<p>💡 其中， <code>word-break</code> 指定了怎样在单词内断行， 这里 <code>break-all</code> 将单词截断换行，由于这里只能显示 2 行，所以出现图中效果</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie &amp; Session</title>
    <url>/posts/CookieSession/</url>
    <content><![CDATA[<p>HTTP无状态（<u>一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接</u>），引入<code>cookie</code> 、<code>session</code>维持和跟踪用户状态。</p>
<br />
<blockquote>
<p><code>Session</code></p>
<p>​	用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId</p>
<p>​	cookie每次请求都把SessionId自动带到服务器</p>
<p>​		当一个用户提交了表单时，浏览器会将用户的SessionId自动附加在HTTP头信息中，（这是浏览器的自动功能，用户不会察觉到），当服务器处理完这个表单后，将结果返回给SessionId所对应的用户。</p>
</blockquote>
<br />
<ul>
<li>
<h3 id="存储位置不同"><a class="markdownIt-Anchor" href="#存储位置不同"></a> 存储位置不同:</h3>
<ul>
<li>
<p>Cookie数据存放在客户的<strong>浏览器</strong>上</p>
</li>
<li>
<p>Session数据放在<strong>服务器</strong>上</p>
</li>
</ul>
</li>
<li>
<h3 id="安全性不同"><a class="markdownIt-Anchor" href="#安全性不同"></a> 安全性不同:</h3>
<ul>
<li>
<p>Cookie不是很安全,别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p>
</li>
<li>
<p>Session存放在服务器上,比较安全</p>
</li>
</ul>
</li>
<li>
<h3 id="大小限制不同"><a class="markdownIt-Anchor" href="#大小限制不同"></a> 大小限制不同:</h3>
<ul>
<li>Cookie大小有<strong>限制</strong>,最大<u>4K</u>左右</li>
</ul>
<ul>
<li>Session大小一般可设置<u>1M到几十M</u>,根据服务器的内存大小而定</li>
</ul>
</li>
<li>
<h3 id="有效期不同"><a class="markdownIt-Anchor" href="#有效期不同"></a> 有效期不同:</h3>
<ul>
<li>
<p>Cookie的有效期需要程序员<strong>自己设置</strong></p>
</li>
<li>
<p>Session的有效期默认到<strong>浏览器关闭</strong>时失效</p>
</li>
</ul>
</li>
<li>
<h3 id="作用范围不同"><a class="markdownIt-Anchor" href="#作用范围不同"></a> 作用范围不同:</h3>
<ul>
<li>Cookie被客户端记录,每次请求时都会携带,对于服务器请求数量多的情况下会增加请求数据量</li>
</ul>
<ul>
<li>Session只保存在服务器端,不会增加请求数据量</li>
</ul>
</li>
<li>
<h3 id="实现机制不同"><a class="markdownIt-Anchor" href="#实现机制不同"></a> 实现机制不同:</h3>
<ul>
<li>
<p>Cookie通过检查客户浏览器的cookie来确定客户身份</p>
</li>
<li>
<p>Session通过给客户浏览器分配一个<strong>特定的ID</strong>来识别客户身份。服务器通过匹配session ID来管理session</p>
</li>
</ul>
</li>
</ul>
<pre class="mermaid">graph TD
A[客户端发起请求] --> B{请求是否包含sessionId?}
B -- 包含 --> C[使用已存在的Session]
B -- 不包含 --> D[创建一个新的Session]
D --> E[生成一个唯一的sessionId]
D --> F[为Session分配资源]
E --> G[将sessionId返回给客户端]
G --> H[客户端保存sessionId]
C --> I[使用已存在的Session资源]
I --> J[处理请求]
J --> K[响应请求]
K --> L[结束]
F --> L[结束]</pre>
]]></content>
      <tags>
        <tag>Computer Network</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Create-React-App项目Template</title>
    <url>/posts/Create-React-App%E9%A1%B9%E7%9B%AETemplate/</url>
    <content><![CDATA[<p><a href="https://github.com/ye1223/CRA-template.git">💡项目地址</a><br />
<br /></p>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── .husky</span><br><span class="line">├── .vscode</span><br><span class="line">├── public</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.tsx</span><br><span class="line">│   ├── index.tsx</span><br><span class="line">│   └── react-app-env.d.ts</span><br><span class="line">├── prettier.config.js</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── package.json</span><br><span class="line">└── yarn.lock</span><br><span class="line">├── README.md</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="初始化项目"><a class="markdownIt-Anchor" href="#初始化项目"></a> 初始化项目</h3>
<p>​	<code>yarn add create-react-app [app-name] --template typescript</code></p>
<h3 id="prettier"><a class="markdownIt-Anchor" href="#prettier"></a> prettier</h3>
<p>​	<code>yarn add -D prettier</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//prettier.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">   <span class="attr">semi</span>: <span class="literal">false</span>, <span class="comment">// 在每条语句的末尾不使用分号</span></span><br><span class="line">   <span class="attr">trailingComma</span>: <span class="string">&#x27;es5&#x27;</span>, <span class="comment">// 允许在ES5中有效的尾随逗号</span></span><br><span class="line">   <span class="attr">singleQuote</span>: <span class="literal">true</span>, <span class="comment">// 使用单引号而不是双引号</span></span><br><span class="line">   <span class="attr">printWidth</span>: <span class="number">80</span>, <span class="comment">// 指定打印行的最大长度</span></span><br><span class="line">   <span class="attr">tabWidth</span>: <span class="number">3</span>, <span class="comment">// 设置每个缩进级别的空格数</span></span><br><span class="line">   <span class="attr">useTabs</span>: <span class="literal">false</span>, <span class="comment">// 使用空格而不是制表符进行缩进</span></span><br><span class="line">   <span class="attr">bracketSpacing</span>: <span class="literal">true</span>, <span class="comment">// 在对象字面量中添加空格</span></span><br><span class="line">   <span class="attr">jsxBracketSameLine</span>: <span class="literal">false</span>, <span class="comment">// 在JSX中把&#x27;&gt;&#x27;放在最后一行的末尾</span></span><br><span class="line">   <span class="attr">arrowParens</span>: <span class="string">&#x27;avoid&#x27;</span>, <span class="comment">// 当箭头函数只有一个参数时不使用圆括号</span></span><br><span class="line">   <span class="attr">endOfLine</span>: <span class="string">&#x27;lf&#x27;</span>, <span class="comment">// 行尾序列使用LF（\n）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="husky"><a class="markdownIt-Anchor" href="#husky"></a> <strong>husky</strong></h3>
<p>​	<code>yarn add -D husky</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;prettier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prettier --write \&quot;src/**/*.&#123;js,jsx,ts,tsx,json,css,scss,md&#125;\&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>​	<strong>启用 Git 钩子</strong>： <code>npx husky install</code></p>
<p>​	<strong>添加 pre-commit 钩子</strong>：<code>npx husky add .husky/pre-commit &quot;yarn prettier&quot;</code></p>
<h3 id="路径别名"><a class="markdownIt-Anchor" href="#路径别名"></a> 路径别名</h3>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// ...其他配置...</span></span><br><span class="line">  <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;*&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<br />
<strong> 静候补充... </strong>]]></content>
  </entry>
  <entry>
    <title>Event Loop</title>
    <url>/posts/EventLoop/</url>
    <content><![CDATA[<p>JS单线程，为了不阻塞线程，很多代码通过回调的方式异步执行</p>
<p>JS代码执行顺序被打乱，就需要一种机制–事件循环，协调各个事件的执行顺序</p>
<h3 id="浏览器"><a class="markdownIt-Anchor" href="#浏览器"></a> 浏览器</h3>
<ol>
<li>同步代码，一行一行在Call Stack中执行（压栈弹栈）</li>
<li>遇到异步代码，记录下代码，等时机到了将代码入队Callback Queue中</li>
<li>当同步代码执行为空，Call Stack为空，Event Loop开始工作</li>
<li>Event Loop轮询查找Callback Queue中是否有可执行代码
<ol>
<li>有，将代码送入Call Stack执行</li>
<li>没有，将继续轮询查找</li>
</ol>
</li>
</ol>
<p><font color=red>调用栈为空触发Event Loop执行先后顺序：微任务、DOM渲染、宏任务</font></p>
<p>微任务： Promise, async/await</p>
<p>宏任务： 定时器、Ajax、DOM事件</p>
<img src="https://s2.loli.net/2023/10/07/nFwAxKGfkaDUp8b.png" alt="浏览器事件循环" style="width:70%;" />
<h3 id="node"><a class="markdownIt-Anchor" href="#node"></a> Node</h3>
<p>Node异步API</p>
<table>
<thead>
<tr>
<th>定时器</th>
<th>I/O操作</th>
<th>node独有</th>
</tr>
</thead>
<tbody>
<tr>
<td>setTimeout<br />setInterval</td>
<td>文件读写<br />数据库操作<br />网络请求…</td>
<td>process.nextTick<br />setImmediate</td>
</tr>
</tbody>
</table>
<p>设计上，事件循环优先处理执行I/O事件</p>
<img src="https://s2.loli.net/2023/10/07/Y7yhcei5f86PaS4.png" alt="Node事件循环" style="width:70%;" />
<p>process.nextTick不属于事件循环一部分，优先于事件循环执行</p>
<p>从Timer到Check为一个Tick</p>
<blockquote>
<p><code>setImediate(()=&gt;&#123;&#125;)</code>、与<code>setTimeout(()=&gt;&#123;&#125;, 0)</code> 中执行时机不确定？</p>
<p>setTimeout(, 0) —&gt; <code>浏览器 4ms</code>,<code> node 1ms</code></p>
<p>解决： 将两者放在I/O操作回调中，能保证setImmediate回调先执行</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>FUNNY_ERROR</title>
    <url>/posts/FUNNY-ERROR/</url>
    <content><![CDATA[<h2 id="1-immediate-写错位置-哭晕"><a class="markdownIt-Anchor" href="#1-immediate-写错位置-哭晕"></a> 1、immediate 写错位置 哭晕</h2>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reCompolist = <span class="title function_">ref</span>([])</span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> props.<span class="property">list</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ;(reCompolist.<span class="property">value</span> <span class="keyword">as</span> <span class="built_in">any</span>) = props.<span class="property">list</span>.<span class="title function_">map</span>(</span><br><span class="line">      <span class="function">(<span class="params">row</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="attr">newRow</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt; = &#123;&#125;</span><br><span class="line">        props.<span class="property">labels</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, _]</span>) =&gt;</span> &#123;</span><br><span class="line">          newRow[key] = row[key]</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> newRow</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>GPTPlus速通</title>
    <url>/posts/GPTPlus%E9%80%9F%E9%80%9A/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JS类型转换</title>
    <url>/posts/JS%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>JS是动态类型语言，我们在定义一个变量其实并没有指定这个变量到底属于那种类型，只有到程序执行阶段才确定当前数据类型。</p>
<p>而<font color=red>各种<strong>运算符</strong>对数据类型是有要求的</font>，所以就会触发类型转换机制（no matter 人为 or 隐式触发）</p>
<h2 id="显示转换"><a class="markdownIt-Anchor" href="#显示转换"></a> 显示转换：</h2>
<p>​	通过JS内置的函数<strong>明确转换的数据类型</strong></p>
<ul>
<li>
<p>Number</p>
</li>
<li>
<p>parseInt(string, ?进制) 比Number宽松，一位一位解析遇到不能解析的停止</p>
</li>
<li>
<p>String</p>
</li>
<li>
<p>Boolean</p>
</li>
</ul>
<h2 id="隐式转换"><a class="markdownIt-Anchor" href="#隐式转换"></a> 隐式转换：</h2>
<p>​	运算操作符两边数据类型不一致（比较运算符、算术运算符）</p>
<ul>
<li>
<p>转为Boolean (需要布尔值的地方，借助的<code>Boolean()</code>函数)</p>
<ul>
<li>falsely变量：<code>undefined</code>、<code>null</code>、<code>false</code>、<code>+/-0</code>、<code>NAN</code>、<code>&quot;&quot;</code></li>
</ul>
</li>
<li>
<p>转为String （复合类型—&gt;原始类型----&gt;字符串）</p>
<ul>
<li>常发生在，如 <code>&quot;5&quot; + xxx</code> 的加法运算中</li>
</ul>
</li>
<li>
<p>转为Number</p>
<ul>
<li>除了加法运算符号，其他都有可能</li>
</ul>
</li>
</ul>
<h2 id="other"><a class="markdownIt-Anchor" href="#other"></a> other</h2>
<blockquote>
<p><code>=== </code>在不进行类型转换情况下，双方的类型与值都相等</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Preparation</tag>
      </tags>
  </entry>
  <entry>
    <title>RENEW-vue2</title>
    <url>/posts/RENEW-vue2/</url>
    <content><![CDATA[<h3 id="1-关于生命周期"><a class="markdownIt-Anchor" href="#1-关于生命周期"></a> 1. 关于生命周期</h3>
<h5 id="11-生命周期有哪些发送请求在created还是mounted"><a class="markdownIt-Anchor" href="#11-生命周期有哪些发送请求在created还是mounted"></a> 1.1 生命周期有哪些？发送请求在created还是mounted？</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求接口测试：https://fcm.52kfw.cn/index.php?_mall_id=1&amp;r=api/default/district</span><br></pre></td></tr></table></figure>
<p>Vue2.x系统自带有8个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">beforeMount</span><br><span class="line">mounted</span><br><span class="line">beforeUpdate</span><br><span class="line">updated // DOM 已经更新</span><br><span class="line">beforeDestroy // 实例还在，进行清理任务，比如清除计时器、解绑全局事件监听器</span><br><span class="line">destroyed </span><br></pre></td></tr></table></figure>
<p>发送请求在created还是mounted？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个问题具体要看项目和业务的情况了，因为组件的加载顺序是，父组件引入了子组件，那么先执行父的前3个生命周期，再执行子的前4个生命周期，那么如果我们的业务是父组件引入子组件，并且==优先加载子组件==的数据，那么在父组件中当前的请求要放=mounted=中，如果当前组件没有依赖关系那么放在哪个生命周期中请求都是可以的。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><mark>生命周期：先执行 父前三，在执行子元素前四</mark></p>
<p><mark>如果优先加载子组件的数据，就放在mounted中发送请求</mark> ，<mark>确保子组件优先挂载</mark></p>
</blockquote>
<h5 id="12-为什么发送请求不在beforecreate里beforecreate和created有什么区别"><a class="markdownIt-Anchor" href="#12-为什么发送请求不在beforecreate里beforecreate和created有什么区别"></a> 1.2 为什么发送请求不在beforeCreate里？beforeCreate和created有什么区别？</h5>
<p>为什么发送请求不在beforeCreate里？</p>
<blockquote>
<p><mark>拿不到methods方法（如果请求封装在methods中）</mark></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为：如果请求是在methods封装好了，在beforeCreate调用的时候，beforeCreate阶段是拿不到methods里面的方法的（会报错了）。</span><br></pre></td></tr></table></figure>
<p>beforeCreate和created有什么区别？</p>
<blockquote>
<p><mark>拿不拿得到$data与methods</mark></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeCreate没有$data</span><br><span class="line">created中有$data</span><br><span class="line"></span><br><span class="line">created是可以拿到methods的方法的</span><br><span class="line">beforeCreate拿不到methods的方法</span><br></pre></td></tr></table></figure>
<h5 id="13-在created中如何获取dom"><a class="markdownIt-Anchor" href="#13-在created中如何获取dom"></a> 1.3 在created中如何获取dom</h5>
<blockquote>
<p><mark>异步获取</mark></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 只要写异步代码，获取dom是在异步中获取的，就可以了。</span><br><span class="line">	例如：setTimeout、请求、Promise.xxx()等等...</span><br><span class="line">2. 使用vue系统内置的this.$nextTick</span><br></pre></td></tr></table></figure>
<h5 id="14-一旦font-colorred进入组件font会执行哪些生命周期"><a class="markdownIt-Anchor" href="#14-一旦font-colorred进入组件font会执行哪些生命周期"></a> 1.4 一旦<font color=red>进入组件</font>会执行哪些生命周期？</h5>
<blockquote>
<p>进入组件，组件已经<strong>挂载</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">beforeMount</span><br><span class="line">mounted</span><br></pre></td></tr></table></figure>
<h5 id="15-第二次或者第n次进去组件会执行哪些生命周期"><a class="markdownIt-Anchor" href="#15-第二次或者第n次进去组件会执行哪些生命周期"></a> 1.5 第二次或者第N次进去组件会执行哪些生命周期？</h5>
<blockquote>
<p><mark>看是否缓存了组件</mark></p>
</blockquote>
<p>如果当前组件加入了<strong>keep-alive</strong>，只会执行一个生命周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">activated</span><br></pre></td></tr></table></figure>
<p>如果没有加入keep-alive</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">beforeMount</span><br><span class="line">mounted</span><br></pre></td></tr></table></figure>
<h5 id="16-父组件引入子组件那么生命周期执行的顺序是"><a class="markdownIt-Anchor" href="#16-父组件引入子组件那么生命周期执行的顺序是"></a> 1.6 父组件引入子组件，那么生命周期执行的顺序是？</h5>
<blockquote>
<p><mark>父三 子四</mark></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父：beforeCreate、created、beforeMount</span><br><span class="line">子：beforeCreate、created、beforeMount、mounted</span><br><span class="line">...</span><br><span class="line">父：mounted</span><br></pre></td></tr></table></figure>
<h5 id="17-加入keep-alive会执行哪些生命周期"><a class="markdownIt-Anchor" href="#17-加入keep-alive会执行哪些生命周期"></a> 1.7 加入keep-alive会执行哪些生命周期？</h5>
<p>如果使用了keep-alive组件，当前的组件会额外增加2个生命周期（系统8 + 2 ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">activated</span><br><span class="line">deactivated</span><br></pre></td></tr></table></figure>
<p>如果当前组件加入了keep-alive第一次进入这个组件会执行5个生命周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">beforeMount</span><br><span class="line">mounted</span><br><span class="line">activated</span><br></pre></td></tr></table></figure>
<h5 id="18-你在什么情况下用过哪些生命周期说一说生命周期使用场景"><a class="markdownIt-Anchor" href="#18-你在什么情况下用过哪些生命周期说一说生命周期使用场景"></a> 1.8 你在什么情况下用过哪些生命周期？说一说生命周期使用场景</h5>
<blockquote>
<p>activated 中重新刷新数据 ， 因为使用了缓存组件，后续进入该组件只会运行这一个生命周期</p>
<p>deacticated 清理定时器相关的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created    ===&gt; 单组件请求</span><br><span class="line">mounted    ===&gt; 同步可以获取dom，如果先子组件请求后父组件请求</span><br><span class="line">activated  ===&gt; 判断id是否相等，如果不相同发起请求</span><br><span class="line">destroyed  ===&gt; 关闭页面记录视频播放的时间,初始化的时候从上一次的历史开始播放</span><br></pre></td></tr></table></figure>
<h3 id="2-关于组件"><a class="markdownIt-Anchor" href="#2-关于组件"></a> 2. 关于组件</h3>
<blockquote>
<p>父 -&gt; 子 <mark>props、<a href="http://this.$parent.xxx">this.$parent.xxx</a>(子元素可以直接修改父元素数据)、依赖注入（在配置主题颜色 react中的context上下文 provider）</mark></p>
<p>子 -&gt; 父 <mark>自定义事件emit、$refs</mark></p>
<p>兄弟元素： <mark>eventbus （发布订阅模式）</mark></p>
<p>集中状态管理 vuex pinia</p>
</blockquote>
<h5 id="21-组件传值通信的方式"><a class="markdownIt-Anchor" href="#21-组件传值通信的方式"></a> 2.1 组件传值（通信）的方式</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父传后代 ( 后代拿到了父的数据 )</span><br><span class="line">1. 父组件引入子组件，绑定数据</span><br><span class="line">	 &lt;List :str1=&#x27;str1&#x27;&gt;&lt;/List&gt;</span><br><span class="line">	子组件通过props来接收</span><br><span class="line">	props:&#123;</span><br><span class="line">		str1:&#123;</span><br><span class="line">			type:String,</span><br><span class="line">			default:&#x27;&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	***这种方式父传子很方便，但是父传给孙子辈分的组件就很麻烦（父=》子=》孙）</span><br><span class="line">	这种方式：子不能直接修改父组件的数据</span><br><span class="line"></span><br><span class="line">2. 子组件直接使用父组件的数据</span><br><span class="line">	子组件通过：this.$parent.xxx使用父组件的数据</span><br><span class="line">	这种方式：子可以直接修改父组件的数据</span><br><span class="line">	</span><br><span class="line">3. 依赖注入</span><br><span class="line">	优势：父组件可以直接向某个后代组件传值(不让一级一级的传递)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">后代传父 （父拿到了后代的数据）</span><br><span class="line">1. 子组件传值给父组件</span><br><span class="line">	子组件定义自定义事件 this.$emit</span><br><span class="line">2. 父组件直接拿到子组件的数据</span><br><span class="line">	&lt;List ref=&#x27;child&#x27;&gt;&lt;/List&gt;</span><br><span class="line">	this.$refs.child</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">平辈之间的传值 ( 兄弟可以拿到数据 ) </span><br><span class="line"></span><br><span class="line">通过新建bus.js文件来做</span><br></pre></td></tr></table></figure>
<h5 id="22-父组件如何直接修改子组件的值"><a class="markdownIt-Anchor" href="#22-父组件如何直接修改子组件的值"></a> 2.2 父组件如何直接修改子组件的值</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;List ref=&#x27;child&#x27;&gt;&lt;/List&gt;</span><br><span class="line">this.$refs.child.xxx = &#x27;yyyy&#x27;;</span><br></pre></td></tr></table></figure>
<h5 id="23-子组件如何直接修改父组件的值"><a class="markdownIt-Anchor" href="#23-子组件如何直接修改父组件的值"></a> 2.3 子组件如何直接修改父组件的值</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子组件中可以使用：this.$parent.xxx去修改</span><br></pre></td></tr></table></figure>
<h5 id="24-如何找到父组件"><a class="markdownIt-Anchor" href="#24-如何找到父组件"></a> 2.4 如何找到父组件</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$parent</span><br></pre></td></tr></table></figure>
<h5 id="25-如何找到根组件"><a class="markdownIt-Anchor" href="#25-如何找到根组件"></a> 2.5 如何找到根组件</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$root</span><br></pre></td></tr></table></figure>
<h5 id="26-keep-alive"><a class="markdownIt-Anchor" href="#26-keep-alive"></a> 2.6 keep-alive</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keep-alive是什么  ： 缓存当前组件</span><br></pre></td></tr></table></figure>
<h5 id="27-slot插槽"><a class="markdownIt-Anchor" href="#27-slot插槽"></a> 2.7 slot/插槽</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匿名插槽 ：插槽没有名字</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具名插槽 ：插槽有名字</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用域插槽 ： 传值</span><br></pre></td></tr></table></figure>
<h5 id="28-provideinject"><a class="markdownIt-Anchor" href="#28-provideinject"></a> 2.8 provide/inject</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">provide/inject ===&gt; 依赖注入</span><br></pre></td></tr></table></figure>
<h5 id="29-如何封装组件"><a class="markdownIt-Anchor" href="#29-如何封装组件"></a> 2.9 如何封装组件</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组件一定要难点，涉及的知识点：slot、组件通信...</span><br></pre></td></tr></table></figure>
<h3 id="3-关于vuex"><a class="markdownIt-Anchor" href="#3-关于vuex"></a> 3. 关于Vuex</h3>
<h5 id="31-vuex有哪些属性"><a class="markdownIt-Anchor" href="#31-vuex有哪些属性"></a> 3.1 Vuex有哪些属性</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">state ==&gt; 全局共享属性</span><br><span class="line">getters ==&gt; 针对于state数据进行二次计算</span><br><span class="line">mutatioins ==&gt; 存放同步方法的</span><br><span class="line">actions    ==&gt; 存放异步方法的，并且是来提交mutations</span><br><span class="line">modules    ==&gt; 把vuex再次进行模块之间的划分</span><br></pre></td></tr></table></figure>
<h5 id="32-vuex使用state值"><a class="markdownIt-Anchor" href="#32-vuex使用state值"></a> 3.2 Vuex使用state值</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$store.state.xxx</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">辅助函数：mapState</span><br></pre></td></tr></table></figure>
<p>以上俩种方式都可以拿到state的值，那么区别是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用this.$store.state.xxx是可以直接修改vuex的state数据的</span><br><span class="line"></span><br><span class="line">使用辅助函数的形式，是不可以修改的</span><br></pre></td></tr></table></figure>
<h5 id="33-vuex的getters值修改"><a class="markdownIt-Anchor" href="#33-vuex的getters值修改"></a> 3.3 Vuex的getters值修改</h5>
<p>面试官可能会这样问：组件使用了getters中的内容，组件使用采用v-model的形式会发生什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getters是不可以修改的</span><br></pre></td></tr></table></figure>
<h5 id="34-vuex的mutations和actions区别"><a class="markdownIt-Anchor" href="#34-vuex的mutations和actions区别"></a> 3.4 Vuex的mutations和actions区别</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相同点：mutations和actions都是来存放全局方法的，这个全局方法return的值拿不到</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">区别：</span><br><span class="line">	mutations ==》 同步</span><br><span class="line">	actions   ==》 返回的是一个Promise对象，他可以执行相关异步操作</span><br><span class="line">	</span><br><span class="line">mutations是来修改state的值的，actions的作用是来提交mutations</span><br></pre></td></tr></table></figure>
<h5 id="35-vuex持久化存储-在页面使用了state值1然后把1修改成2然后刷新页面又回到了1为什么"><a class="markdownIt-Anchor" href="#35-vuex持久化存储-在页面使用了state值1然后把1修改成2然后刷新页面又回到了1为什么"></a> 3.5 Vuex持久化存储  ：在页面使用了state值：1，然后把1修改成2，然后刷新页面又回到了1为什么？</h5>
<blockquote>
<p><mark>我用的pinia</mark></p>
<p><mark>state在LS，读取时getItem，修改时setItem</mark></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vuex本身不是持久化存储的数据。Vuex是一个状态管理仓库（state：全局属性）==》就是存放全局属性的地方。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现持久化存储：1. 自己写localStorage  2. 使用vuex-persistedstate插件</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插件使用方式：https://www.xuexiluxian.cn/blog/detail/dae4073b07144d3c9abb3e2cc8495922</span><br></pre></td></tr></table></figure>
<h3 id="4-关于路由"><a class="markdownIt-Anchor" href="#4-关于路由"></a> 4. 关于路由</h3>
<h5 id="41-路由的模式和区别"><a class="markdownIt-Anchor" href="#41-路由的模式和区别"></a> 4.1 路由的模式和区别</h5>
<blockquote>
<p>history 使用HTML5 的history API, <mark><strong><code>pushState(state, title, url)</code></strong></mark> <strong><code>popstate</code></strong> replacestate</p>
<p>hash检测浏览器url hash值 , <mark>浏览器并不会因为hash值的改变而作响应向服务器发送请求，而是有vuerouter控制客户端作相应的响应，利用onhashchange（window.location.hash）</mark>   同一页面内的不同位置标记</p>
</blockquote>
<blockquote>
<p><font color=red>hash</font></p>
<p><mark>服务器只需要返回入口页面（通常是 <code>index.html</code>）</mark>, 而后面一切都是由vuerouter在客户端渲染完成的</p>
<p><font color=red>history</font></p>
<p>需要在后端额外配置请求的uri地址</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路由的模式：history、hash</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">区别：</span><br><span class="line">1. 关于找不到当前页面发送请求的问题</span><br><span class="line">	history会给后端发送一次请求而hash不会</span><br><span class="line">2. 关于项目打包前端自测问题</span><br><span class="line">	hash是可以看到内容的</span><br><span class="line">	history默认情况是看不到内容的</span><br><span class="line">3. 关于表象不同</span><br><span class="line">	hash:#</span><br><span class="line">	history:/</span><br></pre></td></tr></table></figure>
<h5 id="42-子路由和动态路由"><a class="markdownIt-Anchor" href="#42-子路由和动态路由"></a> 4.2 子路由和动态路由</h5>
<blockquote>
<p>动态路由 /user/:id 占位</p>
</blockquote>
<h5 id="43-路由传值"><a class="markdownIt-Anchor" href="#43-路由传值"></a> 4.3 路由传值</h5>
<blockquote>
<p>query 和 params 两种</p>
</blockquote>
<h5 id="44-导航故障"><a class="markdownIt-Anchor" href="#44-导航故障"></a> 4.4 导航故障</h5>
<blockquote>
<p>可以catch捕获，isNavigationFailure 给出相关提示</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网说明：https://v3.router.vuejs.org/zh/guide/advanced/navigation-failures.html#%E6%A3%80%E6%B5%8B%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C</span><br></pre></td></tr></table></figure>
<p>解决：</p>
<blockquote>
<p>$router.push跳转到一个相同的路由报错</p>
<p>重写push方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">const routerPush = VueRouter.prototype.push</span><br><span class="line">VueRouter.prototype.push = function (location) &#123;</span><br><span class="line">  return routerPush.call(this, location).catch(error =&gt; error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="45-router和route区别"><a class="markdownIt-Anchor" href="#45-router和route区别"></a> 4.5 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext>和</mtext></mrow><annotation encoding="application/x-tex">router和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">和</span></span></span></span>route区别</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$router不仅包含当前路由还包含 ==整个路由的属性和方法==</span><br><span class="line"></span><br><span class="line">$route包含==当前==路由对象</span><br></pre></td></tr></table></figure>
<h5 id="46-导航守卫"><a class="markdownIt-Anchor" href="#46-导航守卫"></a> 4.6 导航守卫</h5>
<blockquote>
<p>beforeResolve</p>
<p>所有组件内守卫和异步路由组件被解析之后，而在导航被最终确认之前。</p>
<p>提供了一个<mark>最后的机会</mark>来取消或修改即将发生的路由跳转。 （权限</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 全局守卫</span><br><span class="line"></span><br><span class="line">	beforeEach 路由进入之前</span><br><span class="line">	afterEach 路由进入之后</span><br><span class="line"></span><br><span class="line">2. 路由独享守卫</span><br><span class="line">	</span><br><span class="line">	beforeEnter 路由进入之前</span><br><span class="line"></span><br><span class="line">3. 组件内守卫</span><br><span class="line"></span><br><span class="line">	beforeRouteEnter 路由进入之前</span><br><span class="line">	beforeRouteUpdate 路由更新之前</span><br><span class="line">	beforeRouteLeave 路由离开之前</span><br></pre></td></tr></table></figure>
<h3 id="5-关于api"><a class="markdownIt-Anchor" href="#5-关于api"></a> 5. 关于API</h3>
<h5 id="51-set"><a class="markdownIt-Anchor" href="#51-set"></a> 5.1 $set</h5>
<blockquote>
<p>给响应式对象添加新属性</p>
<p>响应式数组对象<strong>不能</strong>直接通过<strong>修改索引</strong>的方式修改数据 ， 利相关方法push pop shift unshift splice sort reverse，更改length</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面试官：你有没有碰到过，数据更新视图没有更新的问题==》$set</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$set(target,key,修改后的值)</span><br></pre></td></tr></table></figure>
<h5 id="52-nexttick"><a class="markdownIt-Anchor" href="#52-nexttick"></a> 5.2 $nextTick</h5>
<blockquote>
<p><mark>在写单元测试的时候使用过，因为要获取当前最新的DOM，返回promise</mark></p>
<p>数据更新导致视图变化，（给这个DOM添加动画</p>
<p>DOM是异步更新的，确保获取最新的DOM借助nexttick</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$nextTick返回的参数[函数]，是一个异步的。功能：==获取更新后的dom==</span><br><span class="line"></span><br><span class="line">源码|原理：</span><br><span class="line">$nextTick( callback )&#123;</span><br><span class="line">		return Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">			callback();</span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="53-refs"><a class="markdownIt-Anchor" href="#53-refs"></a> 5.3 $refs</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">来获取dom的</span><br></pre></td></tr></table></figure>
<h5 id="54-el"><a class="markdownIt-Anchor" href="#54-el"></a> 5.4 $el</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$el 获取当前组件的根节点</span><br></pre></td></tr></table></figure>
<h5 id="55-data"><a class="markdownIt-Anchor" href="#55-data"></a> 5.5 $data</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$data 获取当前组件data数据的</span><br></pre></td></tr></table></figure>
<h5 id="56-children"><a class="markdownIt-Anchor" href="#56-children"></a> 5.6 $children</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$children 获取到当前组件的所有子组件的</span><br></pre></td></tr></table></figure>
<h5 id="57-parent"><a class="markdownIt-Anchor" href="#57-parent"></a> 5.7 $parent</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到当前组件的父组件，如果找不到返回自身</span><br></pre></td></tr></table></figure>
<h5 id="58-root"><a class="markdownIt-Anchor" href="#58-root"></a> 5.8 $root</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到根组件</span><br></pre></td></tr></table></figure>
<h5 id="59-data定义数据"><a class="markdownIt-Anchor" href="#59-data定义数据"></a> 5.9 data定义数据</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据定义在data的return内和return外的区别：</span><br><span class="line"></span><br><span class="line">1. return外：单纯修改这个数据是不可以修改的，因为没有被get/set</span><br><span class="line">2. reutnr内：是可以修改的</span><br></pre></td></tr></table></figure>
<h5 id="510-computed计算属性"><a class="markdownIt-Anchor" href="#510-computed计算属性"></a> 5.10 computed计算属性</h5>
<blockquote>
<p>getter setter写法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed计算属性的结果值，可以修改吗？可以的，需要通过get/set写法</span><br><span class="line"></span><br><span class="line">当前组件v-model绑定的值是computed来的，那么可以修改吗？可以的，需要通过get/set写法</span><br></pre></td></tr></table></figure>
<h5 id="511-watch"><a class="markdownIt-Anchor" href="#511-watch"></a> 5.11 watch</h5>
<blockquote>
<p><mark>可以在其中执行<strong>异步</strong>方法，但是要注意trycatch捕获处理异常</mark></p>
<p><mark>在组件销毁时清理watch，返回一个销毁函数</mark></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">  obj:&#123;</span><br><span class="line">    handler(newVal,oldVal)&#123;</span><br><span class="line">      console.log( &#x27;obj&#x27;,newVal , oldVal )</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate:true,</span><br><span class="line">    deep:true</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="512-methods和computed区别"><a class="markdownIt-Anchor" href="#512-methods和computed区别"></a> 5.12 methods和computed区别</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed是有缓存机制的，methods是没有缓存机制的（调用几次执行几次）</span><br></pre></td></tr></table></figure>
<h3 id="6-关于指令"><a class="markdownIt-Anchor" href="#6-关于指令"></a> 6. 关于指令</h3>
<h5 id="61-如何自定义指令"><a class="markdownIt-Anchor" href="#61-如何自定义指令"></a> 6.1 如何自定义指令</h5>
<blockquote>
<p><mark>组件权限管理</mark></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局：</span><br><span class="line">Vue.directive(&#x27;demo&#x27;, &#123;</span><br><span class="line">  inserted: function (a,b,c) &#123;</span><br><span class="line">    console.log( a,b,c );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">局部：</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  directives: &#123;</span><br><span class="line">    demo: &#123;</span><br><span class="line">      bind: function (el) &#123;</span><br><span class="line">        console.log( 1 )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="62-vue单项绑定"><a class="markdownIt-Anchor" href="#62-vue单项绑定"></a> 6.2 vue单项绑定</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">双向绑定：v-model</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单项绑定：v-bind</span><br></pre></td></tr></table></figure>
<h5 id="63-v-if和v-for优先级"><a class="markdownIt-Anchor" href="#63-v-if和v-for优先级"></a> 6.3 v-if和v-for优先级</h5>
<blockquote>
<p><mark>同时作用在一个元素上，浪费性能，我们其实只想渲染出list其中符合条件的item，事实上我们却把每条item都遍历了一遍</mark></p>
<p><mark>所以我们应该在vfor之前过滤filter</mark></p>
</blockquote>
<blockquote>
<p>Vue2</p>
<p>​	利用computed重新生成数组</p>
<p>Vue3 虽说可以同时使用，但是，vif优先级高，可能不能及时获取到当前的item导致错误</p>
<p>​	借助vfor template标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">         &lt;li v-if=&quot;item.show&quot;&gt;</span><br><span class="line">           &#123;&#123; item.name &#125;&#125;</span><br><span class="line">         &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue2中：v-for &gt; v-if</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue3中：v-if &gt; v-for</span><br></pre></td></tr></table></figure>
<h3 id="7-关于原理"><a class="markdownIt-Anchor" href="#7-关于原理"></a> 7. 关于原理</h3>
<h5 id="71-nexttick原理"><a class="markdownIt-Anchor" href="#71-nexttick原理"></a> 7.1 $nextTick原理</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$nextTick功能：获取更新后的dom</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$nextTick( callback )&#123;</span><br><span class="line"></span><br><span class="line">		return Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">			callback();</span><br><span class="line">		&#125;)</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="72-双向绑定原理"><a class="markdownIt-Anchor" href="#72-双向绑定原理"></a> 7.2 双向绑定原理</h5>
<blockquote>
<p>双向绑定就是 数据与视图</p>
</blockquote>
<p>UI 控件的变化能自动更新数据模型</p>
<p>vmodel 语法糖，vbind绑定在监听@input or @change事件做出改变</p>
<h3 id="响应式"><a class="markdownIt-Anchor" href="#响应式"></a> 响应式</h3>
<p>数据劫持： 当对数据进行取值操作的时候，就会对这个数据进行依赖收集，当这个数据发生改变的时候，就会触发视图更新，刷新页面。</p>
<p>在get中进行<code>depend</code>依赖收集，在set中进行<code>notify</code>通知依赖的watcher去重新渲染（视图更新）</p>
<p><code>Object.defineProperty</code>这个api存在着一些问题，比如必须要<strong>深层次递归监听一个对象内所有的属性</strong>，性能并不太好，并且不能监听数组的<code>length</code>改变</p>
<p>数据代理 （复制一份）</p>
<p>​	Vue 在组件实例上通过 <code>this</code> 提供对组件数据的直接访问。这是通过将 <code>data</code> 对象中的属性代理到 Vue 实例上实现的。这样，你可以通过 <code>this.propertyName</code> 直接访问数据，而不是 <code>this.data.propertyName </code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(vm.<span class="property">$data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, key, &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> vm.<span class="property">$data</span>[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">        vm.<span class="property">$data</span>[key] = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>RENEW-汇总</title>
    <url>/posts/RENEW-%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="一-css"><a class="markdownIt-Anchor" href="#一-css"></a> 一、CSS</h2>
<h3 id="1说一下css的盒模型"><a class="markdownIt-Anchor" href="#1说一下css的盒模型"></a> 1.说一下CSS的盒模型。</h3>
<p>​        在HTML页面中的所有元素都可以看成是一个盒子<br />
​        盒子的组成：内容content、内边距padding、边框border、外边距margin<br />
​        盒模型的类型：<br />
​            标准盒模型<br />
​                margin + border + padding + content<br />
​            <mark>IE盒模型</mark><br />
​                margin + <mark>content(border + padding)</mark><br />
​        控制盒模型的模式：box-sizing:content-box（默认值，标准盒模型）、border-box（IE盒模型）;</p>
<h3 id="2css选择器的优先级"><a class="markdownIt-Anchor" href="#2css选择器的优先级"></a> 2.CSS选择器的优先级？</h3>
<p>​        CSS的特性：继承性、层叠性、优先级<br />
​        优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式<br />
​        标签、类/伪类/属性、全局选择器、行内样式、id、!important<br />
​       <mark>!important &gt; inline样式 &gt; id &gt; class/伪类/属性 &gt; 标签 &gt; 全局选择器</mark></p>
<h3 id="3隐藏元素的方法有哪些"><a class="markdownIt-Anchor" href="#3隐藏元素的方法有哪些"></a> 3.隐藏元素的方法有哪些？</h3>
<p>​        display:none;<br />
​            元素在页面上消失，不占据空间</p>
<p>​	html元素直接设置hidden</p>
<p>​        opacity:0;<br />
​            设置了元素的透明度为0，元素不可见，占据空间位置<br />
​        visibility:hidden;<br />
​            让元素消失，占据空间位置，一种不可见的状态<br />
​        position:absolute; clip-path: polygon(0 0, 0 0, 0 0, 0 0)将元素的可见部分裁剪掉<br />
​        position: absolute;    left: -9999px;</p>
<h3 id="4px和rem的区别是什么"><a class="markdownIt-Anchor" href="#4px和rem的区别是什么"></a> 4.px和rem的区别是什么？</h3>
<p>​        px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，<font color=red>绝对单位长度</font><br />
​        rem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%;<br />
​            1rem = 10px; （16px*62.5%=10px）</p>
<h3 id="5重绘重排有什么区别"><a class="markdownIt-Anchor" href="#5重绘重排有什么区别"></a> 5.重绘重排有什么区别？</h3>
<p>​        重排（回流Reflow）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小<br />
​        重绘 (Repaint)：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制<br />
​        浏览器的渲染机制<br />
​        对DOM的<u>大小、位置</u>进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排 (<mark>对元素几何属性修改获取</mark>)<br />
​        对DOM的样式进行修改，比如<u>color</u>和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘</p>
<h3 id="6让一个元素水平垂直居中的方式有哪些"><a class="markdownIt-Anchor" href="#6让一个元素水平垂直居中的方式有哪些"></a> 6.让一个元素水平垂直居中的方式有哪些？</h3>
<p>​        1.定位+margin<br />
​        2.定位+transform<br />
​        3.flex布局<br />
​        4.grid布局<br />
​        5.table布局</p>
<h3 id="7css的哪些属性哪些可以继承哪些不可以继承"><a class="markdownIt-Anchor" href="#7css的哪些属性哪些可以继承哪些不可以继承"></a> 7.CSS的哪些属性哪些可以继承？哪些不可以继承？</h3>
<p>​        CSS的三大特性：继承、层叠、优先级<br />
​        子元素可以继承父类元素的样式<br />
​        1.字体的一些属性：font<br />
​        2.文本的一些属性：line-height<br />
​        3.元素的可见性：visibility:hidden<br />
​        4.表格布局的属性：border-spacing<br />
​        5.列表的属性：list-style<br />
​        6.页面样式属性：page<br />
​        7.声音的样式属性</p>
<h3 id="8有没有用过预处理器"><a class="markdownIt-Anchor" href="#8有没有用过预处理器"></a> 8.有没有用过预处理器？</h3>
<p>​        预处理语言增加了变量、函数、混入（重用@include）等强大的功能<br />
​        SASS  LESS<br />
​        <mark>nesting写法、@extend样式继承、</mark></p>
<h2 id="二-javascript"><a class="markdownIt-Anchor" href="#二-javascript"></a> 二、JavaScript</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本数据类型：Null Undefined Boolean Number String Symbol Bigint（超过2^53 -1）</span><br><span class="line">引用数据类型（复杂数据类型）：Object Function Array</span><br></pre></td></tr></table></figure>
<h3 id="1js由哪三部分组成"><a class="markdownIt-Anchor" href="#1js由哪三部分组成"></a> 1.JS由哪三部分组成？</h3>
<p>​        ECMAScript：JS的核心内容，描述了语言的<strong>基础语法</strong>，比如var,for，数据类型（数组、字符串），<br />
​        文档对象模型（DOM）：DOM把整个HTML<strong>页面</strong>规划为元素构成的<strong>文档</strong><br />
​        浏览器对象模型（BOM）：对<strong>浏览器窗口</strong>进行访问和操作</p>
<h3 id="2js有哪些内置对象"><a class="markdownIt-Anchor" href="#2js有哪些内置对象"></a> 2.JS有哪些内置对象？</h3>
<p>​        String Boolean Number Array Object Function Math Date RegExp…<br />
​        Math<br />
​            abs() sqrt() max() min()<br />
​        Data<br />
​            new Data() getYear()<br />
​        Array<br />
​        String<br />
​            concat() length  slice() split()</p>
<h3 id="3操作数组的方法有哪些"><a class="markdownIt-Anchor" href="#3操作数组的方法有哪些"></a> 3.操作数组的方法有哪些？</h3>
<p>​        push() pop() sort() splice() unshift() shift() reverse() concat() join() map() filter()<br />
​        ervery() some() reduce() isArray() findIndex()<br />
​        哪些方法会改变原数组？<br />
​            push() pop() unshift() shift() sort() reverse() splice()</p>
<h3 id="4js对数据类的检测方式有哪些"><a class="markdownIt-Anchor" href="#4js对数据类的检测方式有哪些"></a> 4.JS对数据类的检测方式有哪些？</h3>
<p>​        typeof()<br />
​        instanceof()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceOf</span>(<span class="params">instance, constructor</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> objectProto = instance.<span class="property">__proto__</span></span><br><span class="line">  <span class="comment">// Object.getPrototypeOf</span></span><br><span class="line">  <span class="keyword">while</span>(objectProto !== <span class="literal">null</span> )&#123;</span><br><span class="line">    <span class="keyword">if</span>(objectProto.<span class="property">__proto__</span> == constructor.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    objectProto = objectProto.<span class="property">__proto__</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        constructor</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">([]).<span class="property">constructor</span>.<span class="property">name</span>;    <span class="comment">// &quot;Array&quot;</span></span><br></pre></td></tr></table></figure>
<p>​        Object.prototype.toString.call()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]);        <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;);        <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="5说一下闭包闭包有什么特点"><a class="markdownIt-Anchor" href="#5说一下闭包闭包有什么特点"></a> 5.说一下闭包，闭包有什么特点？</h3>
<p>​        什么是闭包？函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包<br />
​        特点：可以<mark>重复利用变量</mark>，并且这个变量不会污染全局的一种机制；这个变量是一直<strong>保存再内存</strong>中，不会被垃圾回收机制回收<br />
​        缺点：闭包较多的时候，会消耗内存，导致页面的性能下降，在IE浏览器中才会导致内存泄漏<br />
​        使用场景：<mark>防抖，节流，函数嵌套函数避免全局污染</mark>的时候</p>
<h3 id="6前端的内存泄漏怎么理解"><a class="markdownIt-Anchor" href="#6前端的内存泄漏怎么理解"></a> 6.前端的内存泄漏怎么理解？</h3>
<p>​        JS里已经分配内存地址的对象，但是由于长时间<mark>没有释放</mark>或者<strong>没办法清除</strong>，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致<u>运行速度慢</u>，甚至崩溃的情况。</p>
<p>​        <mark>回收机制</mark>（标记清除、引用计数）<br />
​        因素：一些未声明直接赋值的变量；一些未清空的定时器；过度的闭包；一些引用元素没有被清除。</p>
<h3 id="7事件委托是什么"><a class="markdownIt-Anchor" href="#7事件委托是什么"></a> 7.事件委托是什么？</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事件捕获 和 冒泡 阶段</span><br></pre></td></tr></table></figure>
<p>​        又叫事件代理，原理就是<strong>利用了事件冒泡的机制</strong>来实现，也就是说把<strong>子元素的事件绑定到了父元素的身上</strong><br />
​        如果子元素组织了事件冒泡，那么委托也就不成立<br />
​        组织事件冒泡：event.stopPropagation()<br />
​        addEventListener(‘click’,函数名，true/false) 默认是false（事件冒泡），true（事件捕获）<br />
​        好处：提高性能，<strong>减少事件的绑定</strong>，也就减少了内存的占用。</p>
<h3 id="8基本数据类型和引用数据类型的区别"><a class="markdownIt-Anchor" href="#8基本数据类型和引用数据类型的区别"></a> 8.基本数据类型和引用数据类型的区别？</h3>
<p>​        基本数据类型：String Number Boolean undefined null<br />
​            基本数据类型保存在栈内存当中，保存的就是一个具体的值<br />
​        引用数据类型（复杂数据类型）：Object Function Array<br />
​            保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址<br />
​            假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变</p>
<h3 id="9说一下原型链"><a class="markdownIt-Anchor" href="#9说一下原型链"></a> 9.说一下原型链。</h3>
<p>​        原型就是一个普通对象，它是为构造函数的实例共享属性和方法；所有实例中引用的原型都是同一个对象<br />
​        使用prototype可以把方法挂在原型上，内存值保存一份<br />
​        __proto__可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype）</p>
<h3 id="10new操作符具体做了什么"><a class="markdownIt-Anchor" href="#10new操作符具体做了什么"></a> 10.new操作符具体做了什么？</h3>
<p>​        1.先创建一个<strong>空对象</strong><br />
​        2.把空对象和构造函数通过<strong>原型</strong>链进行链接<br />
​        3.把构造函数的<strong>this绑定</strong>到新的空对象身上<br />
​        4.根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myNew = <span class="keyword">function</span>(<span class="params">constructor,...args</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  obj.<span class="property">__proto__</span> = constructor.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="keyword">const</span> res = constructor.<span class="title function_">apply</span>(obj,args)</span><br><span class="line"> <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? res : obj </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11js是如何实现继承的"><a class="markdownIt-Anchor" href="#11js是如何实现继承的"></a> 11.JS是如何实现继承的？</h3>
<p>​        1.原型链继承 //篡改父类原型链上的数据<br />
​	2.借用构造函数继承 //不能调用父类原型链上的方法<br />
​        3.组合式继承 // 父类被调用了两次，影响性能<br />
​        4.寄生组合继承<br />
​        5.ES6的class类继承</p>
<h3 id="12js的设计原理是什么"><a class="markdownIt-Anchor" href="#12js的设计原理是什么"></a> 12.JS的设计原理是什么？</h3>
<p>​        JS引擎 运行上下文 调用栈 事件循环 回调</p>
<h3 id="13js中关于this指向的问题"><a class="markdownIt-Anchor" href="#13js中关于this指向的问题"></a> 13.JS中关于this指向的问题</h3>
<ul>
<li>
<p>全局对象中的this指向<br />
指向的是window</p>
</li>
<li>
<p>全局作用域或者普通函数中的this<br />
指向全局window</p>
</li>
<li>
<p>this永远指向最后调用它的那个对象<br />
在不是箭头函数的情况下</p>
</li>
<li>
<p>new 关键词改变了this的指向</p>
</li>
<li>
<p>apply,call,bind<br />
可以改变this指向，不是箭头函数</p>
</li>
<li>
<p>箭头函数中的this<br />
它的指向在定义的时候就已经确定了<br />
箭头函数它没有this,看外层是否有函数，有就是外层函数的this，没有就是window</p>
</li>
<li>
<p>匿名函数中的this<br />
永远指向了window,匿名函数的执行环境具有全局性，因此this指向window</p>
</li>
</ul>
<h3 id="14-script标签里的async和defer有什么区别"><a class="markdownIt-Anchor" href="#14-script标签里的async和defer有什么区别"></a> 14. script标签里的async和defer有什么区别？</h3>
<p>​</p>
<pre><code>当没有async和defer这两个属性的时候，
  浏览器会立刻加载并执行指定的脚本
有async
  加载和渲染后面元素的过程将和script的加载和执行并行进行（异步）
有defer
  加载和渲染后面元素的过程将和script的加载并行进行（异步），但是它的执行事件要**等所有元素解析完成**之后才会执行
</code></pre>
<h3 id="15settimeout最小执行时间是多少"><a class="markdownIt-Anchor" href="#15settimeout最小执行时间是多少"></a> 15.setTimeout最小执行时间是多少？</h3>
<p>HTML5规定的内容：<br />
setTimeout最小执行时间是4ms<br />
setInterval最小执行时间是10ms</p>
<h3 id="16es6和es5有什么区别"><a class="markdownIt-Anchor" href="#16es6和es5有什么区别"></a> 16.ES6和ES5有什么区别？</h3>
<p>​	JS的组成：ECMAScript BOM  DOM<br />
​	ES5:ECMAScript5,2009年ECMAScript的第五次修订，ECMAScript2009<br />
​	ES6:ECMAScript6,2015年ECMAScript的第六次修订，ECMAScript2015，是JS的下一个版本标准</p>
<h3 id="17es6的新特性有哪些"><a class="markdownIt-Anchor" href="#17es6的新特性有哪些"></a> 17.ES6的新特性有哪些？</h3>
<p>​	1.新增<strong>块级作用域</strong>（let,const）<br />
​      	不存在变量提升<br />
​     	 存在暂时性死区的问题<br />
​      	块级作用域的内容<br />
​      	不能在同一个作用域内重复声明<br />
​	2.新增了定义类的语法糖（<strong>class</strong>）<br />
​	3.新增了一种基本数据类型（<strong>symbol</strong>）<br />
​	4.新增了<strong>解构赋值</strong><br />
​      	从数组或者对象中取值，然后给变量赋值<br />
​	5.新增了函数参数的默认值<br />
​	6.给数组新增了API<br />
​	7.对象和数组新增了<strong>扩展运算符</strong><br />
​	8.<strong>Promise</strong><br />
​     	 解决回调地狱的问题。<br />
​     	 自身有all,reject,resolve,race方法<br />
​      	原型上有then,catch<br />
​      	把异步操作队列化<br />
​      	三种状态：pending初始状态,fulfilled操作成功,rejected操作失败<br />
​      	状态：pending -&gt; fulfilled;pending -&gt; rejected 一旦发生，状态就会凝固，不会再变<br />
​      	<strong>async  await</strong>（<strong>ES7</strong>）<br />
​          	同步代码做异步的操作，两者必须搭配使用<br />
​          	async表明函数内有异步操作，调用函数会返回promise<br />
​          	await是组成async的表达式，结果是取决于它等待的内容，如果是promise那就是promise的结果，如果是普通函数就进行链式调用<br />
​          	await后的promise如果是reject状态，那么整个async函数都会<strong>中断</strong>，后面的代码不执行</p>
<p>​	9.新增了<strong>模块化</strong>（import,export）<br />
​	10.新增了set和map数据结构<br />
​    	set就是不重复<br />
​    	map的key的类型不受限制<br />
​	11.新增了<strong>generator</strong><br />
​	12.新增了<strong>箭头函数</strong><br />
​    	不能作为构造函数使用，不能用new<br />
箭头函数就没有原型<br />
箭头函数没有arguments<br />
​    	箭头函数不能用call,apply,bind去改变this的执行<br />
​    	this指向外层第一个函数的this</p>
<h3 id="18callaplybind三者有什么区别"><a class="markdownIt-Anchor" href="#18callaplybind三者有什么区别"></a> 18.call,aply,bind三者有什么区别？</h3>
<p>​        都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同<br />
​        call方法传的是一个参数列表<br />
​        apply传递的是一个数组<br />
​        bind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数还是可以传参的，bind()()<br />
​        call方法的性能要比apply好一些，所以call用的更多一点</p>
<h3 id="19用递归的时候有没有遇到什么问题"><a class="markdownIt-Anchor" href="#19用递归的时候有没有遇到什么问题"></a> 19.用递归的时候有没有遇到什么问题？</h3>
<p>​        如果一个函数内可以调用函数本身，那么这个就是递归函数<br />
​        函数内部调用自己<br />
​        特别注意：写递归必须要有<strong>退出条件return</strong></p>
<h3 id="20如何实现一个深拷贝"><a class="markdownIt-Anchor" href="#20如何实现一个深拷贝"></a> 20.如何实现一个深拷贝？</h3>
<p>​        深拷贝就是完全拷贝一份新的对象，会在堆内存中开辟新的空间，拷贝的对象被修改后，原对象不受影响<br />
​        主要针对的是引用数据类型<br />
​        1.扩展运算符<br />
​        2.JSON.parse(JSON.stringify())<br />
​        3.利用递归函数实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj ==<span class="literal">null</span>) <span class="keyword">return</span> obj</span><br><span class="line">         <span class="keyword">let</span> res = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;</span><br><span class="line">        <span class="comment">//  for in会遍历到obj原型链上的属性，增加判断，健壮性</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">                <span class="comment">// 嵌套的一层不会被克隆，所以再加一次深度克隆</span></span><br><span class="line">                res[key] = <span class="title function_">deepClone</span>(obj[key])</span><br><span class="line">            &#125;  </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<h3 id="21说一下事件循环"><a class="markdownIt-Anchor" href="#21说一下事件循环"></a> 21.说一下事件循环。</h3>
<p>​        JS是一个单线程的脚本语言<br />
​        主线程 执行栈 任务队列  宏任务 微任务<br />
​        主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务<br />
​        全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环！</p>
<h3 id="22ajax是什么怎么实现的"><a class="markdownIt-Anchor" href="#22ajax是什么怎么实现的"></a> 22.ajax是什么？怎么实现的？</h3>
<p>​        创建交互式网页应用的网页开发技术<br />
​            在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容<br />
​        通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面<br />
​        1.创建XmlHttpRequest对象 xmh<br />
​        2.通过xmh对象里的open()方法和服务器建立连接<br />
​        3.构建请求所需的数据，并通过xmh对象的send()发送给服务器<br />
​        4.通过xmh对象的onreadystatechange事件监听服务器和你的通信状态<br />
​        5.接收并处理服务器响应的数据结果<br />
​        6.把处理的数据更新到HTML页面上</p>
<h3 id="23get和post有什么区别"><a class="markdownIt-Anchor" href="#23get和post有什么区别"></a> 23.get和post有什么区别？</h3>
<p>​        1.get一般是获取数据，post一般是提交数据<br />
​        2.get参数会放在url上，所以安全性比较差，post是放在body中<br />
​        3.get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据<br />
​        4.get请求时会<strong>被缓存</strong>,post请求不会被缓存<br />
​        5.get请求会被保存在<strong>浏览器历史记录</strong>中,post不会<br />
​        6.get请求只能进行<strong>url编码</strong>，post请求支持很多种</p>
<h3 id="24promise的内部原理是什么它的优缺点是什么"><a class="markdownIt-Anchor" href="#24promise的内部原理是什么它的优缺点是什么"></a> 24.promise的内部原理是什么？它的优缺点是什么？</h3>
<p>​        Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果<br />
​        Promise主要就是解决回调地狱的问题，之前如果异步任务比较多，同时他们之间有相互依赖的关系，<br />
​        就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也很差<br />
​        有三种状态：pending初始状态  fulfilled成功状态  rejected失败状态<br />
​        状态改变只会有两种情况，<br />
​            pending -&gt; fulfilled; pending -&gt; rejected 一旦发生，状态就会凝固，不会再变<br />
​        首先就是我们无法取消promise，一旦创建它就会立即执行，不能中途取消<br />
​        如果不设置回调，promise内部抛出的测u哦呜就无法反馈到外面<br />
​        若当前处于pending状态时，无法得知目前在哪个阶段。<br />
​        原理：<br />
​            构造一个Promise实例，实例需要传递函数的参数，这个函数有两个形参，分别都是函数类型，一个是resolve一个是reject<br />
​            promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数，reject是执行第二个函数</p>
<h3 id="25promise和async-await的区别是什么"><a class="markdownIt-Anchor" href="#25promise和async-await的区别是什么"></a> 25.promise和async await的区别是什么？</h3>
<p>​        1.都是处理异步请求的方式<br />
​        2.promise是ES6，async await 是ES7的语法<br />
​        3.async await是基于promise实现的，他和promise都是非阻塞性的<br />
​        优缺点：<br />
​        1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过tra catch进行捕获异常<br />
​        2.async await最大的优点就是能<strong>让代码看起来像同步一样</strong>，只要遇到await就会立刻返回结果，然后再执行后面的操作<br />
​        promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作</p>
<h3 id="26浏览器的存储方式有哪些"><a class="markdownIt-Anchor" href="#26浏览器的存储方式有哪些"></a> 26.浏览器的存储方式有哪些？</h3>
<p>​        1.cookies<br />
​            H5标准前的本地存储方式<br />
​            兼容性好，请求头自带cookie<br />
​            存储量小，资源浪费，使用麻烦（封装）<br />
​        2.localstorage 10MB<br />
​            H5加入的以键值对为标准的方式<br />
​            操作方便，永久存储，兼容性较好<br />
​            保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫<br />
​        3.sessionstorage<br />
​            当前页面关闭后就会立刻清理，会话级别的存储方式<br />
​        4.indexedDB 指定配额<br />
​            H5标准的存储方式，，他是以键值对进行存储，可以快速读取，适合WEB场景</p>
<h3 id="27token存在sessionstorage还是loaclstorage"><a class="markdownIt-Anchor" href="#27token存在sessionstorage还是loaclstorage"></a> 27.token存在sessionstorage还是loaclstorage？</h3>
<p>​        token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串<br />
​        1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台<br />
​        2.存cookie中，会自动发送，缺点就是<strong>不能跨域</strong><br />
​        如果存在localstorage中，容易被XSS（跨站脚本）攻击，但是如果做好了对应的措施，那么是利大于弊<br />
​        如果存在cookie中会有CSRF（跨站请求伪造，利用浏览器会自动携带cookie）攻击</p>
<h3 id="28token的登录流程"><a class="markdownIt-Anchor" href="#28token的登录流程"></a> 28.token的登录流程。</h3>
<p>​        1.客户端用账号密码请求登录<br />
​        2.服务端收到请求后，需要去<strong>验证</strong>账号密码<br />
​        3.验证成功之后，服务端会签发一个token，把这个token发送给客户端<br />
​        4.客户端收到token后保存起来，可以放在cookie也可以是localstorage<br />
​        5.客户端每次向服务端发送请求资源的时候，都需要携带这个token<br />
​        6.服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据</p>
<h3 id="29页面渲染的过程是怎样的"><a class="markdownIt-Anchor" href="#29页面渲染的过程是怎样的"></a> 29.页面渲染的过程是怎样的？</h3>
<p>​        DNS解析<br />
​        建立TCP连接<br />
​        发送HTTP请求<br />
​        服务器处理请求<br />
​        渲染页面<br />
​            浏览器会获取HTML和CSS的资源，然后把HTML解析成DOM树<br />
​            再把CSS解析成CSSOM<br />
​            把DOM和CSSOM合并为渲染树<br />
​            布局<br />
​            把渲染树的每个节点渲染到屏幕上（绘制）<br />
​        断开TCP连接</p>
<h3 id="30dom树和渲染树有什么区别"><a class="markdownIt-Anchor" href="#30dom树和渲染树有什么区别"></a> 30.DOM树和渲染树有什么区别？</h3>
<p>​        DOM树是和HTML标签一一对应的，包括head和隐藏元素<br />
​        渲染树是不包含head和隐藏元素</p>
<h3 id="31精灵图和base64的区别是什么"><a class="markdownIt-Anchor" href="#31精灵图和base64的区别是什么"></a> 31.精灵图和base64的区别是什么？</h3>
<p>​        精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度<br />
​        base64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串<br />
​        base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载。</p>
<h3 id="32svg格式了解多少"><a class="markdownIt-Anchor" href="#32svg格式了解多少"></a> 32.svg格式了解多少？</h3>
<p>​        基于<strong>XML语法格式的图像格式</strong>，可缩放矢量图，其他图像是基于像素的，SVG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真<br />
​        1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作</p>
<p>​		<code>&lt;svg&gt;&lt;/svg&gt;</code></p>
<p>​        2.SVG可作为文件被引入<br />
​            <code>&lt;img src=&quot;pic.svg&quot; /&gt;</code>	<br />
​        3.SVG可以转为base64引入页面</p>
<h3 id="33了解过jwt吗"><a class="markdownIt-Anchor" href="#33了解过jwt吗"></a> 33.了解过JWT吗？</h3>
<p>​        JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输<br />
​        信息传输、授权<br />
​        JWT的认证流程<br />
​        	1.前端把账号密码发送给后端的接口<br />
​       	 2.后端核对账号密码成功后，把用户id等其他信息作为<strong>JWT 负载</strong>，把它和头部分别进行<strong>base64编码拼接后签名</strong>，形成一个JWT（token）。<br />
​        	3.前端每日请求时都会把JWT放在HTTP请求头的<strong>Authorization</strong>字段内<br />
​        	4.后端检查是否存在，如果存在就<strong>验证JWT</strong>的有效性（签名是否正确，token是否过期）<br />
​        	5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果<br />
​        简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。</p>
<h3 id="34npm的底层环境是什么"><a class="markdownIt-Anchor" href="#34npm的底层环境是什么"></a> 34.npm的底层环境是什么？</h3>
<p>​        node package manager,node的包管理和分发工具，已经成为分发node模块的标准，是JS的运行环境<br />
​        npm的组成：网站、注册表、命令行工具</p>
<h3 id="35http协议规定的协议头和请求头有什么"><a class="markdownIt-Anchor" href="#35http协议规定的协议头和请求头有什么"></a> 35.HTTP协议规定的协议头和请求头有什么？</h3>
<p>​        1.请求头信息：<br />
​            Accept:浏览器告诉服务器所支持的数据类型<br />
​            Host:浏览器告诉服务器我想访问服务器的哪台主机<br />
​            Referer:浏览器告诉服务器我是从哪里来的（防盗链）<br />
​            User-Agent:浏览器类型、版本信息<br />
​            Date:浏览器告诉服务器我是什么时候访问的<br />
​            Connection:连接方式<br />
​            Cookie<br />
​            X-Request-With:请求方式<br />
​        2.响应头信息：<br />
​            Location:这个就是告诉浏览器你要去找谁<br />
​            Server:告诉浏览器服务器的类型<br />
​            Content-Type:告诉浏览器返回的数据类型<br />
​            Refresh:控制了的定时刷新</p>
<h3 id="36说一下浏览器的缓存策略"><a class="markdownIt-Anchor" href="#36说一下浏览器的缓存策略"></a> 36.说一下浏览器的缓存策略。</h3>
<p>​        强缓存（本地缓存）、协商缓存（弱缓存）<br />
​        强缓：不发起请求，直接使用缓存里的内容，浏览器把JS，CSS，image等存到内存中，下次用户访问直接从内存中取，提高性能<br />
​        协缓：需要像后台发请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回<strong>304</strong>，浏览器就用缓存里的内容<br />
​        强缓存的触发：<br />
​            HTTP1.0:时间戳响应标头<br />
​            HTTP1.1:Cache-Control响应标头<br />
​        协商缓存触发：<br />
​            HTTP1.0:请求头：if-modified-since 响应头：last-modified<br />
​            HTTP1.1:请求头：if-none-match 响应头：Etag</p>
<h3 id="37说一下什么是同源策略"><a class="markdownIt-Anchor" href="#37说一下什么是同源策略"></a> 37.说一下什么是“同源策略”？</h3>
<p>​        http:// www.  <a href="http://aaa.com:8080/index/vue.js">aaa.com:8080/index/vue.js</a><br />
​        协议    子域名 主域名  端口号     资源<br />
​        同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击<br />
​        主要指的就是<mark>协议+域名+端口号</mark>三者一致，若其中一个不一样则不是同源，会产生跨域<br />
​        三个允许跨域加载资源的标签：<mark>img  link  script</mark><br />
​        跨域是可以发送请求，后端也会正常返回结果，只不过这个<strong>结果被浏览器拦截</strong>了！<br />
​        	JSONP <code>利用script标签跨域，动态创建script标签, script.src='xxxx?callback=handleResponse'</code><br />
​        	CORS<br />
​        	websocket<br />
​        	反向代理</p>
<h3 id="38防抖和节流是什么"><a class="markdownIt-Anchor" href="#38防抖和节流是什么"></a> 38.防抖和节流是什么？</h3>
<p>​        都是应对页面中频繁触发事件的优化方案<br />
​        防抖:避免事件重复触发<br />
​        	使用场景:1.频繁和服务端交互 2.输入框的自动保存事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">           	timer =  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">            &#125;,<span class="number">500</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​        节流:把频繁触发的事件减少,每隔一段时间执行<br />
​        	使用场景:scroll事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timer) <span class="keyword">return</span></span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, <span class="number">500</span>)    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/scrip</span><br></pre></td></tr></table></figure>
<h3 id="39解释一下什么是json"><a class="markdownIt-Anchor" href="#39解释一下什么是json"></a> 39.解释一下什么是json？</h3>
<p>​        JSON是一种<strong>纯字符串形式的数据</strong>，它本身不提供任何方法，适合在网络中进行传输<br />
​        JSON数据存储在.json文件中，也可以把JSON数据以字符串的形式保存在数据库、Cookise中<br />
​        JS提供了JSON.parse() JSON.stringify()<br />
​        什么时候使用json：定义接口；序列化；生成token；配置文件package.json</p>
<h3 id="40当数据没有请求过来的时候该怎么做"><a class="markdownIt-Anchor" href="#40当数据没有请求过来的时候该怎么做"></a> 40.当数据没有请求过来的时候，该怎么做？</h3>
<p>​        可以在渲染数据的地方给一些默认的值<br />
​        if判断语句</p>
<h3 id="41有没有做过无感登录"><a class="markdownIt-Anchor" href="#41有没有做过无感登录"></a> 41.有没有做过无感登录？</h3>
<p>​        1.在相应其中拦截，判断token返回过期后，调用刷新token的接口<br />
​        2.后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口<br />
​        3.写定时器，<strong>定时刷新</strong>token接口<br />
​        流程：<br />
​            1.登录成功后保存token 和 refresh_token<br />
​            2.在响应拦截器中对401状态码（<code>access token</code> 过期）引入刷新token的api方法调用<br />
​            3.替换保存本地新的token<br />
​            4.把错误对象里的token替换<br />
​            5.再次发送未完成的请求<br />
​            6.如果refresh_token过期了，判断是否过期，过期了就清楚所有token重新登录</p>
<h3 id="42大文件上传是怎么做的"><a class="markdownIt-Anchor" href="#42大文件上传是怎么做的"></a> 42.大文件上传是怎么做的？</h3>
<p>​        分片上传：<br />
​            1.把需要上传的文件按照一定的规则，分割成相同大小的数据块<br />
​            2.初始化一个分片上传任务，返回本次分片上传的唯一标识<br />
​            3.按照一定的规则把各个数据块上传<br />
​            4.发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件<br />
​        断点续传：<br />
​            服务端返回，从哪里开始  浏览器自己处理</p>
<h2 id="三-html5css3"><a class="markdownIt-Anchor" href="#三-html5css3"></a> 三、HTML5CSS3</h2>
<h3 id="1语义化的理解"><a class="markdownIt-Anchor" href="#1语义化的理解"></a> 1.语义化的理解。</h3>
<p>​        在写HTML页面结构时所用的标签有意义<br />
​        头部用head  主体用main  底部用foot…<br />
​        怎么判断页面是否语义化了？<br />
​            把CSS去掉，如果能够清晰的看出来页面结构，显示内容较为正常<br />
​        为什么要选择语义化？<br />
​            1.让HTML结构更加清晰明了<br />
​            2.方便团队协作，利于开发<br />
​            3.有利于爬虫和SEO<br />
​            4.能够让浏览器更好的去解析代码<br />
​            5.给用户带来良好的体验</p>
<h3 id="2h5c3有哪些新特性"><a class="markdownIt-Anchor" href="#2h5c3有哪些新特性"></a> 2.H5C3有哪些新特性？</h3>
<p>​        H5的新特性：<br />
​            1.语义化的标签<br />
​            2.新增音频视频<br />
​            3.画布canvas<br />
​            4.数据存储localstorage sessionstorage<br />
​            5.增加了表单控件 email url search…<br />
​            6.拖拽释放API<br />
​        CSS3的新特性：<br />
​            1.新增选择器：属性选择器、伪类选择器、伪元素选择器<br />
​            2.增加了媒体查询<br />
​            3.文字阴影<br />
​            4.边框<br />
​            5.盒子模型box-sizing<br />
​            6.渐变<br />
​            7.过度<br />
​            8.自定义动画<br />
​            9.背景的属性<br />
​            10.2D和3D</p>
<h3 id="3rem是如何做适配的"><a class="markdownIt-Anchor" href="#3rem是如何做适配的"></a> 3.rem是如何做适配的？</h3>
<p>​        rem是相对长度，相对于根元素（html）的font-size属性来计算大小，通常来做移动端的适配<br />
​        rem是根据根元素font-size计算值的倍数<br />
​        比如html上的font-size:16px，给div设置宽为1.5rem,1.2rem = 16px*1.2 = 19.2px.</p>
<h3 id="4解决了哪些移动端的兼容问题"><a class="markdownIt-Anchor" href="#4解决了哪些移动端的兼容问题"></a> 4.解决了哪些移动端的兼容问题？</h3>
<p>​        1.当设置样式overflow:scroll/auto时，IOS上的滑动会卡顿<br />
​            -webkit-overflow-scrolling:touch;<br />
​        2.在安卓环境下placeholder文字设置行高时会偏上<br />
​            input有placeholder属性的时候不要设置行高<br />
​        3.移动端字体小于12px时异常显示<br />
​            应该先把在整体放大一倍，然后再用transform进行缩小<br />
​        4.ios下input按钮设置了disabled属性为true显示异常<br />
​            input[typy=button]{<br />
​                opcity:1<br />
​            }<br />
​        5.安卓手机下取消语音输入按钮<br />
​            input::-webkit-input-speech-button{<br />
​                display:none<br />
​            }<br />
​        6.IOS下取消input输入框在输入引文首字母默认大写<br />
​            <input autocapitalize='off' autocorrect='off'/><br />
​        7.禁用IOS和安卓用户选中文字<br />
​            添加全局CSS样式：-webkit-user-select:none<br />
​        8.禁止IOS弹出各种窗口<br />
​            -webkit-touch-callout:none<br />
​        9.禁止IOS识别长串数字为电话<br />
​            添加meta属性 <meta conten='telephone=no' name='format-detection'></p>
<h2 id="四-vue"><a class="markdownIt-Anchor" href="#四-vue"></a> 四、Vue</h2>
<h3 id="1v-if和v-show的区别"><a class="markdownIt-Anchor" href="#1v-if和v-show的区别"></a> 1.v-if和v-show的区别？</h3>
<p>​        都可以控制元素的显示和隐藏<br />
​        1.v-show时控制元素的display值来让元素显示和隐藏；v-if显示隐藏时把DOM元素整个添加和删除<br />
​        2.v-if有一个<strong>局部编译/卸载</strong>的过程，切换这个过程中会适当的销毁和重建内部的事件监听和子组件；v-show只是简单的css切换<br />
​        3.v-if才是真正的条件渲染；v-show从false变成true的时候不会触发组件的声明周期，v-if会触发声明周期<br />
​        4.v-if的切换效率比较低  v-show的效率比较高</p>
<h3 id="2如何理解mvvm的"><a class="markdownIt-Anchor" href="#2如何理解mvvm的"></a> 2.如何理解MVVM的？</h3>
<p>是Model-View-ViewModel的缩写。前端开发的架构模式<br />
​        M：模型，对应的就是data的数据<br />
​        V：视图，用户界面，DOM<br />
​        VM：视图模型：Vue的实例对象，连接View和Model的桥梁<br />
​        核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定<br />
​        ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为她是由MVVM统一管理</p>
<h3 id="3v-for中的key值的作用是什么"><a class="markdownIt-Anchor" href="#3v-for中的key值的作用是什么"></a> 3.v-for中的key值的作用是什么？</h3>
<p>​        key属性是DOM元素的唯一标识<br />
​        作用：<br />
​            1.提高虚拟DOM的更新<br />
​            2.若不设置key，可能会触发一些bug<br />
​            3.为了触发过度效果</p>
<h3 id="4说一下你对vue生命周期的理解"><a class="markdownIt-Anchor" href="#4说一下你对vue生命周期的理解"></a> 4.说一下你对vue生命周期的理解。</h3>
<p>​        组件从创建到销毁的过程就是它的生命周期<br />
​        创建<br />
​            beforeCreat<br />
​                在这个阶段属性和方法都不能使用<br />
​            created<br />
​                这里时实例创建完成之后，在这里完成了数据监测，可以使用数据，修改数据，不会触发updated，也不会更新视图<br />
​        挂载<br />
​            beforeMount<br />
​                完成了模板的编译，虚拟DOM也完成创建，即将渲染，修改数据，不会触发updated<br />
​            Mounted<br />
​                把编译好的模板挂载到页面，这里可以发送异步请求也可以访问DOM节点<br />
​        更新<br />
​            beforeUpdate<br />
​                组件数据更新之前使用，数据是新的，页面上的数据时旧的，组件即将更新，准备渲染，可以改数据<br />
​            updated<br />
​                render重新做了渲染，这时数据和页面都是新的，避免在此更新数据<br />
​        销毁<br />
​            beforeDestroy<br />
​                实例销毁前，在这里实例还可以用，可以清楚定时器等等<br />
​            destroyed<br />
​                组件已经被销毁了，全部都销毁<br />
​        使用了keep-alive时多出两个周期：<br />
​            activited<br />
​                组件激活时<br />
​            deactivited<br />
​                组件被销毁时</p>
<h3 id="5在created和mounted去请求数据有什么区别"><a class="markdownIt-Anchor" href="#5在created和mounted去请求数据有什么区别"></a> 5.在created和mounted去请求数据，有什么区别？</h3>
<p>​        created：在渲染前调用，通常先初始化属性，然后做渲染<br />
​        mounted：在模板渲染完成后，一般都是初始化页面后，在对元素节点进行操作<br />
​                在这里请求数据可能会出现闪屏的问题，created里不会<br />
​        一般用created比较多<br />
​        请求的数据对DOM有影响，那么使用created<br />
​        如果请求的数据对DOM无关，可以放在mounted</p>
<h3 id="6vue中的修饰符有哪些"><a class="markdownIt-Anchor" href="#6vue中的修饰符有哪些"></a> 6.vue中的修饰符有哪些？</h3>
<p>​        1.事件修饰符<br />
​            .stop       组织冒泡<br />
​            .prevent    组织默认行为<br />
​            .capture    内部元素触发的事件先在次处理<br />
​            .self       只有在event.target是当前元素时触发<br />
​            .once       事件只会触发一次<br />
​            .passive    立即触发默认行为<br />
​            .native     把当前元素作为原生标签看待<br />
​        2.按键修饰符<br />
​            .keyup      键盘抬起<br />
​            .keydown    键盘按下<br />
​        3.系统修饰符<br />
​            .ctrl<br />
​            .alt<br />
​            .meta<br />
​        4.鼠标修饰符<br />
​            .left       鼠标左键<br />
​            .right      鼠标右键<br />
​            .middle     鼠标中键<br />
​        5.表单修饰符<br />
​            .lazy       等输入完之后再显示<br />
​            .trim       删除内容前后的空格<br />
​            .number     输入是数字或转为数字</p>
<h3 id="7elementui是怎么做表单验证的"><a class="markdownIt-Anchor" href="#7elementui是怎么做表单验证的"></a> 7.elementui是怎么做表单验证的？</h3>
<p>​        1.在表单中加rules属性，然后再data里写校验规则<br />
​        2.内部添加规则<br />
​        3.自定义函数校验</p>
<h3 id="8vue如何进行组件通信"><a class="markdownIt-Anchor" href="#8vue如何进行组件通信"></a> 8.vue如何进行组件通信？</h3>
<p>​        1.父传子<br />
​            props<br />
​                父组件使用自定义属性，然后子组件使用props<br />
​            <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>f</mi><mtext>​引用信息会注册在父组件的</mtext></mrow><annotation encoding="application/x-tex">ref
​                引用信息会注册在父组件的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">​</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">注</span><span class="mord cjk_fallback">册</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span></span></span></span>refs对象上<br />
​        2.子传父<br />
​            <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mtext>​子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数​</mtext><mn>3.</mn><mtext>兄弟传​</mtext><mi>n</mi><mi>e</mi><mi>w</mi><mtext>一个新的</mtext><mi>v</mi><mi>u</mi><mi>e</mi><mtext>实例，用</mtext><mi>o</mi><mi>n</mi><mtext>和</mtext><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mtext>来对数据进行传输​</mtext><mn>4.</mn><mi>v</mi><mi>u</mi><mi>e</mi><mi>x</mi><mtext>传值​</mtext><mn>9.</mn><mi>k</mi><mi>e</mi><mi>e</mi><mi>p</mi><mo>−</mo><mi>a</mi><mi>l</mi><mi>i</mi><mi>v</mi><mi>e</mi><mtext>是什么？怎么使用？​</mtext><mi>V</mi><mi>u</mi><mi>e</mi><mtext>的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们​作用：把组件切换的状态保存在内存里，防止重复渲染</mtext><mi>D</mi><mi>O</mi><mi>M</mi><mtext>节点，减少加载时间和性能消耗，提高用户体验​</mtext><mn>10.</mn><mi>a</mi><mi>x</mi><mi>i</mi><mi>o</mi><mi>s</mi><mtext>是怎么做封装的？​下载创建实例接着封装请求响应拦截器抛出最后封装接口​</mtext><mn>11.</mn><mi>v</mi><mi>u</mi><mi>e</mi><mtext>路由时怎么传参的？​</mtext><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mtext>传参​</mtext><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">emit
​                子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数
​        3.兄弟传
​            new一个新的vue实例，用on和emit来对数据进行传输
​        4.vuex传值
​    9.keep-alive是什么？怎么使用？
​        Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们
​        作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验
​    10.axios是怎么做封装的？
​        下载 创建实例 接着封装请求响应拦截器  抛出 最后封装接口
​    11.vue路由时怎么传参的？
​        params传参
​            this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord">​</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">绑</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">义</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">触</span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">给</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">监</span><span class="mord cjk_fallback">听</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord">​</span><span class="mord">3</span><span class="mord">.</span><span class="mord cjk_fallback">兄</span><span class="mord cjk_fallback">弟</span><span class="mord cjk_fallback">传</span><span class="mord">​</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">用</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">和</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">输</span><span class="mord">​</span><span class="mord">4</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">值</span><span class="mord">​</span><span class="mord">9</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">什</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">？</span><span class="mord cjk_fallback">怎</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">？</span><span class="mord">​</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">裹</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">候</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">缓</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">活</span><span class="mord cjk_fallback">跃</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">销</span><span class="mord cjk_fallback">毁</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">们</span><span class="mord">​</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">把</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">切</span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">态</span><span class="mord cjk_fallback">保</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">防</span><span class="mord cjk_fallback">止</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">渲</span><span class="mord cjk_fallback">染</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">减</span><span class="mord cjk_fallback">少</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">载</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">和</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">耗</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">提</span><span class="mord cjk_fallback">高</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">体</span><span class="mord cjk_fallback">验</span><span class="mord">​</span><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">怎</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">做</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">？</span><span class="mord">​</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">载</span><span class="mord cjk_fallback">创</span><span class="mord cjk_fallback">建</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">着</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">请</span><span class="mord cjk_fallback">求</span><span class="mord cjk_fallback">响</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">拦</span><span class="mord cjk_fallback">截</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">抛</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">口</span><span class="mord">​</span><span class="mord">1</span><span class="mord">1</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">怎</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">？</span><span class="mord">​</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">参</span><span class="mord">​</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span>router.push({name:‘index’,params:{id:item.id}})<br />
​            this.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mtext>​路由属性传参​</mtext><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">route.params.id
​        路由属性传参
​            this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord">​</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">属</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">参</span><span class="mord">​</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span>router.push({name:'/index/<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 11: {item.id}&#039;}̲)
​            …'>{item.id}&#039;})
​            路由配置 { path:&#039;/index:id&#039; }
​        query传参（可以解决页面刷新参数丢失的问题）
​            this.</span>router.push({<br />
​                name:‘index’,<br />
​                query:{id:item.id}<br />
​            })</p>
<h3 id="12vue路由的hash模式和history模式有什么区别"><a class="markdownIt-Anchor" href="#12vue路由的hash模式和history模式有什么区别"></a> 12.vue路由的hash模式和history模式有什么区别？</h3>
<p>​        1.hash的路由地址上有#号，history模式没有<br />
​        2.在做回车刷新的时候，hash模式会加载对应页面，history会报错404<br />
​        3.hash模式支持低版本浏览器，history不支持，因为是H5新增的API<br />
​        4.hash不会重新加载页面，单页面应用必备<br />
​        5.history有历史记录，H5新增了pushState和replaceState()去修改历史记录，并不会立刻发送请求<br />
​        6.history需要后台配置</p>
<h3 id="13路由拦截是怎么实现的"><a class="markdownIt-Anchor" href="#13路由拦截是怎么实现的"></a> 13.路由拦截是怎么实现的？</h3>
<p>​        路由拦截 axios拦截<br />
​        需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">           	<span class="attr">name</span>:<span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">​           <span class="attr">path</span>:<span class="string">&#x27;/index&#x27;</span>,</span><br><span class="line">​           <span class="attr">component</span>:<span class="title class_">Index</span>,</span><br><span class="line">​           <span class="attr">meta</span>:&#123;</span><br><span class="line">​                <span class="attr">requirtAuth</span>:<span class="literal">true</span></span><br><span class="line">​            &#125;</span><br><span class="line">​        &#125;</span><br><span class="line">​        router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span> &#123;</span><br><span class="line">​            <span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">requirtAuth</span>)&#123;</span><br><span class="line">​                <span class="keyword">if</span>( store.<span class="property">satte</span>.<span class="property">token</span> )&#123;</span><br><span class="line">​                    <span class="title function_">next</span>()</span><br><span class="line">​                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">​                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="14说一下vue的动态路由"><a class="markdownIt-Anchor" href="#14说一下vue的动态路由"></a> 14.说一下vue的动态路由。</h3>
<p>​        要在路由配置里设置meat属性，扩展权限相关的字段，在路由导航守卫里通过判断这个权限标识，实现路由的动态增加和跳转<br />
​        根据用户登录的账号，返回用户角色<br />
​        前端再根据角色，跟路由表的meta.role进行匹配<br />
​        把匹配搭配的路由形成可访问的路由</p>
<h3 id="15如何解决刷新后二次加载路由"><a class="markdownIt-Anchor" href="#15如何解决刷新后二次加载路由"></a> 15.如何解决刷新后二次加载路由？</h3>
<p>​        1.window.location.reload()<br />
​        2.matcher<br />
​            const router = createRouter()<br />
​            export function resetRouter(){<br />
​                const newRouter = creatRouter()<br />
​                router.matcher = newRouter.matcher<br />
​            }</p>
<h3 id="16vuex刷新数据会丢失吗怎么解决"><a class="markdownIt-Anchor" href="#16vuex刷新数据会丢失吗怎么解决"></a> 16.vuex刷新数据会丢失吗？怎么解决？</h3>
<p>​        vuex肯定会重新获取数据，页面也会丢失数据<br />
​        1.把数据直接保存在浏览器缓存里（cookie  localstorage  sessionstorage）<br />
​        2.页面刷新的时候，再次请求数据，达到可以动态更新的方法<br />
​            监听浏览器的刷新书简，在刷新前把数据保存到sessionstorage里，刷新后请求数据，请求到了用vuex，如果没有那就用sessionstorage里的数据</p>
<h3 id="17computed和watch的区别"><a class="markdownIt-Anchor" href="#17computed和watch的区别"></a> 17.computed和watch的区别？</h3>
<p>​        1.computed是计算属性，watch是监听，监听的是data中数据的变化<br />
​        2.computed是支持缓存，依赖的属性值发生变化，计算属性才会重新计算，否则用缓存；watch不支持缓存<br />
​        3.computed不支持异步，watch是可以异步操作<br />
​        4.computed是第一次加载就监听，watch是不监听<br />
​        5.computed函数中必须有return  watch不用</p>
<h3 id="18vuex在什么场景会去使用属性有哪些"><a class="markdownIt-Anchor" href="#18vuex在什么场景会去使用属性有哪些"></a> 18.vuex在什么场景会去使用？属性有哪些？</h3>
<p>​        state       存储变量<br />
​        getters     state的计算属性<br />
​        mutations   提交更新数据的方法<br />
​        actions     和mutations差不多，他是提交mutations来修改数据，可以包括异步操作<br />
​        modules     模块化vuex<br />
​        使用场景：<br />
​            用户的个人信息、购物车模块、订单模块</p>
<h3 id="19vue的双向数据绑定原理是什么"><a class="markdownIt-Anchor" href="#19vue的双向数据绑定原理是什么"></a> 19.vue的双向数据绑定原理是什么？</h3>
<p>​        通过数据劫持和发布订阅者模式来实现，同时利用Object.defineProperty()劫持各个属性的setter和getter，<br />
​        在数据发生改变的时候发布消息给订阅者，触发对应的监听回调渲染视图，也就是说数据和视图时同步的，数据发生改变，视图跟着发生改变，视图改变，数据也会发生改变。<br />
​        第一步：需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter<br />
​        第二步：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图<br />
​        第三步：Watcher订阅者是Observer和Compile之间的通信桥梁，作用：<br />
​                1.在自身实例化的时候忘订阅器内添加自己<br />
​                2.自身要有一个update()方法<br />
​                3.等待属性变动时，调用自身的update方法，触发compile这种的回调<br />
​        第四步：MVVM作为数据绑定的入口，整合了observer、compile和watcher三者，通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher把observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果</p>
<h3 id="20了解diff算法和虚拟dom吗"><a class="markdownIt-Anchor" href="#20了解diff算法和虚拟dom吗"></a> 20.了解diff算法和虚拟DOM吗？</h3>
<p>​        虚拟DOM，描述元素和元素之间的关系，创建一个JS对象<br />
​        如果组件内有响应的数据，数据发生改变的时候，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的虚拟DOM内容，然后去对应的真实DOM中修改<br />
​        diff算法就是虚拟DOM的比对时用的，返回一个patch对象，这个对象的作用就是存储两个节点不同的地方，最后用patch里记录的信息进行更新真实DOM<br />
​        步骤：<br />
​            1.JS对象表示真实的DOM结构，要生成一个虚拟DOM，再用虚拟DOM构建一个真实DOM树，渲染到页面<br />
​            2.状态改变生成新的虚拟DOM，跟就得虚拟DOM进行比对，这个比对的过程就是DIFF算法，利用patch记录差异<br />
​            3.把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了。</p>
<h3 id="21vue和jquery的区别是什么"><a class="markdownIt-Anchor" href="#21vue和jquery的区别是什么"></a> 21.vue和jquery的区别是什么？</h3>
<p>​        1.原理不同<br />
​            vue就是数据绑定；jq是先获取dom再处理<br />
​        2.着重点不同<br />
​            vue是数据驱动，jq是着重于页面<br />
​        3.操作不同<br />
​        4.未来发展不同</p>
<h3 id="22vuex的响应式处理"><a class="markdownIt-Anchor" href="#22vuex的响应式处理"></a> 22.vuex的响应式处理。</h3>
<p>​        vuex是vue的状态管理工具<br />
​        vue中可以直接触发methods中的方法，vuex是不可以的。未来处理异步，当触发事件的时候，会通过dispatch来访问actions中的方法，actions中的commit会触发mutations中的方法从而修改state里的值，通过getter把数据更新到视图<br />
​        Vue.use(vuex)，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store就可以访问到store对象。<br />
​        vuex的state是响应式的，借助的就是vue的data，把state存到vue实例组件的data中</p>
<h3 id="23vue中遍历全局的方法有哪些"><a class="markdownIt-Anchor" href="#23vue中遍历全局的方法有哪些"></a> 23.vue中遍历全局的方法有哪些？</h3>
<p>​        1.普通遍历，对象.forEach()<br />
​            arr.forEach(function(item,index,arr){<br />
​                console.log(item,index)<br />
​            })<br />
​        2.对元素统一操作  对象.map()<br />
​            var newarr = arr.map(function(item){<br />
​                return item+1<br />
​            })<br />
​        3.查找符合条件的元素 对象.filter()<br />
​            arr.filter(function(item){<br />
​                if(item &gt; 2){<br />
​                    return false<br />
​                }else{<br />
​                    return true<br />
​                }<br />
​            })<br />
​        4.查询符合条件的元素，返回索引 对象.findindex()<br />
​            arr.finindex(function(item){<br />
​                if(item&gt;1){<br />
​                    return true<br />
​                }else{<br />
​                    return false<br />
​                }<br />
​            })<br />
​        对象.evening()  遇到不符合的对象会停止<br />
​        对象.some()  找到符合条件的元素就停止</p>
<h3 id="24如何搭建脚手架"><a class="markdownIt-Anchor" href="#24如何搭建脚手架"></a> 24.如何搭建脚手架？</h3>
<p>​        下载：node  cnpm  webpack vue-cli<br />
​        创建项目：<br />
​            1.找到对应的文件，然后利用node指令创建（cmd）<br />
​            2.vue init webpack xxxx<br />
​            3.回车项目描述<br />
​            4.作者回车<br />
​            5.选择vue build<br />
​            6.回车<br />
​            7.输入n<br />
​            8.不按照yarn<br />
​            9.输入npm run dev</p>
<h3 id="25如何封装一个组件"><a class="markdownIt-Anchor" href="#25如何封装一个组件"></a> 25.如何封装一个组件？</h3>
<p>​        1.使用Vue.extend()创建一个组件<br />
​        2.使用Vue.components()方法注册组件<br />
​        3.如果子组件需要数据，可以在props中接收定义<br />
​        4.子组件修改好数据，要把数据传递给父组件，可以用emit()方法<br />
​        原则：<br />
​            把功能拆开<br />
​            尽量让组件原子化，一个组件做一件事情<br />
​            容器组件管数据，展示组件管视图</p>
<h3 id="26封装一个可复用的组件需要满足什么条件"><a class="markdownIt-Anchor" href="#26封装一个可复用的组件需要满足什么条件"></a> 26.封装一个可复用的组件，需要满足什么条件？</h3>
<p>​        1.低耦合，组件之间的依赖越小越好<br />
​        2.最好从父级传入信息，不要在公共组件中请求数据<br />
​        3.传入的数据要进行校验<br />
​        4.处理事件的方法写在父组件中</p>
<h3 id="27vue的过滤器怎么使用"><a class="markdownIt-Anchor" href="#27vue的过滤器怎么使用"></a> 27.vue的过滤器怎么使用？</h3>
<p>​        vue的特性，用来对文本进行格式化处理<br />
​        使用它的两个地方，一个是插值表达式，一个是v-bind<br />
​        分类：<br />
​            1.全局过滤器<br />
​                Vue.filter(‘add’,function(v){<br />
​                    return v &lt; 10 ? ‘0’ + v : v<br />
​                })</p>
<pre><code>            &lt;div&gt;&#123;&#123;33 | add&#125;&#125;&lt;/div&gt;
</code></pre>
<p>​            2.本地过滤器<br />
​                和methods同级<br />
​                filter:{<br />
​                    add:function(v){<br />
​                        return v &lt; 10 ? ‘0’ + v : v<br />
​                    }<br />
​                }</p>
<h3 id="28vue中如何做强制刷新"><a class="markdownIt-Anchor" href="#28vue中如何做强制刷新"></a> 28.vue中如何做强制刷新？</h3>
<p>​        1.localtion.reload()<br />
​        2.this.$router.go(0)<br />
​        3.provide和inject</p>
<h3 id="29vue3和vue2有哪些区别"><a class="markdownIt-Anchor" href="#29vue3和vue2有哪些区别"></a> 29.vue3和vue2有哪些区别？</h3>
<p>​        1.双向数据绑定的原理不同<br />
​        2.是否支持碎片<br />
​        3.API不同<br />
​        4.定义数据变量方法不同<br />
​        5.生命周期的不同<br />
​        6.传值不同<br />
​        7.指令和插槽不同<br />
​        8.main.js不同</p>
<h3 id="30vue的性能优化怎么做"><a class="markdownIt-Anchor" href="#30vue的性能优化怎么做"></a> 30.vue的性能优化怎么做？</h3>
<p>​        1.编码优化<br />
​            不要把所有数据都放在data中<br />
​            v-for时给每个元素绑定事件用事件代理<br />
​            keep-alive缓存组件<br />
​            尽可能拆分组件，提高复用性、维护性<br />
​            key值要保证唯一<br />
​            合理使用路由懒加载，异步组件<br />
​            数据持久化存储的使用尽量用防抖、节流优化<br />
​        2.加载优化<br />
​            按需加载<br />
​            内容懒加载<br />
​            图片懒加载<br />
​        3.用户体验<br />
​            骨架屏<br />
​        4.SEO优化<br />
​            预渲染<br />
​            服务端渲染ssr<br />
​        5.打包优化<br />
​            CDN形式加载第三方模块<br />
​            多线程打包<br />
​            抽离公共文件<br />
​        6.缓存和压缩<br />
​            客户端缓存、服务端缓存<br />
​            服务端Gzip压缩</p>
<h3 id="31首屏优化该如何去做"><a class="markdownIt-Anchor" href="#31首屏优化该如何去做"></a> 31.首屏优化该如何去做？</h3>
<p>​        1.使用路由懒加载<br />
​        2.非首屏组件使用异步组件<br />
​        3.首屏不中要的组件延迟加载<br />
​        4.静态资源放在CDN上<br />
​        5.减少首屏上JS、CSS等资源文件的大小<br />
​        6.使用服务端渲染<br />
​        7.简历减少DOM的数量和层级<br />
​        8.使用精灵图请求<br />
​        9.做一些loading<br />
​        10.开启Gzip压缩<br />
​        11.图片懒加载</p>
<h3 id="32vue3的性能为什么比vue2好"><a class="markdownIt-Anchor" href="#32vue3的性能为什么比vue2好"></a> 32.vue3的性能为什么比vue2好？</h3>
<p>​        1.diff算法的优化<br />
​        2.静态提升<br />
​        3.事件侦听缓存</p>
<h3 id="33vue3为什么使用proxy"><a class="markdownIt-Anchor" href="#33vue3为什么使用proxy"></a> 33.vue3为什么使用proxy？</h3>
<p>​        1.proxy可以代理整个对象，defineproperty只代理对象上的某个属性<br />
​        2.proxy对代理对象的监听更加丰富<br />
​        3.proxy代理对象会生成新的对象，不会修改被代理对象本身<br />
​        4.proxy补兼容ie浏览器</p>
<h3 id="34说一下你对组件的理解"><a class="markdownIt-Anchor" href="#34说一下你对组件的理解"></a> 34.说一下你对组件的理解。</h3>
<p>​        可以重复使用的vue实例，独一无二的组件名称<br />
​        可以抽离单独的公共模块<br />
​        提高代码的复用率</p>
<h3 id="35你是如何规划项目文件的"><a class="markdownIt-Anchor" href="#35你是如何规划项目文件的"></a> 35.你是如何规划项目文件的？</h3>
<p>​        public<br />
​            图标、index.html、img<br />
​        src<br />
​            api<br />
​            assets<br />
​            components<br />
​                按分类再次划分子目录<br />
​            plugins<br />
​            router<br />
​            static<br />
​            styles<br />
​            utils<br />
​            views<br />
​        App.vue<br />
​        main.js<br />
​        package.json<br />
​        vue.config.js</p>
<h3 id="36是否使用过nuxtjs"><a class="markdownIt-Anchor" href="#36是否使用过nuxtjs"></a> 36.是否使用过nuxt.js？</h3>
<p>​        是基于vue的应用框架，关注的是渲染，可以开发服务端渲染应用的配置<br />
​        SSR：服务端渲染<br />
​            好处：<br />
​                SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索<br />
​                优化了首屏加载时间<br />
​        SEO：优化搜索引擎<br />
​        SPA的应用不利于搜索引擎SEO的操作</p>
<h3 id="37seo如何优化"><a class="markdownIt-Anchor" href="#37seo如何优化"></a> 37.SEO如何优化？</h3>
<p>​        1.SSR<br />
​        2.预渲染 prerender-spa-plugin</p>
<h2 id="五-echarts"><a class="markdownIt-Anchor" href="#五-echarts"></a> 五、Echarts</h2>
<p>​    1.echarts有用过吗？常用的组件有哪些？<br />
​        title标题组件 show  text  link<br />
​        toolbox工具栏 导出图片 数据视图 切换 缩放 show orient feature<br />
​        tooltip tigger 触发类型<br />
​        markPoint标注点<br />
​        markLine图标的标线</p>
<h2 id="六-uni-app"><a class="markdownIt-Anchor" href="#六-uni-app"></a> 六、Uni-APP</h2>
<p>​    1.uni-app有没有做过分包？<br />
​        优化小程序的下载和启动速度<br />
​        小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示</p>
<h2 id="七-weabpack"><a class="markdownIt-Anchor" href="#七-weabpack"></a> 七、Weabpack</h2>
<p>​    1.webpack打包和不打包的区别？<br />
​        1.运行效率<br />
​        2.对基础的支持不够<br />
​    2.webpack是怎么打包的，babel是做什么的？<br />
​        webpack会把js css image看作一个模块，用import/require引入<br />
​        找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起<br />
​        把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件<br />
​        如果一个被多个文件引用，打包时只会生成一个文件<br />
​        如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包<br />
​        对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中</p>
<h2 id="八-git"><a class="markdownIt-Anchor" href="#八-git"></a> 八、Git</h2>
<p>​    1.git如何合并、拉取代码？<br />
​        拉取代码 git pull ‘仓库地址’<br />
​        查看状态 git status<br />
​        提交到本地缓存区  git add .<br />
​        提交本地仓库 git commit -m ‘修改描述’<br />
​        提交到远程仓库 git push ‘仓库地址’ master<br />
​        创建分支 git branch -b xxx<br />
​        合并分支 git merge ‘合并分支的名字’<br />
​    2.git如何解决冲突问题？<br />
​        1.两个分支中修改了同一个文件<br />
​        2.两个分支中修改了同一个文件的名字<br />
​        1.解决：当前分支上，直接修改代码  add  commit<br />
​        2.解决：在本地当前分支上，修改冲突代码 add commit push</p>
]]></content>
  </entry>
  <entry>
    <title>SUMMARY</title>
    <url>/posts/SUMMARY/</url>
    <content><![CDATA[<h2 id="01-数据类型"><a class="markdownIt-Anchor" href="#01-数据类型"></a> 01 数据类型</h2>
<p>基本数据类型：</p>
<ul>
<li>Null
<ul>
<li><code>typeof null 等于 object</code></li>
</ul>
</li>
<li>Undefined
<ul>
<li>Let var 声明未初始化值为 undefined</li>
</ul>
</li>
<li>Boolean
<ul>
<li>falsely=== <code>null undefined 0 '' NaN </code></li>
</ul>
</li>
<li>Number
<ul>
<li>10 进制 <code>1</code></li>
<li>8 进制 0 开头 <code>070</code></li>
<li>16 进制 0x 开头 <code>0x1</code></li>
<li>浮点数 包含小数点 <code>1.1</code> <code>1.0</code> <code>.1</code> <code>3.14e10</code> 科学计数法</li>
<li>NaN 不是数值 <code>Object.is(NaN,NaN) 返回true</code></li>
</ul>
</li>
<li>String</li>
<li>Symbol</li>
</ul>
<p>（栈）值类型：String 、Number、 Boolean、 Symbol</p>
<p>（堆）引用类型：object{}、 Array、 <strong>null</strong>、function</p>
<h2 id="02-数组方法"><a class="markdownIt-Anchor" href="#02-数组方法"></a> 02 数组方法</h2>
<p>splice <code>增(return [])</code> <code> 删return删除数组</code> <code>改return[]</code> 不影响原数组</p>
<p>splice(initIndex, deleteNum, InsertElement) 返回数组</p>
<p>slice (from, to) 截取数组，不会影响原数组，返回新数组</p>
<ul>
<li>
<p>增</p>
<ul>
<li>push() 尾部增加 返货数组新长度</li>
<li>unshift 首部增加 返回数组新长度</li>
<li>concat(“yellow”, [“red”, “green”]) 不会改变原数组</li>
</ul>
</li>
<li>
<p>删</p>
<ul>
<li>
<p>pop() 返回删除元素</p>
</li>
<li>
<p>shift 返回删除元素</p>
</li>
</ul>
</li>
<li>
<p>查</p>
<ul>
<li>indexOf() 返回元素所在索引，没有返回-1</li>
<li>includes() 返回 true/false</li>
<li>find 返回第一个查找元素, 没有返回 undefined (finnIndex、findLast、findLastIndex）</li>
</ul>
</li>
</ul>
<h3 id="排序方法"><a class="markdownIt-Anchor" href="#排序方法"></a> 排序方法：</h3>
<ul>
<li>sort(?compareFn) —toSorted</li>
<li>reverse --toReverse</li>
</ul>
<h3 id="转换"><a class="markdownIt-Anchor" href="#转换"></a> 转换</h3>
<ul>
<li>join(?separator) 转为由分隔符分隔的字符串
<ul>
<li>
<img src="/Users/liuye/学习/前端/ForInternNotes/note/2数组方法.assets/image-20230918150627981.png" alt="image-20230918150627981" style="width:30%; float:left;" />
</li>
</ul>
</li>
</ul>
<h3 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h3>
<p>（都有 thisArg 形参，更改回调函数体内 this 指向，但是<strong>直接使用</strong>箭头函数 this 仍指向上一层 this）</p>
<ul>
<li>some() 某一个符合条件 true，every 全部符合条件 true</li>
<li>forEach、filter、map</li>
</ul>
<h2 id="03-字符串方法"><a class="markdownIt-Anchor" href="#03-字符串方法"></a> 03 字符串方法</h2>
<ul>
<li>增 (返回副本)
<ul>
<li><code>+</code> <code>$&#123;&#125;</code></li>
<li>concat()</li>
</ul>
</li>
<li>删（返回副本）
<ul>
<li>slice(startIndex, endIndex)(与 substring 差不多，但 substring 不支持负数索引，start &gt; end 交换索引)</li>
<li>substr(startIndex, length)</li>
</ul>
</li>
<li>改
<ul>
<li>trim、trimLeft/Right 删空格</li>
<li>repeat(count) 重复几次这个字符串</li>
<li>padStart/End(maxLength, ?fillString) 不符合 maxLength 就长度填充， 默认填充空格</li>
</ul>
</li>
<li>查
<ul>
<li>charAt(index) 根据索引返回元素，没有返回空串</li>
<li>indexOf</li>
<li>startWith include 查找返回 true/false</li>
</ul>
</li>
</ul>
<p>转换方法</p>
<ul>
<li>split() 字符串转数组
<ul>
<li>
<img src="/Users/liuye/学习/前端/ForInternNotes/note/2数组方法.assets/image-20230918155323753.png" alt="image-20230918155323753" style="width:30%; float:left" />
</li>
</ul>
</li>
</ul>
<p>模板匹配</p>
<ul>
<li>match(<code>whichpattern</code>)</li>
<li>search</li>
<li>replace(originString, replaceString) (reg, function(match, …))</li>
</ul>
<h2 id="04-ajax"><a class="markdownIt-Anchor" href="#04-ajax"></a> 04 AJAX</h2>
<p>Ajax 允许我们利用 js 和 xmlHttpRequest 在后台与服务器交换数据</p>
<p>允许我们不用刷新网页，与后端交换数据，局部更新部分网页</p>
<p><mark>通过 XmlHttpRequest 向服务器发送异步请求，从服务器获得数据，利用 js 操作 dom 更新页面</mark></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建xhr对象实例</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">//与服务器创建连接</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">//给服务端发送数据</span></span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br><span class="line"><span class="comment">//接受服务端数据相应</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">//done 整个过程请求完成</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; shr.<span class="property">status</span> &lt;= <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="05-数据传输"><a class="markdownIt-Anchor" href="#05-数据传输"></a> 05 数据传输</h2>
<p>multipart/form-data 可以<strong>传输二进制文件</strong></p>
<p>application/x-www-form-urlencoded 用于传输普通的表单数据,</p>
<p>application/json 用于传输 JSON 对象,</p>
<p>二者都不会传输文件,主要传输<strong>字符串</strong>、<strong>数字类型</strong>的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">upload</span>(<span class="params">url, Form</span>) &#123;</span><br><span class="line">  <span class="comment">// FormData格式提交给后端</span></span><br><span class="line">  <span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="title class_">Form</span>) &#123;</span><br><span class="line">    params.<span class="title function_">append</span>(i, <span class="title class_">Form</span>[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里使用了 params.append(name, value) 方法,将字段名和值添加到 FormData 对象中。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> axios</span><br><span class="line">    .<span class="title function_">post</span>(url, params, &#123;</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;multipart/form-data&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="property">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="06-url-to-browser"><a class="markdownIt-Anchor" href="#06-url-to-browser"></a> 06 URL To Browser</h2>
<p>url</p>
<p>协议 + 域名 + 资源名(目录名/文件名)</p>
<h3 id="dns-解析"><a class="markdownIt-Anchor" href="#dns-解析"></a> DNS 解析</h3>
<p>找缓存-</p>
<ol>
<li>浏览器</li>
<li>操作系统</li>
<li>本地 host</li>
</ol>
<p>没有缓存</p>
<p>向域名服务器发送请求(dig +trace <a href="http://baidu.com">baidu.com</a>)</p>
<ol>
<li>根域名 .</li>
<li>顶级域名 .com</li>
<li>权威域名 <a href="http://baidu.com">baidu.com</a></li>
</ol>
<p>发送网络请求</p>
<h3 id="建立-tcp-链接-三次握手"><a class="markdownIt-Anchor" href="#建立-tcp-链接-三次握手"></a> 建立 TCP 链接 三次握手</h3>
<h3 id="发送-http-请求"><a class="markdownIt-Anchor" href="#发送-http-请求"></a> 发送 HTTP 请求</h3>
<p>options 请求，在其他请求之前发送</p>
<blockquote>
<p>post 请求格式为 application/json 格式才会触发 options</p>
<p>触发 options</p>
<ol>
<li>跨域，options 请求预先检测</li>
<li>自定义请求头</li>
</ol>
</blockquote>
<h3 id="浏览器缓存"><a class="markdownIt-Anchor" href="#浏览器缓存"></a> 浏览器缓存</h3>
<p>强缓存 浏览器强制缓存服务端的数据（静态资源）</p>
<blockquote>
<p><code>res.setHeader('Cache-Control', 'max-age=10')</code>或者设置 <code>res.setheader(expires GMT时间))</code></p>
<p>form disk cahce 磁盘缓存服务端的资源</p>
<p>from memory cache 内存缓存服务端资源 ，多次刷新，就读内存里的</p>
</blockquote>
<p>协商缓存</p>
<blockquote>
<p>Last-Modified GMT 时间 <mark>最后更改时间</mark></p>
<p>if-Modified-Since</p>
<p>如果前后时间(或 xxx 字段)是一致的那么就代表资源没有改变，后端返回 304，</p>
<p>变了代表资源改变，后端返回新的资源，返回 200</p>
<p>ETAG:‘xxx’ (文件 hash，or 版本号) <mark>唯一标识符，用于标识特定版本的资源</mark></p>
<p>if-None-Match</p>
</blockquote>
<h3 id="tcp-断链-4-次挥手"><a class="markdownIt-Anchor" href="#tcp-断链-4-次挥手"></a> TCP 断链 4 次挥手</h3>
<h3 id="html-渲染"><a class="markdownIt-Anchor" href="#html-渲染"></a> HTML 渲染</h3>
<p>html 解析器 解析标签为 DOM 树</p>
<p>样式计算</p>
<blockquote>
<p>渲染引擎格式化计算 css 样式(rem-&gt;px bold-&gt;700…) CSSOM 构建</p>
</blockquote>
<p>回流</p>
<blockquote>
<p>计算得到几何信息、大小</p>
</blockquote>
<blockquote>
<p><em>触发回流</em></p>
<ol>
<li>首次渲染</li>
<li>resize</li>
<li>跟大小宽高有关的改变</li>
<li>hover</li>
<li>js 获取 clientWidth</li>
</ol>
</blockquote>
<p>重绘</p>
<blockquote>
<p>元素样式的改变并不影响它在文档流中的位置(color backgoroung-color,visibility)，浏览器将新样式给他并重新绘制</p>
</blockquote>
<p>GPU 渲染</p>
<p>v8 解析 js</p>
<p>渲染树？？</p>
<h2 id="07-tcp-http"><a class="markdownIt-Anchor" href="#07-tcp-http"></a> 07 TCP HTTP</h2>
<p>OSI 七层</p>
<p>应用层 （应用进程之间的交互规则） 万维网 HTTP 邮件 SMTP 域名系统 DNS</p>
<p>表示层 （通信的应用程序能够<strong>解释交换数据的含义</strong>）</p>
<p>会话层 （建立、管理和终止<strong>表示层实体之间的通信会话</strong>）</p>
<p>传输层 （为<strong>进程之间的通信提供服务</strong>，处理数据包错误、数据包次序，以及其他）<strong>TCP UDP</strong></p>
<p>网络层 （选择合适的网间<strong>路由和交换节点</strong>，确保数据按时成功传送）</p>
<p>数字链路层 （两台主机之间的数据传输，总是在一段一段的链路上传送的，<strong>将 IP 数据组合成帧，相邻节点传输帧</strong>）</p>
<p>物理层 （定义传输媒介）</p>
<p>All People need data processing</p>
<h2 id="08-vue"><a class="markdownIt-Anchor" href="#08-vue"></a> 08 VUE</h2>
<p>v-if 切换有一个局部编译/卸载的过程，切换过程中合适的销毁和重建内部事件监听和子组件，v-show 只是简单的进行 css 的切换</p>
<blockquote>
<p>vif 切换消耗</p>
<p>Vshow 初始渲染消耗</p>
</blockquote>
<h2 id="09-定义列表"><a class="markdownIt-Anchor" href="#09-定义列表"></a> 09 定义列表</h2>
<p>自定义</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>无序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>11111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>22222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>选择框—分组</p>
<p><img src="https://s2.loli.net/2024/03/25/X4xb3CE5jMaNDsd.png" alt="image-20231007174223914" /></p>
<p>filedset legend</p>
<p><img src="https://s2.loli.net/2024/03/25/7TWLP8xkglwQc1i.png" alt="image-20231007174412245" /></p>
<h2 id="10-拖拽"><a class="markdownIt-Anchor" href="#10-拖拽"></a> 10 拖拽</h2>
<p><img src="https://s2.loli.net/2024/03/25/bt843AozKdD7Fi5.png" alt="image-20230524160915054" /></p>
<h2 id="11-和"><a class="markdownIt-Anchor" href="#11-和"></a> 11 <code>==</code>和<code>===</code></h2>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> <code>==</code></h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双等号隐式类型转换 ALL true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">100</span> == <span class="string">&quot;100&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> == <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> == <span class="literal">false</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span> == <span class="literal">false</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>
<h3 id="开发尽量使用"><a class="markdownIt-Anchor" href="#开发尽量使用"></a> 开发尽量使用<code>===</code>，</h3>
<p>但是这种情况可以，两者等价 <code>obj==null</code> 与<code>obj===null || obj===undefined</code></p>
<h2 id="12-闭包"><a class="markdownIt-Anchor" href="#12-闭包"></a> 12 闭包</h2>
<p><font color=red>指函数和其周围的状态（即词法环境）的组合，作用域的特殊运用</font></p>
<p>内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后</p>
<h3 id="自由变量"><a class="markdownIt-Anchor" href="#自由变量"></a> 自由变量</h3>
<p>在闭包函数中使用但<strong>不是在该函数作用域</strong>内声明的变量</p>
<p>自由变量的值：在<strong>函数定义</strong>的地方向上层寻找，与函数调用的地方无关</p>
<h4 id="以下是一些常见的触发闭包的情况"><a class="markdownIt-Anchor" href="#以下是一些常见的触发闭包的情况"></a> 以下是一些常见的触发闭包的情况：</h4>
<ol>
<li>函数嵌套：内部函数可以访问外部函数的变量，导致形成了闭包。</li>
<li>函数作为返回值：如果一个函数返回了一个内部函数，那么该内部函数可以访问到外部函数的变量，从而形成闭包。</li>
</ol>
<p>​</p>
<ol>
<li>事件监听：如果在事件监听函数内部定义了函数，那么该内部函数可以访问到事件监听函数的变量，形成闭包。</li>
<li>延迟调用：如果在一个函数内部调用了另外一个函数，并且该函数有一个定时器或者是回调函数，那么该回调函数可以访问到外部函数的变量，形成闭包。</li>
<li>IIFE（立即调用的函数表达式）：如果在一个函数内部定义了一个函数并立即调用，那么该内部函数可以访问到外部函数的变量，形成闭包。</li>
</ol>
<h2 id="13-防抖节流"><a class="markdownIt-Anchor" href="#13-防抖节流"></a> 13 防抖节流</h2>
<p><font color=red>事件被频繁触发时，减少事件执行的次数</font></p>
<h3 id="防抖-debounce"><a class="markdownIt-Anchor" href="#防抖-debounce"></a> 防抖 Debounce</h3>
<p>在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。(input 输入，resize )</p>
<p><img src="https://s2.loli.net/2024/03/25/KdzxpNmlB4w7MQE.png" alt="image-20230403104255692" /></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ipt&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> ipt = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#ipt&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">  ipt.<span class="title function_">addEventListener</span>(</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;keyup&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(ipt.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  )</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span></span><br><span class="line"><span class="language-javascript">        timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">500</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="节流-throttle"><a class="markdownIt-Anchor" href="#节流-throttle"></a> 节流 Throttle</h3>
<p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。（拖拽、scoll）</p>
<p><img src="https://s2.loli.net/2024/03/25/yGBE2tDsi1QVarZ.png" alt="image-20230403104138541" /></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;background-color: red; width: 100px;height: 100px;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> box1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.box1&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">  box1.<span class="title function_">addEventListener</span>(</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;drag&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">throttle</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">clientX</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  )</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (timer) <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span></span><br><span class="line"><span class="language-javascript">        timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">500</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="14-浏览器相关"><a class="markdownIt-Anchor" href="#14-浏览器相关"></a> 14 浏览器相关</h2>
<p>l 进程：一个程序的运行<strong>实例</strong></p>
<p>运行一个程序，操作系统会创建一块内存， 给代码和运行时的数据使用 ，并且创建一个<strong>线程</strong>来处理任务</p>
<p>线程是 一个进程的执行任务或者控制单元，负责当前进程中程序的执行</p>
<p>一个进程<u>至少</u>有一个线程，多个线程可以进行数据的共享</p>
<img src="./笔记.assets/image-20230405223549096.png" alt="image-20230405223549096" style="zoom:33%;" />
<p>特点：</p>
<ol>
<li>一个线程崩溃，整个进程崩溃</li>
<li>同一进程中，线程可以数据共享</li>
<li>进程关闭后，内存会正确回收</li>
</ol>
<p>普通单线程浏览器</p>
<ul>
<li>不稳定，</li>
<li>容易卡，</li>
<li>内存泄漏（所有页面在一个进程中，单个页面因为代码编写问题数据泄露。关闭页面时，泄露的内存不会回收）</li>
<li>安全问题（插件和渲染线程拥有很高权限，各种脚本代码（通常第三方编写））</li>
</ul>
<img src="./笔记.assets/image-20230405224432228.png" alt="image-20230405224432228" style="zoom:33%;" />
<p>Chrome 多线程</p>
<p>每个页面单独渲染进程和插件进程，装进沙箱，不能获取系统权限</p>
<p>权限由浏览器主线程操作</p>
<img src="./笔记.assets/image-20230405234925822.png" alt="image-20230405234925822" style="zoom: 25%;" />
<img src="./笔记.assets/image-20230405235048594.png" alt="image-20230405235048594" style="zoom:33%;" />
<p>主进程：页面的展示，页面的交互，管理子进程，提供存储功能</p>
<p>网络进程：下载网络资源</p>
<p>GPU 进程：绘制网页和 UI 界面</p>
<p>渲染进程：js v8 引擎，排版引擎 Blink （h5 css js 转换为网页）</p>
<h3 id="网络协议"><a class="markdownIt-Anchor" href="#网络协议"></a> 网络协议</h3>
<p>互联网协议 Internet protocol IP</p>
<p>网络层协议</p>
<p>计算机系统通过 ip 协议在网络中互相传输数据</p>
<p>IP 不好记 ----&gt; 域名</p>
<p>DNS 域名系统 Domain name system</p>
<p>找到具体服务器的系统服务器的 IP 地址，如何指定访问具体程序</p>
<p>​ UDP 用户数据包协议 user datagram protocol 端口号访问指定的程序 <font color=red>传输层协议</font></p>
<p>​ UDP 协议发送数据时，不能保证接收端一定收到</p>
<p>​ TCP 数据传输（控制）协议 transmission control protocol <font color=red>传输层协议  </font></p>
<p>​ 将数据拆分成数据包的形式传输</p>
<p>​ 数据包的丢失，提供重传的机制</p>
<p>​ <font color=blue>面向连接</font>，在传输数据之前，他会和目标设备进行连接，在传输完成后和目标断开连接 （创建和断开的过程，三次握手，四次挥手）</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">TCP</th>
<th style="text-align:center">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">连接方式</td>
<td style="text-align:center">有连接</td>
<td style="text-align:center">无连接</td>
</tr>
<tr>
<td style="text-align:center">可靠性保证</td>
<td style="text-align:center">提供可靠性保证</td>
<td style="text-align:center">不提供可靠性保证</td>
</tr>
<tr>
<td style="text-align:center">传输数据顺序保证</td>
<td style="text-align:center">传输数据顺序得到保证</td>
<td style="text-align:center">不保证传输数据顺序</td>
</tr>
<tr>
<td style="text-align:center">传输数据开销较大</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">适用场景</td>
<td style="text-align:center">适用于数据传输要求可靠的应用程序，如文件传输、电子邮件等</td>
<td style="text-align:center">适用于数据传输速度要求快的应用程序，如在线游戏、实时视频和音频通信等</td>
</tr>
</tbody>
</table>
<h3 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP 🤝👋🏻</h3>
<p><strong>三次握手(建立连接)</strong></p>
<p>​ 1. 客户端请求连接的请求 SYN，<font color=blue>随机起始序列号 Sequence Number</font> 给 服务端</p>
<p>​ 2. 服务端接受到请求，发送<u>确认信息 ACK</u>、SYN（伴随<font color=red>随机起始序列号</font>）、客户端发送来的<font color=blue><u>序列号+1</u></font>（aka<u>确认序列号 Acknowledgement Number</u>）</p>
<p>​ 3. 客户端收到服务器的 SYN 和 ACK，向服务器发送一个 ACK 确认信息（<font color=red>服务器随机序列号+1</font>）</p>
<p>通过握手过程，TCP 协议可以保证连接的可靠性和正确性，同时还可以进行流量控制和拥塞控制，以确保网络的稳定性和可靠性。</p>
<p><strong>四次挥手 （关闭连接）</strong></p>
<ol>
<li>🅰️ 发送一个 FIN 消息，表示没有数据传输，但 🆎 双方仍可接受数据</li>
<li>🅱️ 接受到 FIN，向对方发送 ACK，表示已经接受到该消息</li>
<li>🅱️ 也发送一个 FIN 消息，表示数据全部传输完毕，但 🆎 双方 🈲 不可发送数据</li>
<li>🅰️ 收到 FIN，返回一个 ACK 消息，表示已经接受到该消息</li>
</ol>
<p>通过挥手过程，TCP 协议可以保证数据的完整性和可靠性，在数据传输结束后及时关闭连接，释放资源，以便其他应用程序可以使用它们。</p>
<h3 id="规定传输格式"><a class="markdownIt-Anchor" href="#规定传输格式"></a> 规定传输格式</h3>
<p>浏览器 http 协议</p>
<p>http 请求流程</p>
<p>​ url 给我网页数据 查找缓存（存在且没过期，暂停请求 网页更快加载，减轻服务器压力</p>
<p>​ 没有缓存，http 做应用层协议，tcp ip 发送到网络中（之前通过域名获取 IP 地址，找到缓存，下次直接使用对应 ip,访问域名没有加端口，默认加:80(http 默认端口)</p>
<p>​ 为 TCP 建立连接做 3 次握手，完成 发送 http 请求 ||服务端接受返回数据</p>
<h4 id="输入-url-到页面展示"><a class="markdownIt-Anchor" href="#输入-url-到页面展示"></a> 输入 URL 到页面展示</h4>
<ol>
<li>
<p>浏览器判断输入的内容，不符合 URL 规则，内置搜索引擎搜索；符合规则，加上协议</p>
</li>
<li>
<p>请求阶段：浏览器主进程 =<u>URL(进程之间通信)</u> =&gt; 网络进程=（转圈，接受服务器返回的 http 相应头 html）,让浏览器开启一个渲染进程，发送一个提交文档命令。</p>
<p>网络进程=（HTTP 文档）=&gt; 渲染进程</p>
</li>
</ol>
<p>​ <img src="./笔记.assets/image-20230406143157791.png" alt="image-20230406143157791" style="zoom:25%;" /></p>
<p>​</p>
<p>渲染完毕 ，接受完毕指令，当前页面白屏</p>
<img src="./笔记.assets/image-20230406143342974.png" alt="image-20230406143342974" style="zoom:25%;" />
<p>渲染进程联合 GPU 进程渲染，并返回</p>
<img src="./笔记.assets/image-20230406143530487.png" alt="image-20230406143530487" style="zoom:25%;" />
<p>网络进程 ?缓存资源(返回给浏览器主进程，中断请求)</p>
<p>​ 没有，进入网络流程</p>
<p>​ DNS 解析 ip 地址</p>
<p>同一站点（根域名，协议相同 ）公用一条渲染进程</p>
<p><img src="./%E7%AC%94%E8%AE%B0.assets/image-20230406144818544.png" alt="image-20230406144818544" /></p>
<h2 id="15-面向对象"><a class="markdownIt-Anchor" href="#15-面向对象"></a> 15 面向对象</h2>
<p><strong>类的封装、继承、多态</strong></p>
<ul>
<li>
<p>封装：低内聚高耦合</p>
</li>
<li>
<p>多态：重载和重写</p>
</li>
</ul>
<p>​ 重载：方法名相同，形参个数或者类型不一样</p>
<p>​ JS 中不存在真正意义上的重载，JS 重载指的是使用同一个方法，根据传参不同，实现不同的效果</p>
<p>JS 中的面向对象是基于原型和原型链的</p>
<ul>
<li>继承：子类继承父类的方法</li>
</ul>
<h3 id="js-继承"><a class="markdownIt-Anchor" href="#js-继承"></a> <strong>JS 继承：</strong></h3>
<ul>
<li><strong>原型继承</strong>
<ul>
<li>优点：父类方法可以被复用</li>
<li>缺点：1. 父类的<strong>引用类型</strong>数据会被子类共享篡改 2. <u>子类实例不能给给父类构造函数传参</u></li>
</ul>
</li>
<li><strong>call 继承</strong> 借用构造函数
<ul>
<li>优点：父类的<strong>引用类型</strong>数据不会被子类共享篡改</li>
<li>缺点：不能访问父类原型属性上的方法</li>
</ul>
</li>
<li>**组合继承（**原型继承和 call 继承的结合）
<ul>
<li>优点：
<ul>
<li>父类方法复用</li>
<li>父类引用数据不会被子类共享篡改</li>
<li>子类可以访问父类原型上的方法</li>
</ul>
</li>
<li>缺点：
<ul>
<li>会调用两次父类的数据，会有两份一样的属性和方法，影响性能</li>
</ul>
</li>
</ul>
</li>
<li><strong>寄生组合继承</strong>
<ul>
<li>优点
<ul>
<li>改变以上优缺点</li>
</ul>
</li>
<li>
<h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2>
</li>
</ul>
</li>
<li>ES6 extends、super</li>
</ul>
<h2 id="16-判断数据类型"><a class="markdownIt-Anchor" href="#16-判断数据类型"></a> 16 判断数据类型</h2>
<p><code>typeof </code></p>
<p>Array Object null 都是返回 object 类型 (set、map 也是 object，symbol 返回 symbol)</p>
<p><mark><code>Object.prototype.toString.call()</code> 都可以区分 [] {} null</mark></p>
<h2 id="17-手写代码"><a class="markdownIt-Anchor" href="#17-手写代码"></a> 17 手写代码</h2>
<h3 id="instanceof"><a class="markdownIt-Anchor" href="#instanceof"></a> instanceof</h3>
<p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
<p>判断继承关系，在同一条原型链上，返回 true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">obj1, obj2</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> objProto = obj1.<span class="property">__proto__</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (objProto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (objProto === obj2.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 一层一层往上找</span></span><br><span class="line">    objProto = objProto.<span class="property">__proto__</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bind"><a class="markdownIt-Anchor" href="#bind"></a> bind</h3>
<p><img src="https://s2.loli.net/2024/03/25/iGepJNhtcAM5ZsF.png" alt="image-20230403201715838" /></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// console.log(this) //fn函数</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> arg = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="keyword">const</span> _this = arg.<span class="title function_">shift</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(_this, arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, [...args, ...<span class="variable language_">arguments</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝"><a class="markdownIt-Anchor" href="#深拷贝"></a> 深拷贝</h3>
<ul>
<li></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在一些复杂的对象中，比如包含<strong>函数、正则表达式、日期等类型</strong>的对象时，使用<code>JSON.parse(JSON.stringify(obj))</code>可能会导致数据丢失或类型错误，因为<strong>这些类型的对象不能被序列化为 JSON 字符串</strong>。这时候需要采用其他的深度复制方法，比如手动递归复制、使用第三方库等。</p>
<ul>
<li>递归
<ul>
<li>(没有考虑循环引用) 如果对象 A 引用了对象 B，而对象 B 又引用了对象 A，那么在进行深拷贝的时候会陷入死循环。（哈希表）</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || obj == <span class="literal">null</span>) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="keyword">let</span> res = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;</span><br><span class="line">  <span class="comment">//  for in会遍历到obj原型链上的属性，增加判断，健壮性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 嵌套的一层不会被克隆，所以再加一次深度克隆</span></span><br><span class="line">      res[key] = <span class="title function_">deepClone</span>(obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lodash.cloneDeep()</code></li>
</ul>
<h3 id="扁平化数组"><a class="markdownIt-Anchor" href="#扁平化数组"></a> 扁平化数组</h3>
<p>借助 Array.prototype.concat.apply([], arr)</p>
<h2 id="18-预编译"><a class="markdownIt-Anchor" href="#18-预编译"></a> 18 预编译</h2>
<h3 id="js-预编译"><a class="markdownIt-Anchor" href="#js-预编译"></a> JS 预编译</h3>
<p>js 属于解释性语言，在执行过程中顺序执行，但是会分块先预编译再执行。因此 JS 存在一种变量提升的现象。</p>
<p><strong>但是是因为有预编译才有 所谓的变量提升</strong></p>
<h4 id="函数先于变量提升"><a class="markdownIt-Anchor" href="#函数先于变量提升"></a> 函数先于变量提升</h4>
<h5 id="变量提升"><a class="markdownIt-Anchor" href="#变量提升"></a> 变量提升</h5>
<p>var 声明变量提升、function 声明函数提升</p>
<p>无论这两者声明或调用的位置是前是后，系统总是会将其提升到调用前面，因此只值为 undefined</p>
<h5 id="js-代码运行的三大步骤"><a class="markdownIt-Anchor" href="#js-代码运行的三大步骤"></a> JS 代码运行的三大步骤</h5>
<ol>
<li>词法分析</li>
<li>预编译</li>
<li>解释执行</li>
</ol>
<h5 id="暗示全局变量-imply-global"><a class="markdownIt-Anchor" href="#暗示全局变量-imply-global"></a> 暗示全局变量 imply global</h5>
<p>任何变量，<font color=red>未经声明就赋值</font>，此变量为<strong>全局</strong>所有</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  a = <span class="number">100</span></span></span><br><span class="line"><span class="language-javascript">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a, <span class="variable language_">window</span>.<span class="property">a</span>)) <span class="comment">//100 100</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">     b = <span class="number">200</span></span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   <span class="title function_">test</span>()</span></span><br><span class="line"><span class="language-javascript">   <span class="variable language_">console</span>.<span class="title function_">log</span>(b, <span class="variable language_">window</span>.<span class="property">b</span>) <span class="comment">//200 200</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>、、、、、在 ES5 下、、、、、</p>
<h5 id="global-object-和-activition-object"><a class="markdownIt-Anchor" href="#global-object-和-activition-object"></a> Global Object 和 Activition Object</h5>
<p>所谓的全局作用域，局部作用域</p>
<blockquote>
<ol>
<li>创建 GO 对象</li>
<li>寻找变量声明 var，值设定为 undefined</li>
<li>寻找函数声明，将函数名作为 GO 属性名，值为函数体</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>创建 AO 对象</li>
<li>寻找函数的<strong>形参</strong>和<strong>变量声明</strong>var，将变量和形参名作为 AO key，value 为 undefined</li>
<li>统一形参和实参，即更改形参后的 undefined 为实参值</li>
<li>寻找函数声明，将函数作为 AO key，value 为函数体</li>
</ol>
</blockquote>
<p>匿名函数、函数表达式不参与预编译</p>
<p><img src="https://s2.loli.net/2024/03/25/uCr87YZGxmKEwqi.png" alt="image-20230330165816238" /></p>
<p><img src="https://s2.loli.net/2024/03/25/xetFnNd1LAZo9Ec.png" alt="image-20230330190058698" /></p>
<p><img src="./%E7%AC%94%E8%AE%B0.assets/image-20230330190037506.png" alt="image-20230330190037506" /></p>
<p>ES6 新增的块级作用域</p>
<hr />
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//1</span></span><br><span class="line">  c = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> c</span><br><span class="line">  a = <span class="number">3</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">//2</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">d</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>预编译</p>
<p>AO：{</p>
<p>​ a:<s>undefined</s> 1</p>
<p>​ b:<s>undefined</s> fn</p>
<p>​ c:undefined</p>
<p>​ d: fn</p>
<p>}</p>
<p>执行</p>
<p>AO：{</p>
<p>​ a:<s>undefined</s> <s>1</s> 3</p>
<p>​ b:<s>undefined</s> <s>fn</s> 2</p>
<p>​ c:<s>undefined</s> 0</p>
<p>​ d: fn</p>
<p>}</p>
</blockquote>
<hr />
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//fn a</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">//udefined</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">//1</span></span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//2</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> a</span><br><span class="line">  b = <span class="number">3</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">//fn</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>预编译</p>
<p>AO：{</p>
<p>​ a:<s>undefined</s> <s>1</s> fn</p>
<p>​ b:undefined</p>
<p>}</p>
<p>执行</p>
<p>AO：{</p>
<p>​ a:<s>undefined</s> <s>1</s> <s>fn</s> 2</p>
<p>​ b:<s>undefined</s> <s>1</s> <s>3</s> fn</p>
<p>}</p>
</blockquote>
<hr />
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">e</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e) <span class="comment">//2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">123</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;&#125; <span class="comment">//在if语句里面不声明（块级作用域）</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> c</span><br><span class="line">  <span class="keyword">var</span> a</span><br><span class="line">  a = <span class="variable language_">arguments</span>[<span class="number">1</span>]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">//undefined</span></span><br><span class="line">  f = <span class="number">456</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">//undefined</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f) <span class="comment">//456</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f) <span class="comment">//456</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>预编译</p>
<p>AO：{</p>
<p>​ e:<s>undefined</s> <s>1</s> fn(e)</p>
<p>​ b: undefined</p>
<p>​ c: undefined</p>
<p>​ a:undefined</p>
<p>}</p>
<p>GO:{</p>
<p>​ a: undefined</p>
<p>​ test: fn</p>
<p>}</p>
<p>执行</p>
<p>AO：{</p>
<p>​ e:<s>undefined</s> <s>1</s> <s>fn(e)</s> 2</p>
<p>​ b: undefined</p>
<p>​ c: undefined</p>
<p>​ a:<s>undefined</s> 2</p>
<p>}</p>
<p>GO:{</p>
<p>​ a: <s>undefined</s> 100</p>
<p>​ test: fn</p>
<p>}</p>
</blockquote>
<h2 id="19-for-in-of"><a class="markdownIt-Anchor" href="#19-for-in-of"></a> 19 <code>for in of</code></h2>
<h4 id="for-in-遍历得到-key"><a class="markdownIt-Anchor" href="#for-in-遍历得到-key"></a> For in 遍历得到 key</h4>
<ul>
<li>可枚举的数据 (<code>Object.getOwnPropertyDescriptors()</code>)</li>
</ul>
<p>​ 数组、字符串、对象</p>
<p><font color=red><code>for...in</code> 循环可以遍历对象的可枚举属性，包括自有属性和继承属性。但是需要注意的是，它不能保证属性的遍历顺序，而且会遍历对象的原型链上的属性，所以需要使用 <code>hasOwnProperty()</code> 方法来判断属性是否为自有属性。</font></p>
<h4 id="for-of-遍历得到-value"><a class="markdownIt-Anchor" href="#for-of-遍历得到-value"></a> for of 遍历得到 value</h4>
<ul>
<li>可迭代的数据 (<code>arr[Symbol.iterator]()</code>)</li>
</ul>
<p>​ 数组、字符串、set、map</p>
<h4 id="for-await-of"><a class="markdownIt-Anchor" href="#for-await-of"></a> For await of</h4>
<p>遍历一组 Promise</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">generatePromise</span>(<span class="params">num</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">resolve</span>(num)</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">500</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> p1 = <span class="title function_">generatePromise</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> p2 = <span class="title function_">generatePromise</span>(<span class="number">2</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> p3 = <span class="title function_">generatePromise</span>(<span class="number">3</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> p4 = <span class="title function_">generatePromise</span>(<span class="number">4</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> list = [p1, p2, p3, p4]</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 如何一下子拿到所有结果</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/*     (async function()&#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        for await(let val of list)&#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            console.log(val) //1,2,3,4一行一行打印</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    &#125;)()</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    Promise.all(list).then(res=&gt;&#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        console.log(res) //[1,2,3,4] 返回数组结果</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    &#125;) */</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 如和一步一步拿到结果</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span></span><br><span class="line"><span class="language-javascript">  ;(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> data) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">generatePromise</span>(val)</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;??&quot;</span>, res)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* const res1 = await generatePromise(data[0])</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        console.log(res1)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        const res2 = await generatePromise(data[1])</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        console.log(res2)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        const res3 = await generatePromise(data[2])</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        console.log(res3)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        const res4 = await generatePromise(data[3])</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        console.log(res4)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        const res5 = await generatePromise(data[4])</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        console.log(res5) */</span></span></span><br><span class="line"><span class="language-javascript">  &#125;)()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="20-js-类型转换"><a class="markdownIt-Anchor" href="#20-js-类型转换"></a> 20 JS 类型转换</h2>
<p>js 是动态类型语言，我们在定义一个变量其实并没有指定这个变量到底属于那种类型，只有到程序执行阶段才确定当前数据类型。</p>
<p>而<font color=red>各种<strong>运算符</strong>对数据类型是有要求的</font>，所以就会触发类型转换机制（no matter 人为 or 隐式触发）</p>
<h3 id="显示转换"><a class="markdownIt-Anchor" href="#显示转换"></a> 显示转换：</h3>
<p>​ 通过 JS 内置的函数<strong>明确转换的数据类型</strong></p>
<ul>
<li>
<p>Number</p>
</li>
<li>
<p>parseInt(string, ?进制) 比 Number 宽松，一位一位解析遇到不能解析的停止</p>
</li>
<li>
<p>String</p>
</li>
<li>
<p>Boolean</p>
</li>
</ul>
<h3 id="隐式转换"><a class="markdownIt-Anchor" href="#隐式转换"></a> 隐式转换：</h3>
<p>​ 运算操作符两边数据类型不一致（比较运算符、算术运算符）</p>
<ul>
<li>
<p>转为 Boolean (需要布尔值的地方，借助的<code>Boolean()</code>函数)</p>
<ul>
<li>falsely 变量：<code>undefined</code>、<code>null</code>、<code>false</code>、<code>+/-0</code>、<code>NAN</code>、<code>&quot;&quot;</code></li>
</ul>
</li>
<li>
<p>转为 String （复合类型—&gt;原始类型----&gt;字符串）</p>
<ul>
<li>常发生在 <code>&quot;5&quot; + xxx</code> 加法运算符号</li>
</ul>
</li>
<li>
<p>转为 Number</p>
<ul>
<li>除了加法运算符号，其他都有可能</li>
</ul>
</li>
</ul>
<h3 id="other"><a class="markdownIt-Anchor" href="#other"></a> other</h3>
<blockquote>
<p><code>=== </code>在不进行类型转换情况下，双方的类型与值都相等</p>
</blockquote>
<h2 id="21-js-事件机制"><a class="markdownIt-Anchor" href="#21-js-事件机制"></a> 21 JS 事件机制</h2>
<p>事件</p>
<p>就是 html 文档与浏览器的一些交互操作，使网页具备互动性</p>
<p>由于<strong>DOM</strong>是一个<strong>树</strong>结构，如果在<strong>父子节点绑定事件</strong>时候，当触发<strong>子节点</strong>的时候，就存在一个<strong>顺序问题</strong>，这就涉及到了**<u>事件流</u>**的概念</p>
<p><strong><em>捕获 目标 冒泡</em></strong></p>
<img src="https://s2.loli.net/2024/03/25/7IP1hs6lGbOHMjW.png" alt="image-20230518210314566" style="zoom:50%;" />
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addEventLisener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;, <span class="literal">false</span>) <span class="comment">//默认false，不在捕获阶段执行</span></span><br><span class="line"></span><br><span class="line">event.<span class="title function_">preventPropagation</span>() <span class="comment">//阻止在冒泡阶段执行</span></span><br></pre></td></tr></table></figure>
<p>click 事件 冒泡</p>
<h2 id="22-js-异步机制"><a class="markdownIt-Anchor" href="#22-js-异步机制"></a> 22 JS 异步机制</h2>
<h3 id="js-异步编程"><a class="markdownIt-Anchor" href="#js-异步编程"></a> JS 异步编程</h3>
<p>单线程</p>
<p>DOM 操作，必须要使用单线程模型，否则出现多线程同步问题（一个线程增，一个线程删，麻烦）</p>
<p>假如说只用同步来解决，即排队执行代码，那么则简单、安全。但是遇到一段非常耗时的代码段，导致整个程序被拖延，导致假死（阻塞）情况。所以 JS 带来<u>同步</u>模式<u>异步</u>模式来解决此问题。</p>
<ul>
<li>同步模式与异步模式</li>
<li>事件循环与消息队列</li>
<li>异步编程几种方式</li>
<li>Promise 异步方案、宏任务/微任务队列 （ES2015）</li>
<li>Generator 异步方案（ES2015），Async/Await 语法糖（ES2017）</li>
</ul>
<h3 id="同步模式与异步模式"><a class="markdownIt-Anchor" href="#同步模式与异步模式"></a> 同步模式与异步模式</h3>
<p><strong><font color=red>同步模式</font></strong></p>
<p><u>排队一步一步执行</u></p>
<p>开始执行 JS 引擎将全部代码加载进来，<code>call stack</code>压入一个<code>(anonymous)</code> （全部代码放入匿名函数中执行，<code>call stack</code>是调用栈，函数声明不会压入栈中）</p>
<p><strong><font color=red>异步模式</font></strong></p>
<p>不会等待这个任务结束，才开始下一个任务。开启过后，立即开始下一个任务。后续逻辑一般会通过<strong>回调函数</strong>的方式定义</p>
<p><em>代码执行顺序混乱？？</em></p>
<p>倒计时器根本不会管 call stack 和 Queue，放在 WebAPI 中</p>
<p>call stack 正在执行的工作表</p>
<p>Queue 待办工作表</p>
<p>Event Loop 监听 call stack 和 Queue，</p>
<p>一旦 call stack 任务结束，事件循环会从 Queue 中取出第一个回调函数压入到 call stack</p>
<img src="https://s2.loli.net/2024/03/25/icy4GVaP2uew3fp.png" alt="image-20230403162215658" style="zoom:50%;" />
<img src="https://s2.loli.net/2024/03/25/Nqmv6TrSUJFxVjO.png" alt="image-20230403162615098" style="zoom:50%;" />
<img src="https://s2.loli.net/2024/03/25/8NHPdJlVshjn1wz.png" alt="image-20230403162834422" style="zoom:35%;" />
<p>JS 单线程，是指执行代码是单线程的，但浏览器并不是单线程。</p>
<p>而我们所说的同步异步问题是指<strong>运行环境提供的 API 是以同步或异步模式的方式工作</strong></p>
<h3 id="回调函数"><a class="markdownIt-Anchor" href="#回调函数"></a> 回调函数</h3>
<p>所有异步编程方案的根基</p>
<p>理解为：<code>一件你想要做的事---&gt;但不知道这件事所依赖的事情什么时候结束---&gt;交给异步任务执行者，他知道</code></p>
<p>​ <strong>调用者定义 交给执行者执行</strong></p>
<p><em><font color=gray>事件机制、发布订阅基于回调</font></em></p>
<h3 id="promise"><a class="markdownIt-Anchor" href="#promise"></a> Promise</h3>
<p>一种更优秀的异步编程统一方案（CommonJS 社区提出，被纳入 ES2015）</p>
<p><img src="https://s2.loli.net/2024/03/25/L3nQBlK6ejMhGgy.png" alt="image-20230329145634209" /></p>
<p>明确成功或失败的<u>结果</u>（不可被修改）后，都会有相应的任务自动执行。</p>
<h4 id="链式调用不是通过函数-return-this-达到的链式调用"><a class="markdownIt-Anchor" href="#链式调用不是通过函数-return-this-达到的链式调用"></a> 链式调用（不是通过函数 return this 达到的链式调用）</h4>
<p><code>.then( )方法</code> 返回的是全新的 Promise 对象 （返回</p>
<p>每一个 then 方法实际上都是为上一个 then 返回的 Promise 对象添加状态明确的回调</p>
<ul>
<li>
<p>Promise 的 then 方法返回一个<font color=yellowgreen>全新</font>的 Promise 对象（所以可以采用.then 链式调用）</p>
<ul>
<li>.then 后面会返回一个新的 promise 实例，又可以继续调用 then 或者 catch 方法</li>
</ul>
</li>
<li>
<p>后面的 then 方法就是在为上一个 then 方法返回的 Promise 对象注册回调（添加状态明确的回调）</p>
</li>
<li>
<p>前面 then 方法 return 的返回值会作为下一个 then 方法回调的参数</p>
<ul>
<li>如果 return 的是 Promise 对象，那么后面的 then 方法会等待到他的结束</li>
</ul>
</li>
</ul>
<h4 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h4>
<p>两个回调<code>(onFulfilled，onRejected)</code> （只能在当前 then 方法调用中接住）</p>
<p>.catch （相当于两个回调 其中<code>(undefined，onRejected)</code> ，异常可以被传递，而被 catch 接住</p>
<p>unHandledRejection（全局）</p>
<h4 id="静态方法"><a class="markdownIt-Anchor" href="#静态方法"></a> 静态方法</h4>
<p><code>Promise.reslove()</code> 将一个值快速转换为 Promise 对象</p>
<p>用此方法包装一个 Promise 对象得到的还是原本的 Promise 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p === p2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>如果用此方法，包装如下带有 then 方法的对象 <strong>(thenable 可以被 then 的对象)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(&#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">(<span class="params">onFulfilled, onRejected</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onFulfilled</span>(<span class="string">&quot;qqqq&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">//qqqq</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Promise.reject()</code> 无论传什么参数，都会作为 Promise 失败的理由</p>
<h4 id="priomse-并行执行"><a class="markdownIt-Anchor" href="#priomse-并行执行"></a> Priomse 并行执行</h4>
<p>在页面请求多个接口的情况，这些请求没有过多依赖，那么就可同时请求</p>
<p>怎么知道这些请求完成？传统用<u>计数器</u></p>
<p><code>Promise.all()</code> 多个 Promise 集中管理 （同步执行多个 Promise 的方式）等待所有 Promise 结束后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([xxx, yyy]) <span class="comment">// xxx,yyy为Promise对象</span></span><br></pre></td></tr></table></figure>
<p><code>Promise.race()</code> 只会等待第一个完成的任务，就结束</p>
<h4 id="promise-执行时序-宏任务-vs-微任务"><a class="markdownIt-Anchor" href="#promise-执行时序-宏任务-vs-微任务"></a> Promise 执行时序 宏任务 vs 微任务</h4>
<p>Promise 执行时序有点特殊</p>
<p>回调队列 Queue 中的任务 <font color=red><strong>『宏任务』</strong>，宏任务执行过程期间可能会加上额外的需求</font>，</p>
<p>​ 这些需求可以<u>选择</u>作为<u><em>新的宏任务</em></u>进入到队列 Queue 中排队</p>
<p>​ 也可以作为当前任务的<font color=red><strong>『微任务』</strong>，直接在当前任务结束之后立即执行</font>，而不是进入队列排队</p>
<p><strong>Promise 回调作为<em>微任务</em> 执行的</strong> （本轮结束的末尾，自动执行，不进入队列）</p>
<p>​ 如果处于 pending 状态就不能进入这一次微任务</p>
<p>​ await 后面的语句加入到微任务队列</p>
<p>微任务：提高整体的响应能力</p>
<blockquote>
<p>目前绝大多数异步调用都是作为宏任务执行</p>
<p>微任务：Promise、mutationObserver 以及 Node 中的 process.nextTick</p>
</blockquote>
<h3 id="generator-异步方案"><a class="markdownIt-Anchor" href="#generator-异步方案"></a> Generator 异步方案</h3>
<blockquote>
<p>Promise 处理异步任务的串联执行，仍然有大量的回调函数，虽然没有嵌套，影响阅读</p>
<img src="https://s2.loli.net/2024/03/25/L257BeUSh9HpoNy.png" alt="image-20230329205937527" style="zoom:35%; float:left;margin-left:30px"  />
<p>传统异步模式，更简洁，更利于阅读</p>
<img src="https://s2.loli.net/2024/03/25/X56H7Zl3Ns2MOwE.png" alt="image-20230329210419648" style="zoom:30%;float:left" />
</blockquote>
<h4 id="generator-es2015"><a class="markdownIt-Anchor" href="#generator-es2015"></a> Generator ES2015</h4>
<p>Generator 函数返回的遍历器对象都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。外面 try catch 捕获</p>
<p>生成器函数执行器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> api = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&quot;/api.json&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(api)</span><br><span class="line">    <span class="keyword">const</span> api2 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&quot;/api2.json&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(api2)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* const g = main()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    handleResult(g.next())</span></span><br><span class="line"><span class="comment">    // 生成器函数执行器</span></span><br><span class="line"><span class="comment">    function handleResult(result) &#123;</span></span><br><span class="line"><span class="comment">        if (result.done) return</span></span><br><span class="line"><span class="comment">        result.value.then(data =&gt; &#123;</span></span><br><span class="line"><span class="comment">            handleResult(g.next(data))</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">            error =&gt; &#123;</span></span><br><span class="line"><span class="comment">                g.throw(error)</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>(main)</span><br><span class="line"><span class="comment">// 生成器函数执行器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">generator</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">generator</span>()</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleResult</span>(g.<span class="title function_">next</span>())</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleResult</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span></span><br><span class="line">    result.<span class="property">value</span>.<span class="title function_">then</span>(</span><br><span class="line">      <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">handleResult</span>(g.<span class="title function_">next</span>(data))</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        g.<span class="keyword">throw</span>(error)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>异步调用扁平化</u></p>
<h3 id="async-await"><a class="markdownIt-Anchor" href="#async-await"></a> Async Await</h3>
<p>ES2017</p>
<p>不在需要类似 co 的执行器，语言层面的标准一步语法</p>
<p>async 函数返回的是一个 Promise 对象，利于控制整体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//宏任务1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;children2&quot;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;children3&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;children4&quot;</span>) <span class="comment">//2</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//宏任务</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;children5&quot;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;children6&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 微任务</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;children7&quot;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// start children4 children2 children3  children5  children7 children6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//juejin.cn/post/6950786264941461541</span></span><br></pre></td></tr></table></figure>
<h4 id="asyncawait-执行顺序"><a class="markdownIt-Anchor" href="#asyncawait-执行顺序"></a> async/await 执行顺序</h4>
<p>我们知道<code>async</code>隐式返回 Promise 作为结果的函数,那么可以简单理解为，await 后面的函数执行完毕时，await 会产生一个微任务(Promise.then 是微任务)。</p>
<p>但是我们要注意这个微任务产生的时机，它是执行完 await 之后，直接跳出 async 函数，执行其他代码(此处就是<strong>协程</strong>的运作，A 暂停执行，控制权交给 B)。</p>
<p><font color=red>其他代码执行完毕后，再回到 async 函数去执行剩下的代码，然后把 await 后面的代码注册到微任务队列当中</font>。我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>) <span class="comment">//1微任务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2 end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise&quot;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>)</span><br><span class="line"><span class="comment">// 旧版输出如下，但是请继续看完本文下面的注意那里，新版有改动</span></span><br><span class="line"><span class="comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTime</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>¡importante!</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/posts/TCP/</url>
    <content><![CDATA[<p><strong style="color:red;">在不可靠的网络链路中，进行可靠的链接/断开</strong></p>
<p><strong>全双工（Full Duplex）</strong></p>
<ol>
<li>双向传输:TCP连接的两端都可以同时发送和接收数据包。</li>
<li>双向流量控制:发送方和接收方都可以通过滑动窗口机制控制数据流量,防止对方缓冲区溢出。</li>
<li>双向确认:发送的数据包可以得到对方的确认应答ACK。接收方也可以通过ACK告知发送方自己已经正确接收了数据。</li>
<li>双向重传:如果任意一方没有收到确认或数据包丢失,都可以触发重传机制,直到数据正确发送。</li>
<li>全双工通信:TCP的全双工特性使得双方可以同时进行发言而不会相互干扰,就像电话通话一样。</li>
</ol>
<blockquote>
<p><code>ACK</code> 和<code>FIN</code> 是 TCP 协议中两个重要的控制标志(control flag)</p>
<p><code>ACK(Acknowledgement) </code>确认号，表示确认号,确认接收端已正确接收到前面的数据</p>
<p><code>FIN (Finish)</code> 结束标志，表示发送端已经发送完数据,可以关闭连接了。</p>
</blockquote>
<h2 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手🤝</h2>
<img src="https://i.imgur.com/bJWYomc.png" alt="三次挥手示意图" style="width:50%" />
<h2 id="传输"><a class="markdownIt-Anchor" href="#传输"></a> 传输</h2>
<p>一包数据可能被拆为多包数据发送</p>
<p><strong>丢包问题？乱序问题？</strong></p>
<p>TCP为每个链接建立了一个<mark>发送缓冲区</mark></p>
<img src="https://s2.loli.net/2023/09/11/ACj3KLUHcNiVIMs.png" style="width:50%;" alt="传输示意图" />
<blockquote>
<p>一问一答的方式发送接收（发送端一次也可以发送多包数据，接收端只用回复一次ACK）</p>
</blockquote>
<blockquote>
<p>发送端可以切割发送，接收端利用序列号和长度重组出完整的数据</p>
</blockquote>
<blockquote>
<p>丢失了某个数据包，接收端可以要求发送端重传。</p>
<p>接收端向发送端发送ACK=xxx，发送端重传，接收端收到再<strong>补齐</strong>数据</p>
</blockquote>
<h2 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手👋🏻</h2>
<p>这里以客户端取消l为例</p>
<img src="https://s2.loli.net/2023/09/11/nrxG86lYUf7CqMX.png" alt="四次挥手示意图" style="width:50%;" />
<p>Client等待一段时间，目的为了确保ACK成功发送给Server，否则Server重新发送FIN给client，再重新执行</p>
]]></content>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Volta node版本管理</title>
    <url>/posts/Volta-node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="volta"><a class="markdownIt-Anchor" href="#volta"></a> volta</h2>
<blockquote>
<p>试了多种node版本工具<code>nvm</code> <code>fnm</code>，都没有成功下在离线状态下托管本地node包</p>
</blockquote>
<p>快速安装管理和切换不同版本的node、npm、yarn等的工具</p>
<h3 id="离线管理不同版本的nodewindows"><a class="markdownIt-Anchor" href="#离线管理不同版本的nodewindows"></a> 离线管理不同版本的node（Windows）</h3>
<h4 id="1-下载安装volta"><a class="markdownIt-Anchor" href="#1-下载安装volta"></a> 1. 下载安装volta</h4>
<ul>
<li><code> https://github.com/volta-cli/volta/releases/download/v2.0.1/volta-2.0.1-windows-x86_64.msi</code></li>
</ul>
<h4 id="2-导入本地node预构二进制文件压缩包"><a class="markdownIt-Anchor" href="#2-导入本地node预构二进制文件压缩包"></a> 2. 导入本地node预构二进制文件压缩包</h4>
<ul>
<li>
<p>将Windows的 node zip包放在<code>C:\Users\&#123;用户&#125;\AppData\Local\Volta\tools\inventory\node</code>文件夹中</p>
</li>
<li>
<p><img src="https://s2.loli.net/2024/11/13/UHpEI4ekiMvmdLR.png" alt="windows-volta-node.png" /></p>
</li>
</ul>
<blockquote>
<p><mark>到这一步volta还没有托管手动导入的node包，需要手动挂载到全局或者项目中，才能正常使用</mark></p>
</blockquote>
<h4 id="3-托管本地node包切换node版本也是这流程"><a class="markdownIt-Anchor" href="#3-托管本地node包切换node版本也是这流程"></a> 3. 托管本地node包（切换node版本也是这流程）</h4>
<ul>
<li>
<p>全局级别</p>
<ul>
<li><code>volta install node@&lt;version&gt;</code></li>
</ul>
</li>
<li>
<p>项目级别</p>
<ul>
<li>进入<strong>项目根目录</strong>终端，<code>volta pin node@&lt;version&gt;</code></li>
<li><img src="https://s2.loli.net/2024/11/13/l2Rfm5NTXLGsnA1.png" alt="volta-.png" /></li>
</ul>
</li>
</ul>
<blockquote>
<p>volta将托管导出进来的node包，并在文件夹下生成一个<code>node-v版本号-npm</code>文件</p>
</blockquote>
<h4 id="查看当前托管的node版本"><a class="markdownIt-Anchor" href="#查看当前托管的node版本"></a> 查看当前托管的node版本</h4>
<ul>
<li><code>volta list node</code></li>
<li><img src="https://s2.loli.net/2024/11/13/kB2q8bl9DU4AxuF.png" alt="volta-node.png" /></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>angular-ng</title>
    <url>/posts/angular-ng/</url>
    <content><![CDATA[<h3 id="angualr"><a class="markdownIt-Anchor" href="#angualr"></a> Angualr</h3>
<p>组件模式 AMD</p>
<p>scope</p>
<h3 id="00"><a class="markdownIt-Anchor" href="#00"></a> 00</h3>
<blockquote>
<p>ng-app 指令表明这个 html 文件为 angular 模板文件解析</p>
</blockquote>
<p>使用 <code>ngApp</code> 指令自动引导 AngularJS 应用程序非常简单，并且适合大多数情况。在高级情况下，例如使用脚本加载器时，您可以使用命令/手动方式来引导应用程序。</p>
<ol>
<li>The <a href="https://docs.angularjs.org/api/auto/service/$injector">injector</a> that will be used for dependency injection is created.<br />
创建将用于依赖注入的注入器。</li>
<li>The injector will then create the <a href="https://docs.angularjs.org/api/ng/service/$rootScope">root scope</a> that will become the context for the model of our application.<br />
然后，注入器将创建根范围，该范围将成为我们应用程序模型的上下文。</li>
<li>AngularJS will then “compile” the DOM starting at the <code>ngApp</code> root element, processing any directives and bindings found along the way.<br />
然后，AngularJS 将从 <code>ngApp</code> 根元素开始“编译”DOM，处理沿途发现的任何指令和绑定。</li>
</ol>
<ul>
<li>Added phone images to <code>app/img/phones/</code>.<br />
将手机图像添加到 <code>app/img/phones/</code> 。</li>
<li>Added phone data files (JSON) to <code>app/phones/</code>.<br />
将电话数据文件 (JSON) 添加到 <code>app/phones/</code> 。</li>
</ul>
<h3 id="01-控制器"><a class="markdownIt-Anchor" href="#01-控制器"></a> 01 控制器</h3>
<p>简单理解就是在控制器中写页面处理逻辑</p>
<h3 id="02-组件"><a class="markdownIt-Anchor" href="#02-组件"></a> 02 组件</h3>
<p>​ 由于这种组合（模板 + 控制器）是一种常见且重复出现的模式，因此 AngularJS 提供了一种简单而简洁的方法将它们组合成可重用且独立的实体（称为组件）。此外，AngularJS 将为我们组件的每个实例创建一个所谓的隔离范围，这意味着没有原型继承，并且我们的组件没有影响应用程序其他部分的风险，反之亦然。</p>
<p>​ 事实上，人们可以将组件视为其更复杂、更冗长（但功能更强大）的同级指令（指令）的固执己见和精简版本，指令是 AngularJS 教授 HTML 新技巧的方式。您可以在开发人员指南的指令部分阅读有关它们的所有内容。</p>
<blockquote>
<p>海云项目还没用到 component，</p>
</blockquote>
<h3 id="04-分文件编写"><a class="markdownIt-Anchor" href="#04-分文件编写"></a> 04 分文件编写</h3>
<p>加载顺序</p>
<p><img src="https://s2.loli.net/2024/05/17/OlKUGzXMjqu8Wb6.png" alt="image-20240514172110622" /></p>
<blockquote>
<p>在分文件编写的时候发现模块加载顺序很重要</p>
</blockquote>
<h3 id="05-filter"><a class="markdownIt-Anchor" href="#05-filter"></a> 05 filter</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-2&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Sidebar content--&gt;</span></span><br><span class="line"></span><br><span class="line">      Search: <span class="tag">&lt;<span class="name">input</span> <span class="attr">ng-model</span>=<span class="string">&quot;$ctrl.query&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-10&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Body content--&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;phones&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">&quot;phone in $ctrl.phones | filter:$ctrl.query&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;phone.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;phone.snippet&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="06-双向数据绑定"><a class="markdownIt-Anchor" href="#06-双向数据绑定"></a> 06 双向数据绑定</h3>
<p>vue 的 v-model</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;$ctrl.test&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123;$ctrl.test&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="07-依赖注入"><a class="markdownIt-Anchor" href="#07-依赖注入"></a> 07 依赖注入</h3>
<p>DI subsystem</p>
<p>在控制器中使用“服务”</p>
<p>服务以<code>$</code> 开头，<code>$$</code>被认为是私有的</p>
<p>给某个 controller 注入内置<code>$http</code>服务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PhoneListController</span>(<span class="params">$http</span>) &#123;...&#125;</span><br><span class="line"><span class="title class_">PhoneListController</span>.<span class="property">$inject</span> = [<span class="string">&#x27;$http&#x27;</span>];</span><br><span class="line">...</span><br><span class="line">.<span class="title function_">component</span>(<span class="string">&#x27;phoneList&#x27;</span>, &#123;..., <span class="attr">controller</span>: <span class="title class_">PhoneListController</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>内联写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PhoneListController</span>(<span class="params">$http</span>) &#123;...&#125;</span><br><span class="line">...</span><br><span class="line">.<span class="title function_">component</span>(<span class="string">&#x27;phoneList&#x27;</span>, &#123;..., <span class="attr">controller</span>: [<span class="string">&#x27;$http&#x27;</span>, <span class="title class_">PhoneListController</span>]&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="08-templating-and-links"><a class="markdownIt-Anchor" href="#08-templating-and-links"></a> 08 templating and links</h3>
<p><code>ngSrc</code> 指令可防止浏览器向无效位置发出 HTTP 请求</p>
<h3 id="09-routing-and-mutiple-views"><a class="markdownIt-Anchor" href="#09-routing-and-mutiple-views"></a> 09 Routing and Mutiple Views</h3>
<p>Angular-route : <code>npm i angular-route</code></p>
<p>注入$routeProvider 提供路由服务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&quot;phonecatApp&quot;</span>).<span class="title function_">config</span>([</span><br><span class="line">  <span class="string">&quot;$routeProvider&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">config</span>(<span class="params">$routeProvider</span>) &#123;</span><br><span class="line">    $routeProvider</span><br><span class="line">      .<span class="title function_">when</span>(<span class="string">&quot;/phones&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&quot;&lt;phone-list&gt;&lt;/phone-list&gt;&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">when</span>(<span class="string">&quot;/phones/:phoneId&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&quot;&lt;phone-detail&gt;&lt;/phone-detail&gt;&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">otherwise</span>(<span class="string">&quot;/phones&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>配合 ng-view 指令 （类似 vuerouter 的<code>&lt;router-view/&gt;</code>）</p>
<p>AngularJS（默认情况下）使用 URL 的哈希部分（即哈希 ( <code>#</code> ) 符号后面的内容）来确定当前路由。除此之外，你还可以指定一个散列前缀（默认为 <code>!</code> ），它需要出现在散列符号之后，以便 AngularJS 将该值视为“AngularJS 路径”并处理它（例如例如，尝试将其与路线匹配）[Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>h</mi><mi>t</mi><mi>t</mi><mi>p</mi><mi>s</mi><mo>:</mo><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mi>d</mi><mi>o</mi><mi>c</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>o</mi><mi>r</mi><mi>g</mi><mi mathvariant="normal">/</mi><mi>g</mi><mi>u</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">location](https://docs.angularjs.org/guide/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">/</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">c</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord">/</span></span></span></span>location)</p>
<p><code>phoneDetail</code> 模块依赖于 <code>ngRoute</code> 模块来提供 <code>$routeParams</code> 对象，该对象在 <code>phoneDetail</code> 组件的控制器中使用。由于 <code>ngRoute</code> 也是主 <code>phonecatApp</code> 模块的依赖项，因此其服务和指令已在应用程序中的任何位置可用（包括 <code>phoneDetail</code> 组件）。</p>
<p><mark>始终明确子模块的依赖关系。不要依赖从父模块继承的依赖项（因为有一天该父模块可能不存在）。</mark></p>
<h3 id="11-自定义过滤器"><a class="markdownIt-Anchor" href="#11-自定义过滤器"></a> 11 自定义过滤器</h3>
<p>由于此过滤器是通用的（即它不特定于任何视图或组件），因此我们将其注册到 <code>core</code> 模块中，该模块包含“应用程序范围”功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line">// Define the `core` module</span><br><span class="line">angular.module(&#x27;core&#x27;, []);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">angular. module(&#x27;core&#x27;). filter(&#x27;checkmark&#x27;, function() &#123; return function(input)</span><br><span class="line">&#123; return input ? &#x27;\u2713&#x27; : &#x27;\u2718&#x27;; &#125;; &#125;);</span><br></pre></td></tr></table></figure>
<p>模版中直接使用 <code>&#123;&#123;  true | checkmark &#125;&#125;</code></p>
<h3 id="13-rest-和-定制服务"><a class="markdownIt-Anchor" href="#13-rest-和-定制服务"></a> 13 rest 和 定制服务</h3>
<p>使用 $resource 工厂来定义一个资源服务，这个服务可以用来与后端进行 RESTful 交互</p>
<h3 id="angulardirective-指令"><a class="markdownIt-Anchor" href="#angulardirective-指令"></a> angular.directive 指令</h3>
<p>在 AngularJS 中，restrict 属性用于指定指令可以在模板中以哪种方式使用。restrict 属性可以接受以下参数：</p>
<ol>
<li><strong>‘E’ (Element)</strong>：</li>
</ol>
<p>指令作为<strong>元素</strong>使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-directive&gt;&lt;/my-directive&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>‘A’ (Attribute)</strong>：</li>
</ol>
<p>指令作为属性使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div my-directive&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>‘C’ (Class)</strong>：</li>
</ol>
<p>指令作为类使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;my-directive&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>‘M’ (Comment)</strong>：</li>
</ol>
<p>指令作为注释使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- directive: my-directive --&gt;</span><br></pre></td></tr></table></figure>
<h3 id="组合使用"><a class="markdownIt-Anchor" href="#组合使用"></a> 组合使用</h3>
<p>可以组合使用多个参数，例如 ‘EA’ 表示指令可以作为元素和属性使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.directive(&#x27;myDirective&#x27;, function() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">​    restrict: &#x27;EA&#x27;,</span><br><span class="line">​   // 其他配置</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="angularfactory"><a class="markdownIt-Anchor" href="#angularfactory"></a> angular.factory</h3>
<p><code>.factory</code> 是一个常用的方式来创建并返回一个服务的单例。<code>.factory</code> 方法用于封装业务逻辑或 API 服务，并在整个应用中共享。</p>
]]></content>
  </entry>
  <entry>
    <title>btoa-atob</title>
    <url>/posts/btoa-atob/</url>
    <content><![CDATA[<p>今天在找登录token发先存于Cookie的access_token被加密成ASCII字符串，遂找到了两个window下的api</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// base64Encryption</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">encryptToken</span>(<span class="params">token</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> encryptedToken = <span class="title function_">btoa</span>(token)</span><br><span class="line">  <span class="keyword">return</span> encryptedToken</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">decryptToken</span>(<span class="params">encryptedToken</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> decryptedToken = <span class="title function_">atob</span>(encryptedToken)</span><br><span class="line">  <span class="keyword">return</span> decryptedToken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Binary To ASCII</strong></p>
<p><strong><code>btoa()</code></strong> 方法可以将一个<em>二进制字符串</em>（例如，将字符串中的每一个字节都视为一个二进制数据字节）编码为 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Base64">Base64</a> 编码的 ASCII 字符串。</p>
<p>**ASCII To Binary **</p>
<p><strong><code>atob()</code></strong> 对经过 base-64 编码的字符串进行解码</p>
<p><img src="https://s2.loli.net/2024/02/19/6sy4PoWhdcw5BXJ.png" alt="bta atob" /></p>
]]></content>
      <tags>
        <tag>new found</tag>
      </tags>
  </entry>
  <entry>
    <title>computed与watch</title>
    <url>/posts/computed%E4%B8%8Ewatch/</url>
    <content><![CDATA[<h3 id="计算属性computed"><a class="markdownIt-Anchor" href="#计算属性computed"></a> <strong>计算属性computed</strong></h3>
<p>​	<u>适合用在模板渲染中，某个值是<strong>依赖了其它的响应式对象</strong>甚至是<strong>计算属性</strong>计算而来</u></p>
<ul>
<li><font color=red>支持缓存</font>，只有依赖数据发生改变，才会重新进行计算</li>
<li><mark>不支持异步</mark>，当computed内有异步操作时无效，无法监听数据的变化</li>
<li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li>
<li>如果computed属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个<code>get</code>和一个<code>set</code>方法，当数据变化时，调用set方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;计算属性示例&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;原始数据: &#123;&#123; originalData &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;计算属性: &#123;&#123; computedProperty &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;updateData&quot;&gt;更新数据&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      originalData: 5</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    computedProperty() &#123;</span><br><span class="line">      // 计算属性，依赖于原始数据</span><br><span class="line">      return this.originalData * 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateData() &#123;</span><br><span class="line">      // 更新原始数据，会触发计算属性重新计算</span><br><span class="line">      this.originalData += 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="侦听属性watch"><a class="markdownIt-Anchor" href="#侦听属性watch"></a> 侦听属性watch</h3>
<p>​	<u>适用于观测某个值的变化去<strong>完成一段复杂的业务逻辑</strong>（例如执行异步或开销较大的操作）</u></p>
<ul>
<li><font color=red>不支持缓存</font>，数据变，直接会触发相应的操作；</li>
<li>watch<mark>支持异步</mark>；</li>
<li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li>
<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>
<li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：新值和旧值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;监听的数据: &#123;&#123; watchedData &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;changeData&quot;&gt;改变数据&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      watchedData: &#x27;初始值&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeData() &#123;</span><br><span class="line">      this.watchedData = &#x27;新值&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    watchedData(newVal, oldVal) &#123;</span><br><span class="line">      // 在数据变化时触发的操作</span><br><span class="line">      console.log(&#x27;新值：&#x27;, newVal);</span><br><span class="line">      console.log(&#x27;旧值：&#x27;, oldVal);</span><br><span class="line">      // 这里可以执行您想要的其他操作</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>HTTP summary</title>
    <url>/posts/http/</url>
    <content><![CDATA[<h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> <mark>HTTP</mark></h2>
<p><strong>Hyper Text Transfer Protocol</strong></p>
<img src="https://s2.loli.net/2023/09/08/7HasE3ePGXuqtYn.png" alt="image-20230908155626605" style="width:50%;" />
<ul>
<li><strong style="color:red;">Stateless</strong> : every Request is <strong>INDEPENDENT</strong>
<ul>
<li>regard each request as a single transaction</li>
<li>use <code>cookie</code>  <code>session</code> <code>localStorage</code> … to enhance user experience( <u>memorize the state from the user</u> )</li>
</ul>
</li>
</ul>
<h2 id="https"><a class="markdownIt-Anchor" href="#https"></a> <mark>HTTPS</mark></h2>
<p><strong>Hyper Text Transfer Protocol <u>Secure</u></strong></p>
<ul>
<li>Data sent is <strong>encrypt</strong>
<ul>
<li><strong>SSL</strong> – Secure Sockets Layer</li>
<li><strong>TLS</strong> –  Transfer Layer Security</li>
</ul>
</li>
<li>install certificate on web host to use HTTPs</li>
</ul>
<h2 id="message"><a class="markdownIt-Anchor" href="#message"></a> Message</h2>
<img src="https://s2.loli.net/2023/09/08/u6OS2icBACHrtFf.png" alt="image-20230908164003822" style="width:50%;" />
<h3 id="headers"><a class="markdownIt-Anchor" href="#headers"></a> Headers</h3>
<ul>
<li>General
<ul>
<li>Request URL、Request Method、Status Code、Remote Address、Referrer Policy</li>
</ul>
</li>
<li>Request
<ul>
<li>Cookies、Accept-xxx、Content-Type、Content-Length、Auhurization、User-Agent、Referrer</li>
</ul>
</li>
<li>Response
<ul>
<li>Server、Set-Cookie、Content-Type、Content-Length、Date</li>
</ul>
</li>
</ul>
<h2 id="status-code"><a class="markdownIt-Anchor" href="#status-code"></a> Status Code</h2>
<table>
<thead>
<tr>
<th>Status Code</th>
<th>Means</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>request received / processing</td>
</tr>
<tr>
<td>2xx</td>
<td>Success received, understood, accepted</td>
</tr>
<tr>
<td>3xx</td>
<td>Further action must be taken / redirect</td>
</tr>
<tr>
<td>4xx</td>
<td>Client error</td>
</tr>
<tr>
<td>5xx</td>
<td>Server error</td>
</tr>
</tbody>
</table>
<ul>
<li>200 - OK</li>
<li>201 - OK created</li>
<li>301 - Move to new URL</li>
<li>304 - Not Modified (Cached version)</li>
<li>400 - Bad Request （❌ not sending correct data）</li>
<li>401 - Unauthorized （missing token）</li>
<li>404 - Not Found (resources do not exsist)</li>
<li>500 - Internal Server Error</li>
</ul>
<h2 id="http2"><a class="markdownIt-Anchor" href="#http2"></a> HTTP2</h2>
<p><code>multiplexing</code></p>
<img src="https://s2.loli.net/2023/09/08/sf8H6glXiCnzEA2.png" alt="image-20230908164925817" style="width:50%;" />
]]></content>
      <tags>
        <tag>Computer Network</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>js红宝书</title>
    <url>/posts/js%E7%BA%A2%E5%AE%9D%E4%B9%A6/</url>
    <content><![CDATA[<h3 id="script标签"><a class="markdownIt-Anchor" href="#script标签"></a> <code>&lt;script&gt;</code>标签</h3>
<ul>
<li>
<p>一些属性</p>
<ul>
<li>defer 推迟</li>
<li>async 异步  期间不要动DOM</li>
<li>intergrity 检查安全</li>
</ul>
</li>
<li>
<p>src GET 跨域</p>
</li>
<li>
<p>引入外部文件文件，行内代码写了没用</p>
</li>
</ul>
<blockquote>
<p>MIME 代码块中的脚本语言内容类型</p>
</blockquote>
<ul>
<li><code>&lt;noscript&gt;&lt;/noscript&gt;</code></li>
</ul>
<h3 id="严格模式es5增加"><a class="markdownIt-Anchor" href="#严格模式es5增加"></a> 严格模式（ES5增加）</h3>
<p>遵守的是es3的语法</p>
<p>开启严格模式，脚本开头写上<code>&quot;use strict&quot;;</code> ，也可写在函数内部开头，单独开启严格模式</p>
<h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3>
<p>​	<code>var</code>变量提升hoist ，函数作用域,全局声明成为window对象属性</p>
<p>​	<code>let</code>，块级作用域，暂存性死区（temporal dead zone)</p>
<p>​	<code>let</code>和<code>var</code> 只是指出变量在相关作用域如何让存在</p>
<p>​	<code>const</code> 适用于for-in(对象属性名)、for-of（数组）</p>
<h5 id="声明风格"><a class="markdownIt-Anchor" href="#声明风格"></a> 声明风格</h5>
<p>​		不使用<code>var</code>，<code> const</code>优先，<code>let</code>次之</p>
<h3 id="34-数据类型"><a class="markdownIt-Anchor" href="#34-数据类型"></a> 3.4 数据类型</h3>
<p>​	<strong>Undefined、Null、Boolean、Number、String、Symbol、Object</strong></p>
<p>​	<strong>typeof 操作符</strong></p>
<p>​		typeof null =&gt; onject (null被认为是空对象的引用)</p>
<p>​	<strong>Number</strong><br />
​		八进制: 0111 在严格模式下报错、0o111可以</p>
<p>​		<code>1.</code> 和 1.0 为整数，1.1、1.2浮点数</p>
<p>​		ES会将小数点后至少包括<u>6个0</u>的浮点值转换成科学计数法</p>
<p>​	<strong>String</strong></p>
<p>​		ECMAScript中的字符串是<strong>不可变的immutable</strong></p>
<p>​		<code>toString</code>  返回自身的一个副本</p>
<p>​			除了<font color=red><code>null</code></font> 和<font color=red> <code>undefined</code></font>都有<code>toString</code>方法。对于数值类型可以传参(转换<u>进制数</u>)</p>
<p>​		对于变量未知类型的，转为字符串，利用**<code>String()</code>转型函数**</p>
<p>​		<strong>模板字面量 ``</strong></p>
<p>​			保留换行字符，跨行定义字符串</p>
<p>​			字符串插值 ``${js表达式}` ，调用了toString方法强制转换为字符串</p>
<p>​			标签函数<code>(模板字面量隔开形成的字符串数组，...模板字面量的值)</code></p>
<p>​			原始字符串<code>String.raw</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`\u00A9`</span>) <span class="comment">//© (输出转义后的符号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property">raw</span><span class="string">`\u00A9`</span>) <span class="comment">//\u00A9 (输出原始的字符串</span></span><br></pre></td></tr></table></figure>
<p>​		<strong>Symbol</strong></p>
<p>​			在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同</p>
<p>​			全局符号：</p>
<p>​				symbol.for()执行幂等操作，第一次操作会检查全局运行时注册表，是否存在对应的symbol.for()</p>
<p>​				查询全局注册表<code>Symbol.keyFor(参数)</code>  (参数必须为symbol类型，否则抛出typeError)</p>
<p>​					查询成功返回symbol值，否则返回undefined</p>
<p>​			作为对象<code>[属性]</code>使用</p>
<p>​				defineProperty添加symbol类的值作为属性（在node下不能）</p>
<p>​			内置符号（不可写，不可枚举，不可配置）</p>
<p>​				<code>Symbol.iterator</code> for-of循环会使用这个属性</p>
<p>​				<code>Symbol.asyncIterator</code> for-await-of使用，异步迭代器</p>
<p>​				<code>Symbol.hasInstance</code>定义在Function的原型身上</p>
<p>​				<code>Symbol.isConcatSpreadable</code>（默认值undefined） <strong>控制Array.prorotype.concat是否“打平”连接</strong></p>
<p>​					对于数组对象(默认打平），设置为falsely变量，不会打平连接，会让整个对象追加到数组末尾</p>
<p>​					对于类数组对象（默认不打平），设置为truely变变量，会打平连接，到数组实例</p>
<p>​			<strong>Object</strong></p>
<p>​				ECMAScript只要求给构造函数提供参数时使用括号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span> <span class="comment">//合法，但不推荐</span></span><br></pre></td></tr></table></figure>
<p>​				<code>hasOwnProperty</code></p>
<p>​				<code>valueof()</code> 定义在对象里的方法。 return的值，</p>
<p>​						显示获取：<code>obj.valueOf()</code></p>
<p>​						隐式获取：<code>++obj </code> 对obj进行<strong>数学运算</strong>，直接调用的<code>valueOf()</code>方法</p>
<h3 id="35-操作符"><a class="markdownIt-Anchor" href="#35-操作符"></a> 3.5 操作符</h3>
<p>​	一元操作符</p>
<p>​		自增、自减、+、-</p>
<p>​			<code>+</code> 拼接字符串，<code>-</code> 先<code>Number()</code>转换，在减法操作</p>
<p>​	位操作符</p>
<p>​		ECMAScript 数值 以IEEE 745 64位格式存储</p>
<p>​		位操作，将值转为32位整数，再进行操作，最后再把结果转为64位</p>
<p>········</p>
<h3 id="36-语句"><a class="markdownIt-Anchor" href="#36-语句"></a> 3.6 语句</h3>
<p>​	<code>for-in</code> 严格迭代语句，遍历对象的<u>可枚举</u><u>非symbol类型</u>属性</p>
<p>​	<code>for-of</code> 严格迭代语句，遍历可迭代对象</p>
<p>​	标签语句 配合continue和break使用</p>
<p>​	<code>with</code>语句，将代码的作用域设定为特殊的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = process.<span class="property">pid</span></span><br><span class="line"><span class="keyword">const</span> b = process.<span class="property">ppid</span></span><br><span class="line"><span class="keyword">const</span> c = process.<span class="property">title</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="title function_">with</span>(<span class="params">process</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pid, ppid, title)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//严格模式不支持with，影响性能，难于调试，不推荐使用</span></span><br></pre></td></tr></table></figure>
<p>​	switch 全等操作符，不会强制转换类型</p>
<h2 id="第四章-变量-作用域与内存"><a class="markdownIt-Anchor" href="#第四章-变量-作用域与内存"></a> 第四章 变量、作用域与内存</h2>
<h3 id="41-原始值与引用值"><a class="markdownIt-Anchor" href="#41-原始值与引用值"></a> 4.1 原始值与引用值</h3>
<p>​	原始值（基础数据类型值）</p>
<p>​	引用值，保存在内存中的对象</p>
<p>​	ECMAScript函数参数传递是<strong>按值传递</strong>，（传递的是值的副本而非值本身）</p>
<p>​	确定类型：</p>
<p>​		<strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p>
<p>​		<code>typeof</code>…etc</p>
<h3 id="42-执行上下文与作用域"><a class="markdownIt-Anchor" href="#42-执行上下文与作用域"></a> 4.2 执行上下文与作用域</h3>
<p>​	<code>var</code>的函数作用域声明：变量会添加到<strong>最近的上下文</strong>，<em>作用域提升</em></p>
<p>​	<code>with</code>语句中var声明的变量为在<strong>全局</strong>作用域中</p>
<p>​	<code>let</code>、<code>const</code>  {}块级作用域</p>
<blockquote>
<p>使用<code>const</code>变量有助于JS引擎(谷歌V8引擎)优化，<strong>编译时</strong>就将所有实例替换成<strong>实际的值</strong>，而不会通过查询表进行变量查找</p>
</blockquote>
<p>​	标识符查找：沿作用域链查找</p>
<h3 id="43-垃圾回收️"><a class="markdownIt-Anchor" href="#43-垃圾回收️"></a> 4.3 垃圾回收♻️</h3>
<p>​	基本思路：确定那个变量不会再使用，然后释放他占用的空间。（<strong>周期性自动运行</strong>）</p>
<p>​	主要标记策略</p>
<p>​		<strong>标记清理</strong>：</p>
<p>​			标记内存中的所有变量 ➡️ 去掉上下文或者上下文引用的变量的标记 ➡️ （这时候再被加上标记的变量就是待删除的了，任何上下文的变量都访问不到它们了）回收</p>
<pre><code>	**引用计数**(❗️导致循环引用)
</code></pre>
<p>​			变量声明并赋引用值，引用数为1；</p>
<p>​			如果同一个值又被赋值给另一个，引用数+1；</p>
<p>​			该引用值被其他值覆盖，则引用数-1。</p>
<p>​			当引用值为0时，就会被垃圾回收</p>
<p>​	将变量设为<code>null</code>，切断变量与其之前引用值之间的关系。</p>
<p>​	<strong>性能</strong>：</p>
<p>​		现代垃圾回收程序根据<strong>运行时的环境</strong>来决定何时运行（以前IE是达到设定的阈值，就执行回收）</p>
<p>​		也有浏览器提供方法可以<u>主动触发垃圾回收</u>（❌）</p>
<p>​		提升性能：</p>
<p>​			使用<code>const let</code>声明变量：相对于函数作用域的<code>var</code>，块级作用域<strong>可能</strong>会更早终止，会让垃圾回收程序接介入，尽早回收内存</p>
<p>​			隐藏类和删除操作<code>delete</code></p>
<p>​				V8引擎将JS<strong>代码</strong>编译成实际的<strong>机器码</strong>会利用”隐藏类”，<strong style="color:red">能够共享隐藏类的对象性能更高</strong></p>
<p>​					<strong>动态<font color=blue>添加、删除</font>属性导致不共享一个隐藏类</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;iam foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个实例共用一个相同的隐藏类，因为两个实例共享一个共同的构造函数</span></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//‼️但是如此修改（这种操作的频率和隐藏类的大小对性能产生明显影响</span></span><br><span class="line">f2.<span class="property">name</span> = <span class="string">&#x27;iamf2&#x27;</span><span class="comment">//Foo实例对应两个 不同 的隐藏类。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//✅解决方案： 先创建再补充</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样对应相同的隐藏类</span></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;iamf1&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//‼️但是，使用delete关键字动态删除属性导致，不再共享一个隐藏类</span></span><br><span class="line"><span class="keyword">delete</span> f1.<span class="property">name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//✅解决方案 把不想要的属性设置为null</span></span><br><span class="line">f1.<span class="property">name</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>​		内存泄漏</p>
<p>​			意外声明全局变量</p>
<p>​			定时器回调引用外部变量</p>
<p>​			使用闭包</p>
<p>​		<strong>静态分配与对象池</strong></p>
<h2 id="第五章-基本引用类型"><a class="markdownIt-Anchor" href="#第五章-基本引用类型"></a> 第五章 基本引用类型</h2>
<h3 id="51-date"><a class="markdownIt-Anchor" href="#51-date"></a> 5.1 Date</h3>
<blockquote>
<p>UTC 协调世界时 GMT格林威治平时</p>
</blockquote>
<p>​</p>
<p>​	<code>Date.parse(创建的是本地日期)</code>  <code>Date.UTC(创建的是GMT日期)</code>  将一个表示日期的字符串解析为对应的时间戳（毫秒数）</p>
<p>​	new Date(传入时间字符串) ，根据字符串格式隐式调用上面两个构造函数</p>
<p>​	Date类重写了toLocaleString toString valueOf(返回时间戳)</p>
<h3 id="52-正则"><a class="markdownIt-Anchor" href="#52-正则"></a> ❓5.2 正则</h3>
<h3 id="53-原始值包装类型"><a class="markdownIt-Anchor" href="#53-原始值包装类型"></a> 5.3 原始值包装类型</h3>
<blockquote>
<p>ECMAScript提供了3种特殊的引用类型，<code>Boolean</code> <code>String</code> <code>Number</code></p>
</blockquote>
<p>​	正常来说原始值本身不是对象，按逻辑上不应该有方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;some text&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="title function_">substring</span>(<span class="number">2</span>)) <span class="comment">//me text</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>包装类型让原始值拥有对象行为</p>
<p>​	创建一个String类型实例</p>
<p>​	调用实例上的方法</p>
<p>​	销毁实例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示创建原始值包装类型(不推荐)</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;i am a string&#x27;</span>)<span class="comment">//构造函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s) <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;i am a string&#x27;</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s) <span class="comment">//string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="title class_">String</span>(<span class="string">&#x27;i am a string&#x27;</span>) <span class="comment">//转型函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s) <span class="comment">//string</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object工厂方法创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> os = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&#x27;i am a string&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建的是一个String实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> os, os <span class="keyword">instanceof</span> <span class="title class_">String</span>)<span class="comment">// object true</span></span><br></pre></td></tr></table></figure>
<h4 id="number"><a class="markdownIt-Anchor" href="#number"></a> number</h4>
<p>​		toFixed方法，返回的字符串保留几位小数（0~20位+，超过，四舍五入）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">2</span>))<span class="comment">//10.00</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="number">10.005</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>))<span class="comment">//10.01</span></span><br></pre></td></tr></table></figure>
<p>​	toPrecision返回最合理的数值(1-21小数位)</p>
<h4 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h4>
<p>​	JS 一个字符16位</p>
<p>​	与模式匹配相关的方法: match search replace split</p>
<h3 id="54-单例内置对象"><a class="markdownIt-Anchor" href="#54-单例内置对象"></a> 5.4 单例内置对象</h3>
<h4 id="global"><a class="markdownIt-Anchor" href="#global"></a> Global</h4>
<p>​	eval函数（⛔️XSS攻击）</p>
<p>​		这个函数就是个完整的ECMAScript解释器</p>
<p>​		定义在eval函数中的变量和函数，不存在函数提升</p>
<p>​		开启严格模式够，外部访问不到eval函数里的数据</p>
<h3 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h3>
<h2 id="第六章-集合引用类型"><a class="markdownIt-Anchor" href="#第六章-集合引用类型"></a> 第六章 集合引用类型</h2>
<h3 id="61-object"><a class="markdownIt-Anchor" href="#61-object"></a> 6.1 Object</h3>
<p>​	字面量{}形式创建一个对象，并不会new Object()</p>
<h3 id="62-array"><a class="markdownIt-Anchor" href="#62-array"></a> 6.2 Array</h3>
<p>​	字面量[]形式创建一个数组，也不会new Array()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20</span>) <span class="comment">//定义数组长度为20</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Array.from()</td>
<td>将<strong>伪数组</strong>转为真数组</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Array.of()</td>
<td>将一系列参数转为数组</td>
<td><code>Array.of( 1, 2, 3)</code> ➡️ [1, 2, 3]</td>
</tr>
</tbody>
</table>
<h4 id="数组空位"><a class="markdownIt-Anchor" href="#数组空位"></a> 数组空位</h4>
<p>​		字面量一串<strong>逗号形式</strong>创建空位</p>
<p>​			<img src="JS红宝书.assets/image-20230616144658231.png" alt="image-20230616144658231" style="zoom:50%;" /></p>
<p>​		ES6新增的方法和迭代器，将空位当成存在的元素，值为<code>undefined</code></p>
<p>​			<img src="JS红宝书.assets/image-20230616145322099.png" alt="image-20230616145322099" style="zoom:50%;" /></p>
<p>​		ES6之前的方法， 忽略空位（具体的行为因方法而异）</p>
<p>​			<code>map</code>跳过空位，<code>join</code>将空位视为空字符串</p>
<p>​		<img src="JS红宝书.assets/image-20230616145451935.png" alt="image-20230616145451935" style="zoom:50%;" /></p>
<h4 id="数组索引"><a class="markdownIt-Anchor" href="#数组索引"></a> 数组索引</h4>
<p>​		<font color=red>数组的length不是只读的</font>，利用这个特性删除数组末尾元素（当然也可添加数组空位）</p>
<p>​		<img src="JS红宝书.assets/image-20230616145938663.png" alt="image-20230616145938663" style="zoom:50%;" /></p>
<h4 id="检测数组"><a class="markdownIt-Anchor" href="#检测数组"></a> 检测数组</h4>
<p>​		在一个全局上下文中，使用<code>instanceof</code>。</p>
<blockquote>
<p>多个 iframe多个全局上下文。然后每个里面都有 Array 这个对象。他们并不相等。</p>
<p>本质来讲 <code>instanceof</code> 是去找 prototype 之类的，看看是否有继承。</p>
</blockquote>
<p>​		<strong><code>Array.isArray()</code></strong></p>
<h4 id="迭代器方法"><a class="markdownIt-Anchor" href="#迭代器方法"></a> 迭代器方法</h4>
<p>​		<code>arr.keys()</code> 返回数组索引的迭代器</p>
<p>​		<code>values() </code>返回数组元素的迭代器</p>
<p>​		<code>entries()</code> 返回 索引/值 对的迭代器</p>
<p>​	<em><strong><u>alert期待字符串</u></strong></em></p>
<h4 id="排序方法"><a class="markdownIt-Anchor" href="#排序方法"></a> <strong>排序方法</strong></h4>
<p>​		<code>sort</code> ，事先对数组中的没项元素都使用的<code>String转型函数</code></p>
<p>​			升序：compare(val1, val2) val1 &gt; val2 return 1</p>
<p>​			降序：compare(val1, val2) val1 &gt; val2 return -1</p>
<h4 id="操作方法"><a class="markdownIt-Anchor" href="#操作方法"></a> 操作方法</h4>
<p>​	<code>concat</code> <code>splice</code></p>
<h4 id="搜索方法"><a class="markdownIt-Anchor" href="#搜索方法"></a> 搜索方法</h4>
<p>​	<code>indexof</code> <code>lastIndexOf</code> <code>includes</code></p>
<p>​	<code>find</code> <code>findIndex</code></p>
<h4 id="迭代方法"><a class="markdownIt-Anchor" href="#迭代方法"></a> 迭代方法</h4>
<p>​	<code>every</code> <code>some</code></p>
<p>​	<code>filter</code> <code>map</code> <code>forEach</code></p>
<h4 id="归并方法"><a class="markdownIt-Anchor" href="#归并方法"></a> 归并方法</h4>
<p><code>reduce</code> <code>reduceRight</code></p>
<h3 id="63-定型数组"><a class="markdownIt-Anchor" href="#63-定型数组"></a> 6.3 定型数组</h3>
<h3 id="64-map-set"><a class="markdownIt-Anchor" href="#64-map-set"></a> 6.4 Map Set</h3>
<p>​	定义时都接受一个可迭代对象初始化映射</p>
<p>​	使用<code>forEach</code>，<code>for-of</code>迭代值</p>
<h3 id="65-weakmap-weakset"><a class="markdownIt-Anchor" href="#65-weakmap-weakset"></a> 6.5 weakMap weakSet</h3>
<blockquote>
<p>​	weakMap存储键值对的<strong>键</strong>必须为引用类型数据</p>
</blockquote>
<p>如果键的指向为空，自动称为垃圾回收的目标</p>
<p>weakMap实现真正的私有变量</p>
<p>都不可迭代值</p>
<h3 id="68-迭代与扩展操作"><a class="markdownIt-Anchor" href="#68-迭代与扩展操作"></a> 6.8 迭代与扩展操作</h3>
<p>​	定义的默认迭代器（<code>Array</code> <code>定型数组</code> <code>Map</code> <code>Set</code>）</p>
<p>​	支持for-of顺序迭代、兼容扩展操作符</p>
<blockquote>
<p>浅复制：只会复制对象的引用</p>
</blockquote>
<h2 id="第七章-迭代器与生成器"><a class="markdownIt-Anchor" href="#第七章-迭代器与生成器"></a> 第七章 迭代器与生成器</h2>
<p>​	迭代：按顺序反复执行一段程序</p>
<p>​	循环是迭代的基础</p>
<h3 id="迭代器模式"><a class="markdownIt-Anchor" href="#迭代器模式"></a> 迭代器模式</h3>
<p>​	开发者无需知道如何迭代就能实现迭代操作</p>
<p>​	实现可迭代iterable接口的对象，都能被事件iterator接口的结构消费</p>
<p>​	<strong>内置iterable接口的类型：<code>Stirng</code> <code>Array </code> <code>Map</code> <code>Set</code> <code>arguments对象</code> <code>NodeList等DOM集合类型</code></strong></p>
<p>​	<strong>接受可迭代对象的原生语言特性</strong></p>
<p>​		<code>for-of </code> <code>数组解构</code> <code>扩展操作符</code></p>
<p>​		<code>Array.from</code> <code>new Set/Map</code></p>
<p>​		<code>Promise.all / race</code> <code>yeild*操作符</code></p>
<p><em>给对象添加可迭代的iterable接口，</em></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">list</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> &#123; length &#125; = <span class="variable language_">this</span>.<span class="property">list</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: count === length ? <span class="literal">true</span> : <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">list</span>[count++] &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">          	<span class="comment">//提前终止，调用return方法</span></span><br><span class="line">          	<span class="keyword">return</span>() &#123;</span><br><span class="line">            	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exiting Early!&#x27;</span>)</span><br><span class="line">           	 	<span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">         	 	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收迭代器实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iter = obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()) <span class="comment">//调用next方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不同迭代器实例之间没有联系</p>
<p>迭代器不与对象某时刻的快照绑定，也可根据实际情况动态变化</p>
<p>迭代器维护一个指向可迭代对象的引用，⛔️<strong>阻止</strong>垃圾回收可迭代对象</p>
</blockquote>
<h4 id="提前终止迭代器"><a class="markdownIt-Anchor" href="#提前终止迭代器"></a> <strong>提前终止迭代器</strong></h4>
<p>​	如上<code>return</code>方法指定迭代器提前关闭时执行的逻辑</p>
<p>​		<strong>for-of 循环 在 break continue return throw时，触发提前终止逻辑</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="keyword">if</span>(val === <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Exiting Early!</span></span><br></pre></td></tr></table></figure>
<p>​		 <strong>解构操作并未消费所有的值时</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [item1, item2] = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item1, item2)</span><br><span class="line"><span class="comment">// Exiting Early!</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果迭代器没有关闭，可以从上次离开的地方继续迭代（数组的迭代器不能关闭）</p>
<p>return() 方法是可选的</p>
<p>仅仅给一个不可关闭的迭代器器增加一个return方法并不能让他关闭。调用return方法并不会强制迭代器进入关闭状态。</p>
</blockquote>
<h3 id="生成器模式"><a class="markdownIt-Anchor" href="#生成器模式"></a> 生成器模式</h3>
<blockquote>
<p>临时的可迭代对象称为生成器</p>
</blockquote>
<p>​	生成器拥有在<u>函数块</u>内<strong>暂停</strong>和<strong>恢复代码</strong>执行的能力 <font color=gray>可以用于自定义迭代器和实现协程</font></p>
<h4 id="定义生成器"><a class="markdownIt-Anchor" href="#定义生成器"></a> 💬定义生成器</h4>
<p>​	函数名前加『 *』，箭头函数不可用于定义生成器函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="comment">//函数表达式方式 对象方法 类方法 类静态方法。。。</span></span><br></pre></td></tr></table></figure>
<p>​	调用生成器函数产生生成器对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g)<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<div style="text-align:center; padding: 0 100px; overflow: hidden;">
  <div style="float: left; font-weight: bold;">开始暂时处于暂停执行状态，生成器对象也实现了iterator接口，具有next方法</div>
  <img src="JS红宝书.assets/image-20230617162726562.png" alt="image-20230617162726562" style="zoom:50%; display:block; float: right;" />
</div>
<p>初次调用next()方法指明开始调用生成器</p>
<p>value属性是生成器返回值，默认undefined</p>
<h4 id="yeild中断执行"><a class="markdownIt-Anchor" href="#yeild中断执行"></a> 🛑yeild中断执行</h4>
<p>yeild关键字只能在生成器函数中使用</p>
<h4 id="作为可迭代对象使用"><a class="markdownIt-Anchor" href="#作为可迭代对象使用"></a> 作为可迭代对象使用</h4>
<p>生成器显示调用next方法用处不大。</p>
<p>将生成器对象作为可迭代对象使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">genneratorFn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> <span class="title function_">genneratorFn</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="yeild实现输入输出"><a class="markdownIt-Anchor" href="#yeild实现输入输出"></a> yeild实现输入输出</h4>
<p>yeild产出的值传给g.next()</p>
<p>g.next()传入的参数，作为是yeild的返回值</p>
<h4 id="产生可迭代对象"><a class="markdownIt-Anchor" href="#产生可迭代对象"></a> 产生可迭代对象</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">yeild *[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>yeild* 其实也就是将可迭代对象序列化为一串可以单独产出的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genneratorFnA</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])&#123;</span><br><span class="line">        <span class="keyword">yield</span> val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价！！！</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">genneratorFnB</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="作为默认迭代器使用"><a class="markdownIt-Anchor" href="#作为默认迭代器使用"></a> ✅作为默认迭代器使用</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()&#123;</span><br><span class="line">        <span class="keyword">yield</span>* <span class="variable language_">this</span>.<span class="property">list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> val <span class="keyword">of</span> f)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提前终止生成器"><a class="markdownIt-Anchor" href="#提前终止生成器"></a> 提前终止生成器</h4>
<p><code>return() </code>强制生成器进入关闭状态</p>
<img src="JS红宝书.assets/image-20230617170419253.png" alt="image-20230617170419253" style="zoom:50%;" />
<p><code>throw()</code> 将一个错误注入到生成器中</p>
<table>
<thead>
<tr>
<th>如果生成器没处理这个错误，生成器会closed</th>
<th>生成器内部处理了这个错误生成器就不会关闭，而且会恢复执行<br />（只是跳过了这个值）</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="JS红宝书.assets/image-20230617170721610.png" alt="image-20230617170721610" style="zoom:50%;" /></td>
<td><img src="JS红宝书.assets/image-20230617171023335.png" alt="image-20230617171023335" style="zoom:50%;" /></td>
</tr>
</tbody>
</table>
<h2 id="第八章-对象-类与面向对象编程"><a class="markdownIt-Anchor" href="#第八章-对象-类与面向对象编程"></a> 第八章 对象、类与面向对象编程</h2>
<h3 id="81-对象"><a class="markdownIt-Anchor" href="#81-对象"></a> 8.1 对象</h3>
<h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4>
<p>​	构造函数、字面量形式</p>
<h4 id="对象属性"><a class="markdownIt-Anchor" href="#对象属性"></a> 对象属性</h4>
<h5 id="数据属性默认都为true"><a class="markdownIt-Anchor" href="#数据属性默认都为true"></a> 数据属性（默认都为true)</h5>
<table>
<thead>
<tr>
<th style="text-align:left"><code>Configurable</code></th>
<th><span style="font-weight: normal;">属性可由delete删除</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>Enumerable</code></strong></td>
<td>是否可由<code>for-in</code>枚举</td>
</tr>
<tr>
<td style="text-align:left"><strong><code> Writable</code></strong></td>
<td>是否可被修改</td>
</tr>
<tr>
<td style="text-align:left"><strong><code> Value</code></strong></td>
<td>包含实际值，默认undefined</td>
</tr>
</tbody>
</table>
<p>​	<strong>使用<code>Object.defineProperty</code>对对象属性属性修改（不配置值，默认为fasle）</strong></p>
<img src="JS红宝书.assets/image-20230617174454670.png" alt="image-20230617174454670" style="zoom:50%;" />
<p>(严格模式下： 尝试对configurable: false; witable: false；的值修改，会抛出错误。)</p>
<p>不能对同一个属性，定义多次Object.defineProperty()</p>
<h5 id="访问器属性"><a class="markdownIt-Anchor" href="#访问器属性"></a> 访问器属性</h5>
<p><code>getter</code> <code> setter</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="attr">_name</span>: <span class="string">&#x27;levy_init&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;尝试修改name&#x27;</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_name</span> = newVal</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">        <span class="attr">_name</span>: <span class="string">&#x27;levyy&#x27;</span>,</span><br><span class="line">        <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;尝试修改name&#x27;</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_name</span> = newVal</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>Object.defineProperties</code> 对一个对象的多个属性一次性进行描述符规定</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">_name</span>: <span class="string">&#x27;levy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">21</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="读取属性特性"><a class="markdownIt-Anchor" href="#读取属性特性"></a> 读取属性特性</h4>
<p>​	读取对象某一个： <code>Object.getOwnProperty(obj, 'aProperty')</code></p>
<p>​	读取对象全部属性的特性：<code>Object.getOwnProperties(obj)</code> //其实也是对每个属性调用了上面的方法，在一个新对象返回</p>
<h4 id="合并对象混入"><a class="markdownIt-Anchor" href="#合并对象混入"></a> 合并对象（混入）</h4>
<p><code>Object.assign()</code>浅复制，只复制可枚举(PropertyIsEnumerable)、自身(hasOwnPropery)属性</p>
<p>不复制属性的getter setter</p>
<blockquote>
<p>没有回滚之前赋值的状态，尽力赋值</p>
</blockquote>
<h4 id="相等判断"><a class="markdownIt-Anchor" href="#相等判断"></a> 相等判断</h4>
<p><code>Object.is()</code></p>
<img src="JS红宝书.assets/image-20230617185929270.png" alt="image-20230617185929270" style="zoom:50%;float:left;" />
<h4 id="增强语法"><a class="markdownIt-Anchor" href="#增强语法"></a> 增强语法</h4>
<p>属性值简写、可计算属性、方法简写、对象解构</p>
<h3 id="82-创建对象"><a class="markdownIt-Anchor" href="#82-创建对象"></a> 8.2 创建对象</h3>
<blockquote>
<p>ES6 Class Extends也是基于ES5原型链继承的语法糖</p>
</blockquote>
<h4 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">//显式创建对象</span></span><br><span class="line">    o.<span class="property">name</span> = name</span><br><span class="line">    o.<span class="property">age</span> = age</span><br><span class="line">    o.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o <span class="comment">//return 对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">createPerson</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h4 id="构造函数模式"><a class="markdownIt-Anchor" href="#构造函数模式"></a> 构造函数模式</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>new操作符</p>
<ol>
<li>内存中创建一个新对象</li>
<li>这个新对象的内部的[[Prototype]]属性赋值为构造函数的prototype属性</li>
<li>构造函数内部的this被赋值为这个新对象（this指向新对象）</li>
<li>执行构造函数内部代码（给新对象添加属性）</li>
<li>如果构造函数返回<strong>非空对象</strong>，则返回该对象；否则，返回刚创建的对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myNew</span> = (<span class="params">constructor, ...args</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">    o.<span class="property">__proto__</span> = constructor.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    <span class="keyword">const</span> res = constructor.<span class="title function_">apply</span>(o, args)</span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? res : o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​	构造函数如果不传参可以不用写括号</p>
<h5 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h5>
<p>​	不同实例上的方法不是同一个，方法都是做同样的事，没必要定义两个不同的Function实例。</p>
<p>​	解决可以把方法定义在构造函数外部，构造函数内部方法直接引用</p>
<h4 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式"></a> 原型模式</h4>
<p>在构造函数原型定义的属性方法可以被实例共享</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;小小&#x27;</span></span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>, p.<span class="property">sayName</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化写法：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小小&#x27;</span>,</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="title class_">Person</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span> <span class="comment">//原生constructor不可枚举，用这种方式定义</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>isPrototypeOf 检查原型</code> 原型链</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(p) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><code>Object.getPrototypeOf()</code> 获取原型对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>更改原型对象</strong></p>
<p>​	<code>Object.setPrototypeOf()</code> 影响性能</p>
<p>​	<code>Object.create</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(a, b)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(a) === b) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span> === b) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title class_">Object</span>.<span class="title function_">create</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(c) === a)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">__proto__</span> === a)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>实例可以通过原型链查找属性</p>
<p>确定属性在自身还是是原型链上的 <code>hasOwnProperty()</code></p>
<p><code>in</code> 操作符是在自身以及原型链上查找</p>
<p><code>Object.keys()</code> 遍历实例可枚举属性</p>
<p><code>Object.getOwnPropertyNames()</code> 遍历实例无论是否可枚举属性（除了Symbol ）</p>
<p><code>Object.getOwnPropertySymbols()</code></p>
<p>遍历顺序</p>
<p>for-in Object.keys() 无序</p>
<h4 id="对象迭代"><a class="markdownIt-Anchor" href="#对象迭代"></a> 对象迭代</h4>
<p><code>Object.values() </code> <code>Object.entries() </code></p>
<p>浅复制对象、不迭代Symbol</p>
<h3 id="83-继承"><a class="markdownIt-Anchor" href="#83-继承"></a> 8.3 继承</h3>
<p><a href="https://juejin.cn/post/6844903696111763470">参考掘金</a></p>
<h4 id="原型链继承"><a class="markdownIt-Anchor" href="#原型链继承"></a> 原型链继承</h4>
<p>每个构造函数有一个<font color=red>原型</font>对象prototype， 这个<font color=red>原型</font>对象有个属性constructor指向构造函数本身。</p>
<p>而这个构造函数实例有一个内部指针<code>__proto__</code>，指向这个<font color=red>原型</font></p>
<p>那如果这个原型是另一个类型的实例，就意味着这和<font color=red>原型</font>本身有个指针指向<font color=blue>另一个原型</font>，相应另一个原型也有个指针指向另一个构造函数。</p>
<p>这样形成了实例与原型之前的<strong>原型链</strong></p>
<h4 id="盗用构造函数"><a class="markdownIt-Anchor" href="#盗用构造函数"></a> 盗用构造函数</h4>
<h4 id="组合继承"><a class="markdownIt-Anchor" href="#组合继承"></a> 组合继承</h4>
<h4 id="原型式继承"><a class="markdownIt-Anchor" href="#原型式继承"></a> 原型式继承</h4>
<h4 id="寄生式继承"><a class="markdownIt-Anchor" href="#寄生式继承"></a> 寄生式继承</h4>
<h4 id="寄生组合继承"><a class="markdownIt-Anchor" href="#寄生组合继承"></a> 寄生组合继承</h4>
<p>寄生式继承父类原型，然后将返回的对象赋值给子类原型</p>
<h4 id="混入式继承"><a class="markdownIt-Anchor" href="#混入式继承"></a> 混入式继承</h4>
<h4 id="class-继承"><a class="markdownIt-Anchor" href="#class-继承"></a> Class 继承</h4>
<h3 id="84-类"><a class="markdownIt-Anchor" href="#84-类"></a> 8.4 类</h3>
<p>定义方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Foo</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Foo1</span> = <span class="keyword">class</span> <span class="title class_">FooName</span>&#123; <span class="comment">//表达式类名FooName可选</span></span><br><span class="line">        <span class="title function_">identify</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo1</span>.<span class="property">name</span> ,<span class="title class_">Foo2</span>.<span class="property">name</span>) <span class="comment">//name字段获取类名</span></span><br><span class="line">          	<span class="comment">// class后定义了类名就是指定类名FooName，否则类名就是Foo1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>类是一种特殊的函数<code>typeof</code>，但是并不会有作用域提升</p>
<p>类声明受块级作用域影响，而函数生命则受函数作用域影响</p>
<h4 id="constructor构造函数"><a class="markdownIt-Anchor" href="#constructor构造函数"></a> <code>constructor</code>构造函数</h4>
<p>构造函数默认返回this，<strong>构造函数返回的对象用作实例化的对象</strong></p>
<p>如果这个构造函数返回的不是this对象，而是其他对象，那么通过<code>instanceof</code>操作符不会检测出这个对象与这个类有关。</p>
<blockquote>
<p>因为在<code>new</code>操作时，会自动绑定this，如果</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">override</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (override) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo1 <span class="keyword">instanceof</span> <span class="title class_">Foo</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> foo2 = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo2 <span class="keyword">instanceof</span> <span class="title class_">Foo</span>)<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>类中定义的方法成为原型方法</p>
<p><strong><em>类块</em>中定义的方法都会定义在类的原型上</strong></p>
<p>静态类方法</p>
<p>迭代器、生成器</p>
<h4 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h4>
<p><code>extends</code> 继承一个类或者一个普通的构造函数</p>
<p>super只能在<strong>派生类构造函数和静态方法</strong>中使用</p>
<p>调用super()函数会调用父类构造函数，并将返回的实例赋值给this</p>
<p>给父类传参，super()手动传参</p>
<p>在类构造函数中不能在super()之前调用this</p>
<p>在派生类中显示定义了构造函数，必须要调用super或者返回一个对象</p>
<h4 id="抽象基类"><a class="markdownIt-Anchor" href="#抽象基类"></a> 抽象基类</h4>
<p>供其它类继承，却不被实例化</p>
<p>利用new.target实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>) <span class="comment">//返回Foo类</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Foo</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Foo 不能直接被实例化&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>() <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<h2 id="第九章-代理与反射"><a class="markdownIt-Anchor" href="#第九章-代理与反射"></a> 第九章 代理与反射</h2>
<h3 id="91-代理"><a class="markdownIt-Anchor" href="#91-代理"></a> 9.1 代理</h3>
<p>用作目标对象的替身，但独立于对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handlerObj) <span class="comment">//参数两者缺一不可</span></span><br></pre></td></tr></table></figure>
<p><code>Proxy.proptotype</code> 为undefined，所以不能使用<code>instanceof</code>操作符</p>
<p><code>===</code>严格相等可以用来区分代理和目标</p>
<h4 id="捕获器"><a class="markdownIt-Anchor" href="#捕获器"></a> 捕获器</h4>
<p><code>get</code></p>
<p>​	接受参数（目标对象，要查询的属性，代理对象)</p>
<p>重建被捕获的原始行为：</p>
<p>使用捕获器，被代理的属性如果同时not Configurable and not Writable，则TypeError报错</p>
<blockquote>
<p>反射API Reflect</p>
<p>delete函数属性—&gt;Refelect.deleteProperty</p>
<p>name in obj —&gt; Reflect.has(obj, ‘name’)</p>
</blockquote>
<p>可撤销代理</p>
<p><strong>撤销函数</strong>和<strong>代理对象</strong>是同时在实例化时生成的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构 代理对象和撤回函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; =<span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;1234&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>)<span class="comment">//1234</span></span><br><span class="line"><span class="title function_">revoke</span>() <span class="comment">//撤销代理</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy)<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<h4 id="实用反射reflect-api"><a class="markdownIt-Anchor" href="#实用反射reflect-api"></a> 实用反射Reflect API</h4>
<p>反射API不局限于捕获程序处理</p>
<p>代替Object上的方法（错误必须try catch捕获 到 反射API返回布尔值）</p>
<blockquote>
<p>反射方法return 的值称为“状态标记”的布尔值</p>
</blockquote>
<p>代替一些操作符</p>
<table>
<thead>
<tr>
<th>Reflect.</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>in</td>
</tr>
<tr>
<td>set</td>
<td>= 赋值操作符</td>
</tr>
<tr>
<td>has</td>
<td>in 或者 with()</td>
</tr>
<tr>
<td>deleteProperty</td>
<td>delete</td>
</tr>
<tr>
<td>Construct</td>
<td>new</td>
</tr>
</tbody>
</table>
<p>使用<code>Reflect.apply</code>调用函数(被调用函数，this指向，[实参…])</p>
<h4 id="构建多层拦截网"><a class="markdownIt-Anchor" href="#构建多层拦截网"></a> 构建多层拦截网</h4>
<p>​	代理另一个代理</p>
<h4 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h4>
<p>一种编程模式</p>
<h5 id="跟踪属性访问"><a class="markdownIt-Anchor" href="#跟踪属性访问"></a> 跟踪属性访问</h5>
<h5 id="隐藏属性"><a class="markdownIt-Anchor" href="#隐藏属性"></a> 隐藏属性</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">TrapTarget, property</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hiddenProperties.<span class="title function_">includes</span>(property))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">has</span>(<span class="params">target, property</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hiddenProperties.<span class="title function_">includes</span>(property))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">age</span>) <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> proxy) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sex&#x27;</span> <span class="keyword">in</span> proxy)<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h5 id="属性验证"><a class="markdownIt-Anchor" href="#属性验证"></a> 属性验证</h5>
<p>​	赋值操作触发<code>set</code>，根据情况决定赋值</p>
<h5 id="函数与构造函数参数验证"><a class="markdownIt-Anchor" href="#函数与构造函数参数验证"></a> 函数与构造函数参数验证</h5>
<h5 id="数据绑定和可观察对象"><a class="markdownIt-Anchor" href="#数据绑定和可观察对象"></a> 数据绑定和可观察对象</h5>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs</title>
    <url>/posts/nodejs/</url>
    <content><![CDATA[<h1 id="pre"><a class="markdownIt-Anchor" href="#pre"></a> pre</h1>
<ol>
<li><strong>运行时（Runtime)</strong><br />
&quot;运行时&quot;就是程序运行的时候，也就是<strong>指令加载到内存并由CPU执行</strong>的时候。</li>
</ol>
<p>与之相对应的是“编译时”，其指代码编译的时候，也就是C代码编译成可执行文件的时候，此时指令没有被CPU执行。</p>
<ol start="2">
<li>
<p><strong>运行时库（Runtime Library）</strong><br />
运行时库就是程序运行的时候所需要依赖的库。</p>
</li>
<li>
<p><strong>运行时环境（Runtime environment）</strong><br />
运行环境（英语：Runtime environment）又称“运行时系统”（run-time system），指一种把半编译的运行码在目标机器上运行的环境。</p>
</li>
</ol>
<hr />
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>Nodejs 只是一个js<strong>运行时环境</strong></p>
<p>访问系统内核，访问本地文件，链接服务器…</p>
<p>nodejs在<strong>浏览器之外</strong>运行<strong>v8引擎</strong></p>
<p><strong>跨平台</strong></p>
<p>适合干IO密集型应用，不适合CPU密集型（单线程）</p>
<blockquote>
<p>CPU 密集型： 图像、音频处理需要大量的数据结构+算法</p>
</blockquote>
<hr />
<h1 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h1>
<p>node <code>global</code></p>
<p>浏览器 <code>window</code></p>
<p><code>globalThis</code>根据环境自动判断</p>
<p>ECMAScript中有的全局，如Math…</p>
<ul>
<li>
<p><code>__dirname</code> 当前文件所在目录(绝对路径)</p>
</li>
<li>
<p><code>__filename</code> 当前文件路径（绝对路径）</p>
</li>
<li>
<p><code>__extname</code> 文件后缀</p>
</li>
<li>
<p><code>Buffer</code></p>
</li>
<li>
<p><code>process</code>  处理进程</p>
<ul>
<li><code>process.argv</code> 获取参数数组</li>
<li><code>process.cwd()</code> 目录</li>
<li><code>process.exit()</code> 终止进程</li>
<li><code>process.on('exit', ()=&gt;&#123;console.log('退出')&#125;)</code> 监听事件</li>
</ul>
</li>
</ul>
<hr />
<p><code>nodejs</code>应用在（<font color=red>长期运行!!</font><code>httpserver返回++counter</code>）<strong>单个进程</strong>中运行，无需为每个请求创建新的线程</p>
<p>（相比，Apache，每一个请求创建一个线程）</p>
<p>单线程，并发量为1</p>
<p>采用了<strong>非阻塞</strong>的开发范式（事件循环机制） + v8引擎加持，轻松应对<strong>高并发</strong></p>
<blockquote>
<p>主线程是单线程，io是libuv维护的线程池</p>
</blockquote>
<br/>
<p>当函数调用栈内有函数运行时，js不能处理其他请求</p>
<br/>
<p>异步模块（多线程）和事件循环（监听 派发，不占用单独线程）</p>
<p>循环不停监听异步模块处理进度，等处理完成后，派发函数调用栈执行</p>
<br/>  
<p>最快的速度清空函数调用栈，把耗时的操作全部做异步处理</p>
<p>node将【异步操作和对应的回调函数】封装成一个请求对象，交给底层的异步模块处理</p>
<p>异步操作有结果之后，回调函数进入事件循环等待执行，</p>
<p>事件循环在调用栈清空时，按照某个优先级顺序将回调函数推入到调用栈执行</p>
<hr />
<h1 id="node异步api"><a class="markdownIt-Anchor" href="#node异步api"></a> node异步API</h1>
<ol>
<li>定时器： <code>setTimeOut</code> <code> setInterval</code> （最小1ms，浏览器4ms）</li>
<li>I/O操作： 文件读写，数据库操作，网络请求</li>
<li>node独有的，<code>process.nextTick</code>、<code>setImmediate</code></li>
</ol>
<br/>
<blockquote>
<p>nextTick(<strong>优先级比事件循环队列更高</strong>)</p>
<p>微任务（promise）</p>
<p>timer</p>
<p>–&gt;poll（当执行到这里时卡住，检查timer或者check队列有误需要 执行的）</p>
<p>check</p>
</blockquote>
<p>Poll 阻塞，从设计上，是想优先处理IO事件的</p>
<p>Settimeout(,0)与setimmdeiate 放入io中使用，定时器，总会先执行check队列的操作</p>
<br/>
<blockquote>
<p>Timer -&gt; check运行一周称为一个<code>Tick</code></p>
<p>nextTick先于下一个Tick执行</p>
</blockquote>
<p><strong>异步代码进入异步模块以非阻塞的形式执行，对应的异步函数会在对应的异步代码执行完成后，派发到不同的队列中</strong></p>
<h2 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h2>
<p>为了健壮性：捕获并处理每一个错误</p>
<ul>
<li>
<p>同步代码 try catch</p>
</li>
<li>
<p>异步代码</p>
<ul>
<li>Promise (catch)</li>
<li>async await trycatch</li>
</ul>
</li>
</ul>
<h2 id="异步编程-流程控制"><a class="markdownIt-Anchor" href="#异步编程-流程控制"></a> 异步编程 流程控制</h2>
<p>回调函数 --&gt; Promise —&gt; async await</p>
<br/>
<p>node官方的库</p>
<p>遵循，错误优先风格</p>
<br/>
<p>回调函数，需要顺序执行，就要嵌套的写，但是导致回调地狱</p>
<br/>
<blockquote>
<p>平行</p>
<p>顺序</p>
</blockquote>
<h1 id="module"><a class="markdownIt-Anchor" href="#module"></a> module</h1>
<p>module并不是全局变量，每一个模块有他相应的模块</p>
<br/>
<p>核心模块（随着node）</p>
<p>第三方模块</p>
<p>自定义模块（引用路径）</p>
<br/>
<p>运行时加载 cmj，知道运行时候再报错</p>
<p>编译时加载 esm</p>
<p><code>import from</code> 写在模块顶层</p>
<p><code>import()</code> （异步，返回promise）</p>
<br/>
<p><code>V8</code></p>
<p>预编译阶段 （ESM</p>
<p>-分配内存空间</p>
<p>-确定作用域链…</p>
<p>执行阶段 （CMJ</p>
 <br/>
<hr />
<h1 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> Buffer</h1>
<p>js字符串不可变，所有对字符串的操作都要生成一个新的字符串</p>
<br/>
<p><code>fs</code>模块读取，不生命文件类型，默认返回的都是文件二进制缓冲区</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer1 = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">5</span>) <span class="comment">//申请五个字节</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer1.<span class="title function_">toString</span>())</span><br><span class="line">buffer1.<span class="title function_">write</span>(<span class="string">&#x27;string&#x27;</span>) <span class="comment">//多写入的部分不会写入</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer1, buffer1.<span class="title function_">toString</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;a string&#x27;</span>))</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="stream"><a class="markdownIt-Anchor" href="#stream"></a> stream</h1>
<p><img src="https://s2.loli.net/2023/09/03/JmQjx7fKbWprE1C.png" alt="image-20230601204439944.png" /></p>
<br/>
<p>i/o操作</p>
<p>端到端数据交换</p>
<br/>
<p>加载 缓冲区 处理</p>
<p>流模式 加载一点处理一点</p>
<br/>
<p><img src="https://s2.loli.net/2023/09/03/LGmBcjDfOF5giHV.png" alt="image-20230601204653589.png" /></p>
<br/>
<p><img src="https://s2.loli.net/2023/09/03/iLAFjDZa3q7Sxd5.png" alt="image-20230618200922252.png" /></p>
<hr />
<h1 id="seo"><a class="markdownIt-Anchor" href="#seo"></a> SEO</h1>
<ul>
<li>
<p>TDK</p>
<ul>
<li>title</li>
<li>description (meta)</li>
<li>Key(meta)</li>
</ul>
</li>
<li>
<p>语义化标签</p>
</li>
<li>
<p><code>&lt;a/&gt;</code> href</p>
</li>
<li>
<p><code>&lt;img/&gt;</code> href alt</p>
</li>
<li>
<p>一个页面一个h1 和 main标签</p>
</li>
<li>
<p>…</p>
</li>
</ul>
<p>借助第三方库jsdom（jsdom模拟浏览器环境的库，可以在 Node.js 中使用 DOM API），服务端渲染</p>
]]></content>
  </entry>
  <entry>
    <title>npm</title>
    <url>/posts/npm/</url>
    <content><![CDATA[<p><code>node package manager</code>  基于命令行的工具</p>
<p>安装、卸载、更新、发布</p>
<p><strong>version</strong> <strong>版本号x,y,z</strong></p>
<p>主 次 补丁</p>
<dl>
<dt>^ 锁定从左边数第一个非0的</dt>
<dd>锁定主版本or次版本</dd>
</dl>
<p>latest 最新版本</p>
<h1 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h1>
<p>dependecies</p>
<p>devDependencies 开发依赖</p>
<p>peerDependencies 对等依赖，（插件不能凭空运行，需要依赖某一模块）</p>
<h1 id="一些常用命令"><a class="markdownIt-Anchor" href="#一些常用命令"></a> 一些常用命令</h1>
<ul>
<li><code>npm config list</code> 查看npm配置信息</li>
</ul>
<img src="https://s2.loli.net/2023/09/02/cZmUGLrlnh74v9Y.png" alt="image-20230902172055264" style="width:50%;" />
<ul>
<li><code>npm get registry</code>  查看镜像源</li>
<li><code>npm set registry xxxx</code>设置镜像源</li>
<li><code>npm ls (-g)</code> 当前（全局）安装的可执行文件</li>
</ul>
<h1 id="npm-install-原理"><a class="markdownIt-Anchor" href="#npm-install-原理"></a> npm install 原理</h1>
<p>安装依赖存放于根目录<code>node_modules</code>文件夹</p>
<p>排序: .bin @系列 abcd排序</p>
<p>广度优先，扁平化（理想情况下）处理下载</p>
<blockquote>
<p>非理想： node_modules下a b 模块依赖不同版本的c模块，会给b模块下再建立一个node_modules文件夹</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/09/02/ybEQgwSzVoL2kA3.png" alt="img" /></p>
<blockquote>
<p>pakage-lock.json</p>
<p>锁定版本号</p>
<p>缓存： intergrity + verion + name 生成唯一的key，这个key在缓存文件中,</p>
<p><code>npm config list</code> 查看中的cache</p>
<p>index-v5 索引目录，记录content-v2的索引位置，对应的 intergrity + verion + name由算法生成的哈希值</p>
<p>对应得上，就将这个加密的包解压到node_modules中</p>
</blockquote>
<table>
<thead>
<tr>
<th>pakage-lock.json pakage.json</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>不一致</td>
<td>按照pakage中的版本下载，并更新lock中的版本号</td>
</tr>
<tr>
<td>一直</td>
<td>先找缓存，没有再下载资源</td>
</tr>
</tbody>
</table>
<h1 id="npm-run"><a class="markdownIt-Anchor" href="#npm-run"></a> npm run</h1>
<p>可执行命令都存在node_modules下的<code>.bin</code>文件夹中</p>
<ol>
<li>
<p>当前项目node_modules/.bin 中查找</p>
</li>
<li>
<p>全局的node_modules查找</p>
</li>
<li>
<p>环境变量中查找</p>
</li>
<li>
<p>报错</p>
</li>
</ol>
<p>也是有生命周期的</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;predev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node 1.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node 2.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;postdev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node 3.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>运行 <code>npm run dev</code>, 自动执行了 1.js 2.js 3.js</p>
<blockquote>
<p>比如一个打包命令，之前可以做一个清理的任务，最后做一个发布的工作，比如写一个CI脚本顺便把代码提交了</p>
<p>Vue-cli也是用了生命周期pretest: ‘yarn clean’</p>
</blockquote>
<h1 id="npx"><a class="markdownIt-Anchor" href="#npx"></a> npx</h1>
<p>npm高版本自带的命令行工具</p>
<p><strong>运行node_modules/.bin 下的可执行文件</strong></p>
<blockquote>
<p>之前通过package.json 中的scripts 配合npm run实现，现在可通过npx运行不需要安装这个依赖包运行命令</p>
</blockquote>
<ul>
<li>
<p>避免全局安装</p>
<ul>
<li>当前项目node_modules/.bin —&gt; 全局modules/.bin —&gt; 官网下载，用完删除（需要联网），减少内存占用</li>
</ul>
</li>
<li>
<p>总是使用最新版本</p>
</li>
<li>
<p>执行任意npm包</p>
</li>
</ul>
<blockquote>
<p>在一个项目中，<code>npm i vite</code></p>
<p>没有全局安装，直接运行vite肯定是不行的，</p>
<p>此时配合npx， <code>npx vite</code> 在项目中的node_modules/.bin中查找运行</p>
</blockquote>
<h2 id="与npm区别"><a class="markdownIt-Anchor" href="#与npm区别"></a> 与npm区别</h2>
<p>npx侧重执行命令</p>
<p>npm侧重安装或卸载某个模块，不具备执行某个模块的功能</p>
<h1 id="发布npm包"><a class="markdownIt-Anchor" href="#发布npm包"></a> 发布npm包</h1>
<ul>
<li><code>npm addUser</code>（创建npm账号）</li>
<li><code>npm login</code> 登录( 使用<strong>官方的源</strong>，而不是第三方镜像源)</li>
<li><code>npm publish</code>  发布（同版本号不能重新发布，包名唯一）</li>
</ul>
<h1 id="构建npm私服"><a class="markdownIt-Anchor" href="#构建npm私服"></a> 构建npm私服</h1>
<ul>
<li>部署到内网集群，离线使用</li>
<li>安全性</li>
<li>提高包下载速度</li>
</ul>
<p>利用<code>verdaccio</code>库</p>
<img src="https://s2.loli.net/2023/09/02/PZQCziu4qrKAsRk.png" alt="image-20230902172055264" style="width:50%;" />
<ul>
<li><code>npm i verdaccio -g</code></li>
<li><code>verdaccio --listen 5000</code> 开启服务</li>
<li>发包流程与之前的差不多
<ul>
<li>
<img src="https://s2.loli.net/2023/09/02/zYhy9muZv8cWD3H.png" alt="image-20230902172055264" style="width:50%;" /></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>React小记</title>
    <url>/posts/react%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="react库和框架的区别是什么"><a class="markdownIt-Anchor" href="#react库和框架的区别是什么"></a> React库和框架的区别是什么？</h2>
<ul>
<li>页面组件化</li>
<li>数据驱动</li>
</ul>
<p>MVC V层</p>
<blockquote>
<p>react库</p>
<p>​	react.js是一个开放的js工具库，用于基于UI自检构建用户界面</p>
</blockquote>
<blockquote>
<p>react框架</p>
<p>​	通过脚手架工具搭建的一套完善的前端环境，包括：路由、状态管理、数据获取、第三方的UI组件库和第三方Hooks库(ahooks react-use)</p>
</blockquote>
<h2 id="严格模式"><a class="markdownIt-Anchor" href="#严格模式"></a> 严格模式</h2>
<p>​	检查组件是否为<strong>纯函数</strong></p>
<p>​	及早的发现useEffect中的错误</p>
<p>​	警告过时的API</p>
<h2 id="eslint"><a class="markdownIt-Anchor" href="#eslint"></a> ESLint</h2>
<p>​	代码规范插件</p>
<blockquote>
<p>npm run lint</p>
<p>vite-plugin-eslint （vite构建下）</p>
</blockquote>
<h2 id="prettier"><a class="markdownIt-Anchor" href="#prettier"></a> Prettier</h2>
<p>​	代码格式化插件</p>
<h2 id="react模块"><a class="markdownIt-Anchor" href="#react模块"></a> react模块</h2>
<p>​	核心功能</p>
<p>​	组件</p>
<h2 id="react-dom"><a class="markdownIt-Anchor" href="#react-dom"></a> react-dom</h2>
<p>​	操作浏览器DOM</p>
<p>​	<code>react-dom/client</code> 客户端渲染使用</p>
<p>​	<code>react-dom/server </code>服务端渲染使用</p>
<blockquote>
<p>分离不同代码库，可跨平台使用</p>
<p>比如 编写<code>react-native</code>应用，当然不用使用<code>react-dom</code>模块</p>
</blockquote>
<p>利用<strong>编译器</strong>编译成中间这种<code>reactElement</code>对象格式(虚拟DOM)，再利用<code>react-dom</code>库完成</p>
<p><img src="https://s2.loli.net/2023/07/25/cHAiE6MDN71R9pW.png" alt="image-20230719112407499.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/94UeQaLNsGli1JP.png" alt="image-20230719140934815.png" /></p>
<h2 id="fragment"><a class="markdownIt-Anchor" href="#fragment"></a> fragment</h2>
<p><code>&lt;&gt;&lt;/&gt;</code> 简写，这种方式不能写key</p>
<h2 id="classnames-控制样式"><a class="markdownIt-Anchor" href="#classnames-控制样式"></a> classnames 控制样式</h2>
<p><img src="https://s2.loli.net/2023/07/25/no2bQfZGqpJ3rz4.png" alt="image.png" /></p>
<h2 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h2>
<p>​	合成事件：处理事件有差异（onmouse<u>enter</u> 实际使用的是<u>over</u>）</p>
<p>​	事件委托：委托到容器’root’元素</p>
<p><img src="https://s2.loli.net/2023/07/25/4doOvBUxuV2z8fc.png" alt="image-20230719143026471.png" /></p>
<p>​	传参处理</p>
<p>​		箭头函数</p>
<p>​		高阶函数</p>
<h2 id="条件渲染"><a class="markdownIt-Anchor" href="#条件渲染"></a> 条件渲染</h2>
<p>​	条件分支if else switch case</p>
<p>​	三目 ? :</p>
<p>​	逻辑运算符 || ?? &amp;&amp;</p>
<blockquote>
<p>不会渲染的值：null、undefined、boolean、‘’ 、对象、函数</p>
<p>利用JSON.stringify() 或者 {undefied +‘’}(拼接空串)</p>
</blockquote>
<p>​</p>
<h2 id="数组渲染"><a class="markdownIt-Anchor" href="#数组渲染"></a> 数组渲染</h2>
<blockquote>
<p>​	<font color=red>jsx默认对数组进行join()操作</font></p>
</blockquote>
<p>​	循环语句</p>
<p>​	<img src="https://s2.loli.net/2023/07/25/Gc83QLyR5SVbFKW.png" alt="image-20230719144614400.png" /></p>
<p>​	数组方法（map）</p>
<blockquote>
<p>必须写key</p>
<p>帮助react推断发生了什么，从而得以正确的更新DOM树</p>
<p>跟踪列表每一项的身份， 唯一标识</p>
</blockquote>
<h2 id="组件的u点标记u写法"><a class="markdownIt-Anchor" href="#组件的u点标记u写法"></a> 组件的<u>点标记</u>写法</h2>
<h3 id="对象形式"><a class="markdownIt-Anchor" href="#对象形式"></a> 对象形式</h3>
<p>​		组件写为对象的方法</p>
<p>​		可解构使用</p>
<p><img src="https://s2.loli.net/2023/07/25/ZSJRGjxKWVdFlE9.png" alt="image-20230719145530569.png" /></p>
<h3 id="函数形式更好的进行组件分类"><a class="markdownIt-Anchor" href="#函数形式更好的进行组件分类"></a> 函数形式（更好的进行组件分类</h3>
<p>​	将组件直接挂载在上级组件上</p>
<p>​		<img src="https://s2.loli.net/2023/07/25/mMoLItqRXs6hyA5.png" alt="image-20230719145906028.png" /></p>
<h2 id="组件通信方式"><a class="markdownIt-Anchor" href="#组件通信方式"></a> 组件通信方式</h2>
<p>props传递值</p>
<p>​	整体接收， 解构接收</p>
<p>props传递事件</p>
<p>通过扩展运算符{…}批量上传</p>
<h2 id="组件组合方式"><a class="markdownIt-Anchor" href="#组件组合方式"></a> 组件组合方式</h2>
<blockquote>
<p>插槽</p>
</blockquote>
<p>利用props的children属性</p>
<p><img src="https://s2.loli.net/2023/07/25/fgLQPnTCZsOKjov.png" alt="image-20230719151126002.png" /></p>
<p>​	指定顺序</p>
<p><img src="https://s2.loli.net/2023/07/25/l326jsNfERpq4n8.png" alt="image-20230719151821461.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/35jOCBYAGLvbMSr.png" alt="image-20230719153233192.png" /></p>
<h2 id="props默认值"><a class="markdownIt-Anchor" href="#props默认值"></a> props默认值</h2>
<p>​	利用es6的默认值方式</p>
<p><img src="https://s2.loli.net/2023/07/25/35jOCBYAGLvbMSr.png" alt="image-20230719153233192.png" /></p>
<p>​	react的defaultProps</p>
<p><img src="https://s2.loli.net/2023/07/25/7Mbkav82tCNFzhP.png" alt="image-20230719153301244.png" /></p>
<h2 id="props类型限定"><a class="markdownIt-Anchor" href="#props类型限定"></a> props类型限定</h2>
<p>​	使用ts</p>
<p>​	使用第三方proptypes</p>
<h2 id="组件纯函数"><a class="markdownIt-Anchor" href="#组件纯函数"></a> 组件纯函数</h2>
<p>​	只负责自己的任务，不会在更改函数调用前就已存在的对象和变量。（不能修改这个函数组件作用域外的对象和变量）</p>
<blockquote>
<p>​	<strong>严格模式</strong>检测当前组件是否为纯函数，对这函数调用两次，检测值是否变化</p>
</blockquote>
<p>​	输入相同，则输出相同。纯函数总是返回相同的结果。</p>
<blockquote>
<p>​	不管调用多次，函数都输出同一个值，对于<strong>测试</strong>更方便。<strong>增强健壮性</strong></p>
</blockquote>
<h2 id="组件的状态"><a class="markdownIt-Anchor" href="#组件的状态"></a> 组件的状态</h2>
<p>瞬间变化的数据被称为状态（state），状态可以<strong>进行数据驱动</strong></p>
<p>useState hooks 提供 <u>状态</u> 和 <u>修改状态</u>的方法</p>
<p>​	普通变量 无法重新渲染JSX</p>
<p>​	state状态，重新触发函数组件，并且具备<strong>组件的<font color=red>记忆</font></strong>。</p>
<blockquote>
<p>​	普通纯函数函数， 多次调用执行结果</p>
</blockquote>
<h3 id="状态是如何改变视图的"><a class="markdownIt-Anchor" href="#状态是如何改变视图的"></a> 状态是如何改变视图的</h3>
<p>渲染与提交的过程</p>
<p>1️⃣触发一次渲染</p>
<p>​	💡组件的初次渲染，createRoot.render</p>
<p>​	🔦内部状态更新，触发渲染送入队列</p>
<p>2️⃣渲染您的组件</p>
<p>​	💡在进行初次渲染，react调用根组件<code>&lt;App/&gt;</code></p>
<p>​	🔦内部状态更新，会渲染对应的函数组件</p>
<p>3️⃣提交到DOM上</p>
<p>​	💡初次渲染，appendChild DOM API</p>
<p>​	🔦内部状态更新，更新差异的DOM节点</p>
<h3 id="多状态如何正确记忆"><a class="markdownIt-Anchor" href="#多状态如何正确记忆"></a> 多状态如何正确记忆？</h3>
<p>同一个组件的每次渲染中，useState都依托于一个稳定的调用顺序</p>
<p>在react内部，每个组件保存了一个数组， 按照索引记忆usestate位置。<code>[&#123;索引，useState对&#125;]</code></p>
<blockquote>
<p>所以不要将useState写到一些分支逻辑中，会打乱useState顺序</p>
</blockquote>
<p>配合eslint检查，语法是否合规</p>
<h3 id="状态的快照"><a class="markdownIt-Anchor" href="#状态的快照"></a> 状态的快照</h3>
<p>本次作用域中的状态不会改变</p>
<p><img src="https://s2.loli.net/2023/07/25/uh6UXZsLEilwmjY.png" alt="image-20230719163835286.png" /></p>
<p>点击后，触发三次setcount，但是当前作用域的count都为0</p>
<p>快照的陷阱，异步的时候造成错觉，其实异步逻辑中的状态还是依赖于这次函数作用域</p>
<p><img src="https://s2.loli.net/2023/07/25/65ayv4H7KrhLoli.png" alt="image-20230719164801330.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/9IhUgbs7ZVlW3Hz.png" alt="image-20230719165254304.png" /></p>
<blockquote>
<p>词法作用域，只看定义，不看调用</p>
</blockquote>
<h3 id="状态队列与自动批处理"><a class="markdownIt-Anchor" href="#状态队列与自动批处理"></a> 状态队列与自动批处理</h3>
<p>自动批处理</p>
<p>​	等事件处理函数中的所有代码都运行完毕再处理你的state更新</p>
<p>​	队列都执行完毕后，在进行ui更新</p>
<p>更新函数的写法</p>
<p><img src="https://s2.loli.net/2023/07/25/iCsuQxMSc71oygb.png" alt="image-20230719170017902.png" /></p>
<p>形参c来自于react内部，所以这里并不是保存的count快照，连续调用三次后，得到3</p>
<blockquote>
<p>更新函数在内部还是以回调的形式，但没使用形参</p>
</blockquote>
<h3 id="严格遵守状态不可变"><a class="markdownIt-Anchor" href="#严格遵守状态不可变"></a> 严格遵守状态不可变</h3>
<p><strong>默认</strong>情况下，修改的状态跟上一次相同的情况下，是不会重新触发渲染</p>
<h3 id="引用数据类型"><a class="markdownIt-Anchor" href="#引用数据类型"></a> 引用数据类型</h3>
<p>拷贝</p>
<p>​	数组，使用相关方法</p>
<p>​	扩展运算符</p>
<p>​	深克隆（将没改变的数据也是克隆了一份）</p>
<p>​	immer useimmer 可以直接对数据进行修改</p>
<h3 id="惰性初始化状态的值"><a class="markdownIt-Anchor" href="#惰性初始化状态的值"></a> 惰性初始化状态的值</h3>
<p>当状态的值组要通过复杂计算才能得到的话，可以对其进行惰性初始化</p>
<blockquote>
<p>只在初始化的时候执行一次</p>
</blockquote>
<h3 id="状态提升解决共享问题"><a class="markdownIt-Anchor" href="#状态提升解决共享问题"></a> 状态提升解决共享问题</h3>
<p>父组件管理状态，子组件props</p>
<h3 id="状态的重置处理问题"><a class="markdownIt-Anchor" href="#状态的重置处理问题"></a> 状态的重置处理问题</h3>
<p>当组件被销毁会时，所对应的状态也会被重置</p>
<p>当<strong>组件位置</strong>没有发生变化，状态会被保留</p>
<p><img src="https://s2.loli.net/2023/07/25/hZIvLofTXFxWDYz.gif" alt="状态重置1.gif" /></p>
<blockquote>
<p>组件渲染位置发生变化，状态不被保留</p>
<p><img src="https://s2.loli.net/2023/07/25/7rkxUmafhFbcqGS.gif" alt="状态-不同位置.gif" /></p>
</blockquote>
<p>不同的结构体，给组件添加<strong>key属性</strong></p>
<blockquote>
<p><font color=red>diff算法，同层级的元素是否发生改变</font></p>
</blockquote>
<h3 id="利用状态产生计算变量"><a class="markdownIt-Anchor" href="#利用状态产生计算变量"></a> 利用状态产生计算变量</h3>
<p>根据<strong>状态会重新渲染组件</strong>的特性，利用当前<strong>状态快照</strong>生成对应的计算变量</p>
<p><img src="https://s2.loli.net/2023/07/25/BQFsjgh3nrIdA6k.gif" alt="chrome-capture-2023-6-20.gif" /></p>
<h2 id="受控组件与非受控组件"><a class="markdownIt-Anchor" href="#受控组件与非受控组件"></a> 受控组件与非受控组件</h2>
<p>通过props控制的组件成为受控，通过state控制的组件称为非受控组件</p>
<p>react表单内置了受控组件的行为</p>
<p>​	value + onChange</p>
<p>​	checked + onChange</p>
<p>input标签并不是原始的标签</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          console.log(e.target.value);</span></span><br><span class="line"><span class="language-xml">          setValue(e.target.value)</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="hooks"><a class="markdownIt-Anchor" href="#hooks"></a> Hooks</h1>
<p>react中以use开头的函数被称为Hook钩子，Hooks被称为use函数的集合，也就是钩子的集合</p>
<p>Hooks就是一堆功能函数，（像插件</p>
<p>分为： 内置、自定义、第三方</p>
<h2 id="useref"><a class="markdownIt-Anchor" href="#useref"></a> useRef</h2>
<p>使用ref引用一个值，具备记忆功能</p>
<p>改变ref不会触发重新渲染组件</p>
<p><img src="https://s2.loli.net/2023/07/25/iyCeFSGRxWDZXlr.png" alt="image-20230720100818798.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/XSUFWpV4CJlBMT3.png" alt="image-20230720101032139.png" /></p>
<p>定时器案例：timer用ref存储，始终引用的同一个值</p>
<h3 id="useref进行dom操作"><a class="markdownIt-Anchor" href="#useref进行dom操作"></a> useref进行dom操作</h3>
<p>​	如：让元素获取焦点，滚动到他或测量尺寸位置</p>
<h3 id="回调写法在逻辑中操作dom"><a class="markdownIt-Anchor" href="#回调写法在逻辑中操作dom"></a> 回调写法，在逻辑中操作dom</h3>
<p><img src="https://s2.loli.net/2023/07/25/vtEOLCYA8DgBTfR.png" alt="image-20230720102321632.png" /></p>
<h3 id="forwardref"><a class="markdownIt-Anchor" href="#forwardref"></a> forwardRef</h3>
<p>给<strong>组件</strong>设置ref需要forwardRef<strong>转发</strong></p>
<p>forwardRef让您的组件通过ref向父组件公开DOM节点</p>
<p>直接转发ref给子组件报错</p>
<p><img src="https://s2.loli.net/2023/07/25/kVQnM81xyLu7oDC.png" alt="image-20230724150124791.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/B5Kh6kOrXaLWQdm.png" alt="image-20230724151308635.png" /></p>
<h3 id="useimperativehandle"><a class="markdownIt-Anchor" href="#useimperativehandle"></a> useImperativeHandle</h3>
<p>自定义由ref暴露出来的句柄</p>
<p><img src="https://s2.loli.net/2023/07/25/HSitNEdGyln4KzI.png" alt="image-20230724153237639.png" /></p>
<p><img src="https://s2.loli.net/2023/07/25/7h8YMuCK4WTOwyz.png" alt="image-20230724153456747.png" /></p>
<h2 id="纯函数处理useeffect"><a class="markdownIt-Anchor" href="#纯函数处理useeffect"></a> 纯函数处理useEffect</h2>
<p>纯函数：</p>
<p>副作用：</p>
<p>​	函数在执行过程中对外部造成的影响成为副作用，如ajax、dom操作、与外部系统同步</p>
<p>​	事件可以处理副作用，onclick事件等</p>
<p>​	处理副作用，借助useEffect钩子</p>
<p>useEffect触发时机，<strong>jsx渲染后触发</strong></p>
<p>依赖项，<a href="http://xn--Object-hs2j6622blval8d.is">内部通过Object.is</a>() 方法判定</p>
<p>​	当依赖项为空，指挥初始渲染</p>
<p>​	ESLint会检查依赖项是否正确，包括props state 计算变量</p>
<h3 id="函数写在useeffect中"><a class="markdownIt-Anchor" href="#函数写在useeffect中"></a> 函数写在useEffect中</h3>
<p>useCallback</p>
<p>函数始终是同一个</p>
<p>每次重新渲染函数，函数指向地址发生改变</p>
<h3 id="useeffect清理工作"><a class="markdownIt-Anchor" href="#useeffect清理工作"></a> useEffect清理工作</h3>
<p>严格模式，检测有无做清理工作</p>
<p>初始化数据时，注意清理操作，</p>
<p>​	更简洁的方法是使用第三方，ahooks的useRequest</p>
<h2 id="useeffectevent"><a class="markdownIt-Anchor" href="#useeffectevent"></a> useEffectEvent</h2>
<p><img src="https://s2.loli.net/2023/07/25/uKlfrvej4UA2OqJ.png" alt="image-20230724162726502.png" /></p>
<h2 id="uselayouteffect-同步执行状态更新"><a class="markdownIt-Anchor" href="#uselayouteffect-同步执行状态更新"></a> useLayoutEffect 同步执行状态更新</h2>
<p>useEffect是在渲染之后，更新之前</p>
<p>如过需要在useEffect中处理DOM，并且改变页面的样式，就需要使用useLayoutEffect，</p>
<h2 id="useinsertioneffect-dom更新前触发"><a class="markdownIt-Anchor" href="#useinsertioneffect-dom更新前触发"></a> useInsertionEffect DOM更新前触发</h2>
<p>此时拿不到dom元素</p>
<p>在css-in-js库中使用的多</p>
<h2 id="usereducer"><a class="markdownIt-Anchor" href="#usereducer"></a> useReducer</h2>
<p>局部的状态管理，抽离逻辑</p>
<h2 id="useimmerreducer"><a class="markdownIt-Anchor" href="#useimmerreducer"></a> useImmerReducer</h2>
<p>immer类型数据</p>
<h2 id="context向组件深层次传递数据"><a class="markdownIt-Anchor" href="#context向组件深层次传递数据"></a> Context向组件深层次传递数据</h2>
<blockquote>
<p>reducer配合context实现状态数据共享</p>
<p>更复杂的情况使用第三方库,redux mobx,zuster</p>
</blockquote>
<h2 id="memo在props不变时跳过重新渲染"><a class="markdownIt-Anchor" href="#memo在props不变时跳过重新渲染"></a> memo在props不变时跳过重新渲染</h2>
<p>达到一些性能优化</p>
<blockquote>
<p>props改变的情况下，会重新渲染组件</p>
</blockquote>
<p>没有props</p>
<p><img src="https://s2.loli.net/2023/07/25/Prz2fHX5ksuL71b.gif" alt="memo-props1.gif" /></p>
<p><img src="https://s2.loli.net/2023/07/25/bUIa1KeAVdiRzNg.gif" alt="memo-props2.gif" /></p>
<h2 id="usememo对计算结果进行缓存"><a class="markdownIt-Anchor" href="#usememo对计算结果进行缓存"></a> useMemo对计算结果进行缓存</h2>
<p>虽然使用memo，并且props <strong>数组list****值</strong>未变化，但是list的引用地址发生变化，底层使用<code>Object.is([], []) ==&gt;flase</code> 比较，则<strong>props值</strong>改变</p>
<p><img src="https://s2.loli.net/2023/07/25/G6FMPfQ1NcULiWZ.gif" alt="usememo1.gif" /></p>
<p>使用useMemo对计算数据进行缓存（类似useCallback缓存函数）</p>
<h2 id="usecallback对函数进行缓存"><a class="markdownIt-Anchor" href="#usecallback对函数进行缓存"></a> useCallback对函数进行缓存</h2>
<p>useMemo的一种特殊写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const fn = useMemo(()=&gt; () =&gt; &#123; console.log(1) &#125;)</span><br><span class="line">const fn = useCallback(() =&gt; &#123; console.log(1) &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="starttrasition-方法及并发模式"><a class="markdownIt-Anchor" href="#starttrasition-方法及并发模式"></a> StartTrasition 方法及并发模式</h2>
<p>​	react18开始，渲染是一个单一的、不间断的、同步的事务，一旦渲染开始，就不能被中断</p>
<pre><code>react18引入并发模式，允许标记更新作为一个transition，这回告诉react它们可以被中断执行。这样可以把紧急的任务先更新，不紧急的任务后更新
</code></pre>
<p><code>任务切换</code></p>
<h2 id="usetrasition-hook"><a class="markdownIt-Anchor" href="#usetrasition-hook"></a> useTrasition hook</h2>
<p>提供一个pending状态的布尔值，（配合实现一个loading效果），还有一个startTrasition方法</p>
<p><img src="https://s2.loli.net/2023/07/25/8l6byIz1rWvnd39.gif" alt="useTransition.gif" /></p>
<h2 id="usedeferredvalue-延迟"><a class="markdownIt-Anchor" href="#usedeferredvalue-延迟"></a> useDeferredValue 延迟</h2>
<p>获取该值的延迟版本</p>
<p><img src="https://s2.loli.net/2023/07/25/UoeJhxVuCiRt2DB.gif" alt="useDeferredValue.gif" /></p>
<h2 id="useid-产生唯一标识"><a class="markdownIt-Anchor" href="#useid-产生唯一标识"></a> useId 产生唯一标识</h2>
<p>id 局部前缀</p>
<p>​	xxx + id (字符串拼接)</p>
<p>id 全局前缀</p>
<p>​	createRoot 第二参</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)!, &#123;</span><br><span class="line">  <span class="attr">identifierPrefix</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="usedebugvalue"><a class="markdownIt-Anchor" href="#usedebugvalue"></a> useDebugValue</h2>
<p>在自定义hook中打印信息，devtool</p>
<h2 id="usesyncexternalstore"><a class="markdownIt-Anchor" href="#usesyncexternalstore"></a> useSyncExternalStore</h2>
<p>操作状态</p>
<p>订阅外部 store 的 React Hook。</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>redux-toolkit学习</title>
    <url>/posts/redux-toolkit%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="redux-toolkit"><a class="markdownIt-Anchor" href="#redux-toolkit"></a> Redux-Toolkit</h1>
<blockquote>
<p>摘自官网</p>
<p><strong><a href="https://redux-toolkit.js.org/">Redux Toolkit</a></strong> 是 Redux 官方强烈推荐，开箱即用的一个高效的 Redux 开发工具集。</p>
<p>简化最常见场景下的 Redux 开发，</p>
<p>​	包括配置 store、定义 reducer，不可变的更新逻辑</p>
<p>​	可以立即创建整个状态的 “切片 slice”，而<strong>无需手动编写任何 action creator 或者 action type</strong></p>
<p>自带了一些最常用的 Redux 插件，</p>
<p>​	例如用于异步逻辑 Redux Thunk，</p>
<p>​	用于编写选择器 selector 的函数 Reselect （可缓存select数据）</p>
</blockquote>
<p>在 Redux 中,**切片(Slice)**指的是使用 <strong>createSlice</strong> API 创建的 reducer 和 action 的组合。它是 Redux Toolkit 中的一个核心概念。</p>
<p>createSlice 接收一个配置对象参数,里面包含:</p>
<blockquote>
<ul>
<li>初始 state</li>
<li>reducers:包含不同 reducer 的对象</li>
<li>extraReducers:处理 action 的 reducer 函数</li>
</ul>
</blockquote>
<ul>
<li>切片让我们可以<strong>把 reducer 与 action 打包在一起</strong></li>
<li>创建<strong>简化</strong>了编写 <strong>reducer</strong> 的流程</li>
<li><strong>自动生成 action</strong> 类型</li>
</ul>
<p>⚙️ CRA新建一个react项目</p>
<p><code>create-react-app myapp --template typescript</code></p>
<p>⚙️ 安装react-redux react-toolkit</p>
<p><code>npm install @reduxjs/toolkit react-redux </code></p>
<table>
<thead>
<tr>
<th style="text-align:center">项目基本结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://s2.loli.net/2023/07/14/v4muItCeOgTFfaV.png" alt="image-20230714095149784.png" style="zoom:67%;" /></td>
</tr>
</tbody>
</table>
<ul>
<li>新建状态管理主文件</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&quot;./slice/counterSlice&quot;</span> <span class="comment">// 由切片导入的reducer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">    <span class="attr">reducer</span>: &#123;</span><br><span class="line">        <span class="attr">counter</span>: counterReducer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据store本身推断出推断 `RootState` 和 `AppDispatch`类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">RootState</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> store.<span class="property">getState</span>&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">AppDispatch</span> = <span class="keyword">typeof</span> store.<span class="property">dispatch</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在项目入口文件，给App组件<strong>注入store</strong></li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">&#x27;./redux/store&#x27;</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line">);</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>创建切片</li>
</ul>
<blockquote>
<p>之前利用 都要分别写各自actionCreator和各自的reducer， 现在只用一个切片即可管理</p>
</blockquote>
<p>😇 React Toolkit 创建的 Slice 状态state本身是 <code>immutable</code> 的，所以可以放心的直接加工使用</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/redux/slice/counterSlice.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PayloadAction</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ICounterState</span> &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">initialState</span>: <span class="title class_">ICounterState</span> = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建切片</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">    initialState,</span><br><span class="line">    <span class="attr">reducers</span>: &#123;</span><br><span class="line">        <span class="attr">increment</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">            state.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">decrement</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">            state.<span class="property">value</span> -= <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">incrementByAmount</span>: <span class="function">(<span class="params">state, action: PayloadAction&lt;<span class="built_in">number</span>&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">            state.<span class="property">value</span> += action.<span class="property">payload</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Action creators 会在各自的reducer函数中自动创建， 这里直接导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; increment, decrement, incrementByAmount &#125; = counterSlice.<span class="property">actions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 💡注意&gt; 默认导出的是reducer</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span></span><br></pre></td></tr></table></figure>
<ul>
<li>尝试在App.tsx组件中使用</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AppDispatch</span>, <span class="title class_">RootState</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./redux/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; decrement, increment, incrementByAmount &#125; <span class="keyword">from</span> <span class="string">&#x27;./redux/slice/counterSlice&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useSelector</span>(<span class="function">(<span class="params">state: RootState</span>) =&gt;</span> state.<span class="property">counter</span>.<span class="property">value</span>)</span><br><span class="line">  <span class="keyword">const</span> disptach = useDispatch&lt;<span class="title class_">AppDispatch</span>&gt;()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> disptach(increment())&#125;&gt;点击我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> disptach(decrement())&#125;&gt;点击我-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> disptach(incrementByAmount(100))&#125;&gt;点击我+100<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>✅成功</p>
<p><img src="https://s2.loli.net/2023/07/14/QKWlncjEVHUgGRN.gif" alt="屏幕录制2023-07-14-上午10.12.15" /></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora图床</title>
    <url>/posts/typora%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p>Llllllb, 购买了正版<code>Typora</code>之后，终于可以美美享受图床服务咯</p>
<p><strong>图床平台</strong>：<a href="https://sm.ms/">sm.ms</a> <strong>5.00 GB</strong>免费空间</p>
<p><strong>上传服务器</strong>：<a href="https://picgo.github.io/PicGo-Core-Doc/">PicGo</a></p>
<p>手把手步骤：</p>
<ul>
<li>
<p><strong><a href="http://sm.ms">sm.ms</a></strong></p>
<ul>
<li>注册</li>
<li>获取<code>Token</code>
<ul>
<li>
<img src="https://s2.loli.net/2024/02/17/yogM5hsDnjrlFG1.png" alt="smms-token" style="zoom: 33%; float: left;" />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>PicGo</strong></p>
<ul>
<li>全局下载 CLI：<code>yarn add global picgo</code></li>
<li>配置：<code>picgo set</code> 全部默认就行（图床选择 smms）</li>
<li>查看配置：macos 默认保存在<code>~/.picgo</code>目录下
<ul>
<li><code>vim ~/.picgo/config.json</code></li>
<li>
<img src="https://s2.loli.net/2024/02/17/8gfPF5wTAIytm4X.png" alt="picgo-config.json" style="zoom:20%; float: left" />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Typora</strong></p>
<ul>
<li>设置 &gt; 图像 &gt; 上传服务设置</li>
<li>
<img src="https://s2.loli.net/2024/02/17/SBaVRF3I6kLbP9f.png" alt="typora-picgo" style="zoom: 30%; float:left" />
</li>
</ul>
</li>
<li>
<p><strong>使用</strong></p>
<ul>
<li>
<img src="https://s2.loli.net/2024/02/17/xfaX5rnyosH6D7Y.gif" alt="erastour-loopy" style="zoom: 80%; float:left" />
</li>
</ul>
</li>
</ul>
<p><font style="margin-top: 1em; font-style: italic; font-weight: bold; color: red">OMG 你怎么知道我 3.8.2024 要去<mark>THE ERAS TOUR Singapore</mark></font></p>
]]></content>
      <tags>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3数据绑定之-sync</title>
    <url>/posts/vue3%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B9%8B-sync/</url>
    <content><![CDATA[<p><s><strong><font color=red>啊啊啊啊学了这么久vue3还不知道<code>sync</code>已经在vue3中被剔除了！！！</font></strong></s></p>
<p>在vue2中我们利用v-bind值给子组件，子组件props接受父组件传来的值</p>
<p><img src="https://s2.loli.net/2023/08/04/seqYNjUDltL2Avd.png" alt="image-20230804094605352.png" /></p>
<p><img src="https://s2.loli.net/2023/08/04/Quritsa3AmvLZH1.png" alt="" /></p>
<p>子组件想直接通过props修该父组件传来的值，是不被允许的，这违背了<strong>单项数据流</strong>的原则</p>
<p><img src="https://s2.loli.net/2023/08/04/bFmpQ6fGHYwAIrn.png" alt="" /></p>
<p>那要子组件想要修改父组件的值，需要通过<strong>自定义事件</strong></p>
<p>由父组件定义回调，子组件<code>emit</code>触发回调函数通知父组件修改改，（这里就不展开述说了）</p>
<hr />
<p>在vue2中提供了一个<code>v-bind</code>修饰符<code>.sync</code>，旨在传递一个值给子组件，而子组件可以更改这个值</p>
<p><img src="https://s2.loli.net/2023/08/04/SQyuDWsB5ZbaLP6.png" alt="" /></p>
<p><img src="https://s2.loli.net/2023/08/04/P4WCG5B71k9q6cR.gif" alt="" /></p>
<p>而在vue3中这个sync被v-model替代了</p>
<blockquote>
<p>传递给子组件的，vmodel绑定的这个值一定得是响应式的</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/08/04/tegdIJlGUPpxYmV.png" alt="" /></p>
<p><img src="https://s2.loli.net/2023/08/04/yoMnjfHrslQcXFv.gif" alt="" /></p>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化 + webpack打包</title>
    <url>/posts/webpack/</url>
    <content><![CDATA[<p>「模块化」是思想</p>
<p><img src="https://s2.loli.net/2023/05/08/cqUElmXNyaRPnsG.png" alt="内容概要" /></p>
<h2 id="模块化的演变过程"><a class="markdownIt-Anchor" href="#模块化的演变过程"></a> <mark>模块化的演变过程</mark></h2>
<blockquote>
<p>都是依靠script标签加载模块，不能代码控制加载</p>
</blockquote>
<ol>
<li>
<h4 id="文件划分方式全靠约定"><a class="markdownIt-Anchor" href="#文件划分方式全靠约定"></a> 文件划分方式（全靠约定）</h4>
<p>每一个文件是一个独立模块，存入的状态数据和功能函数</p>
<p>script src引用</p>
<p>使用函数和全局变量</p>
</li>
</ol>
<p>缺点： 污染全局变量、命名冲突、管理模块之前依赖关系</p>
<ol start="2">
<li>
<h4 id="命名空间方式"><a class="markdownIt-Anchor" href="#命名空间方式"></a> 命名空间方式</h4>
<p>将每个模块封装到一个<u>对象</u>中，依靠name属性命名模块</p>
</li>
</ol>
<p>缺点：没有私有空间，可以在外被修改、依赖关系</p>
<ol start="3">
<li>
<h4 id="iife"><a class="markdownIt-Anchor" href="#iife"></a> IIFE</h4>
<p>将模块用<u>IIFE封装</u>，将所需要暴露的数据挂载在<u>全局对象window…</u>上</p>
</li>
</ol>
<p>​	  通过闭包的方式，私有变量、参数传递，依赖关系（Jquery $）</p>
<h2 id="模块化规范"><a class="markdownIt-Anchor" href="#模块化规范"></a> <mark>模块化规范</mark></h2>
<h3 id="模块化规范的出现"><a class="markdownIt-Anchor" href="#模块化规范的出现"></a> 模块化规范的出现</h3>
<h4 id="commonjs"><a class="markdownIt-Anchor" href="#commonjs"></a> CommonJS</h4>
<blockquote>
<p>node提出</p>
<p>同步加载</p>
</blockquote>
<ul>
<li>一个文件就是一个模块</li>
<li>每个模块都是有一个单独的作用域</li>
<li>通过module.exports导出模块、require函数载入模块</li>
</ul>
<h4 id="amdasynchronous-module-definition-异步模块定义规范"><a class="markdownIt-Anchor" href="#amdasynchronous-module-definition-异步模块定义规范"></a> AMD(Asynchronous Module Definition) 异步模块定义规范</h4>
<blockquote>
<p>社区提出</p>
<p>Require.js实现了AMD规范</p>
<p>模块加载器</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义一个模块 */</span></span><br><span class="line"><span class="comment">// 参数 定义模块名、引用依赖文件、函数（依赖文件导出的成员）</span></span><br><span class="line"><span class="title function_">define</span>(<span class="string">&#x27;muduleName&#x27;</span>,[<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;./moduleA&#x27;</span>],<span class="keyword">function</span>(<span class="params">$, moduleA</span>)&#123;</span><br><span class="line">  <span class="comment">// 导出成员</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">animate</span>(&#123;<span class="attr">margin</span>:<span class="string">&#x27;20px&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">moduleA</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 载入一个模块 */</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;moduleName&#x27;</span>],<span class="keyword">function</span>(<span class="params"><span class="variable language_">module</span></span>)&#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="title function_">start</span>()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//自动创建script标签</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>淘宝推出Sea.js 实现的CMD模块，旨在用CommonJS的方式写AMD，后续被require.js兼容</p>
</blockquote>
<h3 id="模块化标准规范"><a class="markdownIt-Anchor" href="#模块化标准规范"></a> 模块化标准规范</h3>
<p>浏览器：ES Module、node：CommonJS</p>
<h4 id="es-module-特性2014年"><a class="markdownIt-Anchor" href="#es-module-特性2014年"></a> ES Module 特性（2014年）</h4>
<p>通过给script标签添加<code>type=&quot;module&quot;</code>，以ESM标准执行JS代码</p>
<ul>
<li>自动开启<strong>严格模式</strong></li>
<li>每个module单独私有作用域</li>
<li>通过CORS方式请求外部的JS模块（外部必须支持CORS，要加入CORS响应头）</li>
<li>延迟执行脚本 <code>defer</code></li>
</ul>
<h4 id="es-module-导入和导出"><a class="markdownIt-Anchor" href="#es-module-导入和导出"></a> ES Module 导入和导出</h4>
<p>导出导入都可 as 重命名，</p>
<p><strong><code>export</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; a, b &#125; <span class="comment">//这个&#123;&#125; 不是对象，而是固定写法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> xxx <span class="comment">//xxx可以是一个变量或者值，</span></span><br></pre></td></tr></table></figure>
<p><strong><code>import</code></strong></p>
<ul>
<li>
<p>引用文件路径</p>
<ul>
<li>不能省略<code>.js</code>文件后缀、也不能直接省略访问<code>index.js</code>，后续通过<strong>打包工具</strong>可以这样做</li>
<li>不能直接载入文件名（<code>from 'moduleA.js'</code>），因为这样会被识别成第三方库</li>
<li>可以载入相对路径(不能省略<code>./</code>)、绝对路径、完整的url路径（引用cdn模块）</li>
</ul>
</li>
<li>
<p>只导入不取值</p>
<ul>
<li>
<pre class="highlight"><code class="js"><span class="keyword">import</span> &#123;&#125; form <span class="string">&#x27;./moduleA.js&#x27;</span>
<span class="keyword">import</span> <span class="string">&#x27;./moduleA.js&#x27;</span> <span class="comment">//简写方式</span>
&lt;!--code￼<span class="number">2</span>--&gt;

</code></pre>
</li>
</ul>
</li>
<li>
<p>动态加载模块（import函数）</p>
<ul>
<li>
<p>普通<code>import from</code> 只能作用于最顶层作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./moduleA.js&#x27;</span>) </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>同时默认和分别导出时</p>
<ul>
<li>
<pre class="highlight"><code class="js"><span class="comment">//导出</span>
<span class="keyword">export</span> &#123;a, b&#125;
<span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&#x27;1234&#x27;</span>

<span class="comment">//导入</span>
<span class="keyword">import</span> &#123;a, b, <span class="keyword">default</span> <span class="keyword">as</span> str&#125; <span class="keyword">from</span> <span class="string">&#x27;./moduleA.js&#x27;</span>
<span class="keyword">import</span> str, &#123;a, b&#125; <span class="keyword">from</span> <span class="string">&#x27;./moduleA.js&#x27;</span>  <span class="comment">//简写 </span>
&lt;!--code￼<span class="number">4</span>--&gt;



</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="es-module-浏览器环境兼容"><a class="markdownIt-Anchor" href="#es-module-浏览器环境兼容"></a> ES Module 浏览器环境兼容</h4>
<blockquote>
<p>这种方式只适合<font color=red>开发阶段</font>，生产阶段不用。动态解析脚本，性能差</p>
<p>最好的方式还是在执行前，就将代码编译好</p>
</blockquote>
<p>有些浏览器不支持直接解析es6</p>
<p><a href="https://github.com/ModuleLoader/browser-es-module-loader">es-module-loader</a>代码读出来，交给babel转换</p>
<p>不支持promise，用<code>promise-ployfill</code></p>
<p>借助<code>script</code>标签的<font color=red><code>nomodule</code></font>属性，只在不支持的浏览器运行转换脚本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/browser-es-module-loader@0.4.1/dist/babel-browser-build.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是一个模块&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="es-module-在node中使用"><a class="markdownIt-Anchor" href="#es-module-在node中使用"></a> ES Module 在Node中使用</h4>
<p>在node环境下，esm文件后缀为<code>.mjs</code> ,不太推荐使用</p>
<p><u>官方内置模块</u>做了兼容，可以默认全部导入，也可以分别导入</p>
<p>第三方库一般都是默认导出，所以不能import {xx} from ‘.module.js’</p>
<h4 id="es-module-在node中与-commonjs模块交互"><a class="markdownIt-Anchor" href="#es-module-在node中与-commonjs模块交互"></a> ES Module 在Node中与 CommonJS模块交互</h4>
<p><font color=red> esm可以载入cjs模块</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// esm.ejs</span></span><br><span class="line"><span class="comment">// 只能默认导入</span></span><br><span class="line"><span class="keyword">import</span> mod <span class="keyword">from</span> <span class="string">&#x27;./cjs.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mod)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ********************* //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cjs.js</span></span><br><span class="line"><span class="comment">/* module.exports = &#123;</span></span><br><span class="line"><span class="comment">    foo: &#x27;cjs中的foo&#x27;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">foo</span> = <span class="string">&#x27;cjs中的foo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>cjs不能载入esm模块（在原生node环境中）</p>
<p>nvm use 版本号</p>
<h4 id="es-module在node新版本中的支持"><a class="markdownIt-Anchor" href="#es-module在node新版本中的支持"></a> ES Module在Node新版本中的支持</h4>
<p><code>package.json</code> 新增<code>&quot;type&quot;:&quot;module&quot;</code> 字段，node中<code>.js</code>文件模块就设定为ESM</p>
<p>此时还需用CommonJS模块，后缀名为<code>.cjs</code></p>
<h4 id="es-module-在node中-babel兼容方案"><a class="markdownIt-Anchor" href="#es-module-在node中-babel兼容方案"></a> ES Module 在Node中 Babel兼容方案</h4>
<p>Babel js编译器，使用新特性代码 =(编译成)=》当前环境支持的代码</p>
<h5 id="用preset插件集合"><a class="markdownIt-Anchor" href="#用preset插件集合"></a> 用preset插件集合</h5>
<p>下载所需模块yarn add <code>@babel/node</code> <code>@babel/core</code> <code>@babel/preset-env </code> --dev(作为开发依赖)</p>
<p>运行 <code>yarn babel-node xxx.js --presets=preset-env</code>  (还有其他preset)</p>
<ul>
<li>
<p>如果不想每次运行都添加–presets=xxx。那么在文件下新建<code>.babelrc</code>文件，中添加</p>
<ul>
<li>
<pre class="highlight"><code class="json"><span class="punctuation">&#123;</span>
  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">]</span>
<span class="punctuation">&#125;</span>
&lt;!--code￼<span class="number">7</span>--&gt;

</code></pre>
</li>
</ul>
</li>
</ul>
<p>运行 <code>yarn babel-node xx.js</code></p>
<h2 id="模块化打包工具"><a class="markdownIt-Anchor" href="#模块化打包工具"></a> <mark>模块化打包工具</mark></h2>
<blockquote>
<p>ESM 存在环境兼容问题</p>
<p>模块文件过多，网络请求频繁，影响工作效率</p>
<p>所有前端资源(html, css…)都需要模块化</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">新特性代码编译</th>
<th style="text-align:center">模块化JS打包</th>
<th style="text-align:center">支持不同类型的资源模块</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://s2.loli.net/2023/05/08/xNJsOmDZSQ24Cka.png" alt="image-20230504103526814" /></td>
<td style="text-align:center"><img src="https://s2.loli.net/2023/05/08/Yoq8ByXEDLQFJw1.png" alt="image-20230504103539317" /></td>
<td style="text-align:center"><img src="https://s2.loli.net/2023/05/08/o5xhIYfqEnHteFs.png" alt="image-20230504103918557" /></td>
</tr>
</tbody>
</table>
<p>模块打包工具（Module Bundler）</p>
<p><code>webpack</code> <code>parcel</code> <code>rollup</code></p>
<p>打包工具的模块化是指对<font color=red>前端整体的模块化</font>，并不单指JS的模块化</p>
<h3 id="webpack"><a class="markdownIt-Anchor" href="#webpack"></a> <code>webpack</code></h3>
<p>模块加载器loader （代码转换）</p>
<p>代码拆分 code splitting</p>
<p>资源模块 assets module，以模块化的方式引入任何资源文件</p>
<p><code>yarn init --yes</code></p>
<p><code>yarn add webpack webpack-cli --dev</code></p>
<p><code>yarn webpack</code> (默认 打包src下的index.js文件)</p>
<h4 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h4>
<p>默认打包 <code>src/index.js</code></p>
<p><code>webpack.config.js</code> 运行在node环境中的CommonJS模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>, <span class="comment">//指定入口文件</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>, <span class="comment">//指定打包后的文件名</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;output&#x27;</span>) <span class="comment">//必须为绝对路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="工作模式"><a class="markdownIt-Anchor" href="#工作模式"></a> 工作模式</h4>
<p>正常运行webpack出现警告⚠️</p>
<blockquote>
<p>WARNING in configuration<br />
The ‘mode’ option has not been set, webpack will fallback to ‘production’ for this value.<br />
<strong>Set ‘mode’ option to ‘development’ or ‘production’ to enable defaults for each environment.</strong><br />
You can also set it to ‘none’ to disable any default behavior. Learn more: <a href="https://webpack.js.org/configuration/mode/">https://webpack.js.org/configuration/mode/</a></p>
</blockquote>
<h5 id="prodcuction-生产默认模式"><a class="markdownIt-Anchor" href="#prodcuction-生产默认模式"></a> prodcuction 生产默认模式</h5>
<p>yarn webpack</p>
<p>​	自动优化打包结果</p>
<h5 id="开发模式"><a class="markdownIt-Anchor" href="#开发模式"></a> 开发模式</h5>
<p>yarn webpack --mode development 优化打包速度，添加调试过程中辅助</p>
<h5 id="none-模式"><a class="markdownIt-Anchor" href="#none-模式"></a> none 模式</h5>
<p>yarn webpack --mode none 最原始</p>
<p>或者在<code>webpack.config.js</code>文件添加<code>mode: 'development'</code>属性，就不需要在<code>yarn webpack --mode 参数</code></p>
<h4 id="资源模块加载"><a class="markdownIt-Anchor" href="#资源模块加载"></a> 资源模块加载</h4>
<p>webpack默认只处理js文件</p>
<p>不同类型的资源文件，需要不同类型的加载器loader</p>
<h5 id="加载css资源"><a class="markdownIt-Anchor" href="#加载css资源"></a> 加载css资源</h5>
<p><code>yarn add css-loader </code> <em><strong>将css文件转为js文件模块</strong></em></p>
<p><code>yarn add style-loader</code> 将css-loader转换的css文件以style标签追加到页面上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.css&#x27;</span>,<span class="comment">//打包css文件</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;output&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/.css$/</span>, <span class="comment">//打包文件后缀</span></span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                ]<span class="comment">//use模块是从后往前直行，左移css-loader要卸载后面</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>loader是webpack的核心特性，通过不同的loader加载不同类型资源</strong></em></p>
<h6 id="导入import资源模块"><a class="markdownIt-Anchor" href="#导入import资源模块"></a> <mark>导入import资源模块</mark></h6>
<p>打包入口—&gt; 运行入口</p>
<p>js驱动驱动整个前端业务</p>
<table>
<thead>
<tr>
<th>js文件作为打包的入口 ，然后在js模块中通过import引入css文件</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="//main.js">//main.js</a> <br /><code>import './xxx.css'</code> <code>import './yyy.css'</code></td>
</tr>
<tr>
<td><img src="https://s2.loli.net/2023/05/08/8BQZXKWvAbUh6Df.png" alt="image-20230504140630685" style="zoom:100%;" /></td>
</tr>
</tbody>
</table>
<p><em><strong>根据代码的需要动态导入资源</strong></em></p>
<p><font color=red>逻辑合理，js需要资源文件</font></p>
<p><font color=red>确保上线资源文件不缺失</font></p>
<blockquote>
<p>代码更易维护，减少网络请求</p>
<p>loader 编译转换压缩</p>
<p>Webpack静态资源优化，分析依赖关系是否必须，tree-shaking，优化代码</p>
</blockquote>
<h5 id="文件资源加载器-file-loader"><a class="markdownIt-Anchor" href="#文件资源加载器-file-loader"></a> 文件资源加载器 file-loader</h5>
<p><code>yarn add file-loader</code> 拷贝物理文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;output&#x27;</span>), <span class="comment">//默认是dist</span></span><br><span class="line">        <span class="comment">// publicPath: &#x27;output/&#x27;  //默认</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/.jpeg$/</span>,</span><br><span class="line">                <span class="attr">use</span>: <span class="string">&#x27;file-loader&#x27;</span> <span class="comment">//配置file-loader</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据配置文件的匹配到对应的文件加载器</p>
<p>文件加载器将导入的文件<strong>拷贝到输出的目录</strong>，</p>
<p>将这个拷贝的<strong>文件路径</strong>作为这个<strong>模块的返回值</strong>返回，文件就被发布出来，</p>
<p>可以通过模块的导出成员拿到这个资源的访问路径</p>
<p><img src="https://s2.loli.net/2023/05/08/7BHleROkNcDWFvd.png" alt="image-20230504143659882" /></p>
<h5 id="url-loader"><a class="markdownIt-Anchor" href="#url-loader"></a> url-loader</h5>
<p>DataUrls 这个就已经代表了文件</p>
<p>将小型文件（如图片、音频等）直接嵌入到 HTML、CSS 或 JavaScript 文件中，而不必再通过网络请求获取这些文件</p>
<table>
<thead>
<tr>
<th><img src="https://s2.loli.net/2023/05/08/FOMloWnvTq9Hc4Z.png" alt="image-20230504144417780" /></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://s2.loli.net/2023/05/08/KoEDmiLzx87gRp4.png" alt="image-20230504144448616" /></td>
</tr>
<tr>
<td><img src="https://s2.loli.net/2023/05/08/A2gP89vCDUpJBRM.png" alt="image-20230504144533002" /></td>
</tr>
<tr>
<td><img src="https://s2.loli.net/2023/05/08/cUkDwi7jH8e9XSC.png" alt="image-20230505105909806" /></td>
</tr>
</tbody>
</table>
<p>通过url-loader实现DataUrls</p>
<p><code>yarn add url-loader</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/.jpeg$/</span>,</span><br><span class="line">                <span class="comment">//use: &#x27;url-loader&#x27;,</span></span><br><span class="line">              	<span class="attr">use</span>: &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>:&#123;</span><br><span class="line">                        <span class="attr">limit</span>: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">//10KB,只处理&lt;=10KB，的文件,超过就单独提取存放</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>url-loader不会像file-loader在输出文件夹，而是生成导出文件（在打包文件中）</p>
<p style="color:red;">小文件使用DataUrls的方式，减少请求次数
  <br>大文件单独提取存放，提高加载速度</p>需要同时安装file-loader和url-loader模块
<h4 id="常用加载器分类"><a class="markdownIt-Anchor" href="#常用加载器分类"></a> 常用加载器分类</h4>
<table>
<thead>
<tr>
<th>编译转换类</th>
<th>文件操作类</th>
<th>代码检查类</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>统一代码风格，提高代码质量</td>
</tr>
<tr>
<td><img src="https://s2.loli.net/2023/05/08/J49vgDNeiHhGoy7.png" alt="image-20230504150809959" /></td>
<td><img src="https://s2.loli.net/2023/05/08/NXHYKzByxDGSv2A.png" alt="image-20230504150857447" /></td>
<td><img src="https://s2.loli.net/2023/05/08/8puCoUVwRJmiWgh.png" alt="image-20230504150924725" /></td>
</tr>
</tbody>
</table>
<h4 id="webpack与es2015-babel-loader"><a class="markdownIt-Anchor" href="#webpack与es2015-babel-loader"></a> webpack与ES2015 babel-loader</h4>
<p>因为打包需要，处理export和import</p>
<p>利用babel中的预设插件编译转换代码</p>
<p><code>yarn add babel-loader @babel/core @babel/preset-env </code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/.js$/</span>,</span><br><span class="line">                <span class="attr">use</span>: &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">          ]</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模块加载方式"><a class="markdownIt-Anchor" href="#模块加载方式"></a> 模块加载方式</h4>
<blockquote>
<p>非必要，不要混用标准</p>
</blockquote>
<p>遵循ESM的import声明</p>
<p>遵循CJS的require函数，（CJS require ESM的默认导出模块，需要<code>require().default</code>）</p>
<p>遵循AMD的define和require函数</p>
<p>Loader加载的非JS也会触发资源加载（处理的结果打包到输出目录）</p>
<p>​	样式代码的@import指令 url函数</p>
<p>​		<code>@import url(reset.css);</code></p>
<p>​		<code>background-image: url(background.jpeg);</code></p>
<p>​	html中的src属性</p>
<blockquote>
<p>Footer.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;img src=&quot;footer.jpeg&quot;&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;footer.jpeg&quot;</span>&gt;</span>download<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>html文件默认导出是字符串，需要接收</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> footerHtml <span class="keyword">from</span> <span class="string">&#x27;./footer.html&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(footer.<span class="property">html</span>)</span><br></pre></td></tr></table></figure>
<p>再配合html-loader（<mark>默认只能加载img src</mark>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/.html$/</span>,</span><br><span class="line">            <span class="attr">use</span>: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="comment">// attrs: [&#x27;img:src&#x27;, &#x27;a:href&#x27;] //已经被废弃</span></span><br><span class="line">            <span class="attr">sources</span>: &#123;</span><br><span class="line">                <span class="attr">list</span>: [</span><br><span class="line">                    <span class="string">&quot;...&quot;</span>,<span class="comment">// 所有默认支持的标签和属性，这个一定要加上，不然就只会检测a标签了</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">tag</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">                        <span class="attr">attribute</span>: <span class="string">&#x27;href&#x27;</span>,</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&#x27;src&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr />
<h4 id="loader核心工作原理"><a class="markdownIt-Anchor" href="#loader核心工作原理"></a> Loader核心工作原理</h4>
<p>入口文件（js文件 ）</p>
<p>通过require import 推断解析文件所依赖的模块，分别解析每个模块</p>
<p>生成依赖树，递归依赖树，找到结点的依赖文件，根据配置文件rules属性，找到对应loader，最后打包在bundle.js文件</p>
<p><em><strong>Loader机制是webpack核心</strong></em></p>
<hr />
<blockquote>
<p>Loader本质上是一个导出函数的Javascript模块，Webpack调用这个函数，将文件内容传递给它，返回转换后的结果。这个函数需要返回一个Javascript模块，Webpack会将它打包到最终的输出中。</p>
</blockquote>
<p><em><strong>管道（Pipeline）机制</strong></em></p>
<h4 id="开发一个loader"><a class="markdownIt-Anchor" href="#开发一个loader"></a> 开发一个Loader</h4>
<p>loader负责资源文件从输入到输出的转换</p>
<p>webpack中对于同一个资源可一次使用多个loader，但是最后loader处理的result必须是一段js代码</p>
<img src="https://s2.loli.net/2023/05/08/lvFeHpb1SPcY3rG.png" alt="image-20230504174619249" style="zoom: 25%;" />
<p>打包过后，webpack直接将loader return的js代码拼接在打包后的js文件中</p>
<h5 id="简单实现一个-显示markdown-loader"><a class="markdownIt-Anchor" href="#简单实现一个-显示markdown-loader"></a> 简单实现一个 显示markdown loader</h5>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//aboutme.md</span><br><span class="line"><span class="section"># 一个markdown文件</span></span><br><span class="line"> xxxxx</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js 打包入口文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入md文件</span></span><br><span class="line"><span class="keyword">import</span> aboutMd <span class="keyword">from</span> <span class="string">&#x27;./aboutme.md&#x27;</span>  <span class="comment">//一般md文件导入会是一段html字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aboutMd)</span><br></pre></td></tr></table></figure>
<p>loader return输出必须是一段js代码，其实就是将return的结果直接拼接在打包完成的js文件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//markdown-loader.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">source</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> marked = <span class="built_in">require</span>(<span class="string">&#x27;marked&#x27;</span>) <span class="comment">//借助marked</span></span><br><span class="line">	<span class="keyword">const</span> html = marked.<span class="title function_">parse</span>(source)</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">//return `module.exports = $&#123;JSON.stringify(html)&#125;` //return输出必须是一段js代码</span></span><br><span class="line">  <span class="comment">// return `export default $&#123;JSON.stringify(html)&#125;` //esm导出</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//!!!!借助html-loader 解析html</span></span><br><span class="line">  <span class="keyword">return</span> html</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/.md$/</span>,</span><br><span class="line">            <span class="attr">use</span>: [<span class="comment">//use数组，从后往前执行</span></span><br><span class="line">                <span class="string">&#x27;html-loader&#x27;</span>,<span class="comment">//!!!!借助html-loader 解析html</span></span><br><span class="line">                <span class="string">&#x27;./markdown-loader&#x27;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插件plugin机制"><a class="markdownIt-Anchor" href="#插件plugin机制"></a> 插件Plugin机制</h4>
<p>增强webpack自动化能力</p>
<p>处理<u>除了loader处理的资源加载</u>以外自动化工作</p>
<p>e.g. 清除上次打包的dist文件夹</p>
<p>​		将拷贝的静态文件输出至目录</p>
<p>​		压缩输出代码</p>
<p>​		…</p>
<p>实现大多数前端工程化</p>
<h5 id="clean-webpack-plugin"><a class="markdownIt-Anchor" href="#clean-webpack-plugin"></a> <code>clean-webpack-plugin</code></h5>
<p>清除输出目录</p>
<p>新打包只会覆盖重名文件，而其他文件则会一直积累在输出目录</p>
<p><code>yarn add clean-webpack-plugin --dev</code> 第三方库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="html-webpack-plugin"><a class="markdownIt-Anchor" href="#html-webpack-plugin"></a> <code>html-webpack-plugin</code></h5>
<p><strong>webpack输出HTML文件</strong></p>
<blockquote>
<p><code>html-webpack-plugin</code>是一个webpack插件，用于生成HTML文件。它可以根据你的配置自动生成一个HTML文件，并将打包生成的js、css等文件<strong>自动引入</strong>到HTML文件中。</p>
</blockquote>
<p>自动使用bundle.js的html</p>
<p>最后只用发布dist目录，不需要另外再同时发布一个html文件</p>
<p><code>yarn add html-webpack-plugin --dev</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    <span class="comment">//new HtmlWebpackPlugin() //在输出目录生成index.html</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;webpack plugin sample&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">viewport</span>: <span class="string">&#x27;width=device-width&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">template</span>:<span class="string">&#x27;./src/index.html&#x27;</span> <span class="comment">//模板文件</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模板文件 ejs模板 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>输出多个html页面，直接多<code>new HtmlWebpackPlugin(&#123;filename:'hello'&#125;)</code></strong></p>
<h5 id="copy-webpack-plugin-静态资源"><a class="markdownIt-Anchor" href="#copy-webpack-plugin-静态资源"></a> <code>copy-webpack-plugin</code> 静态资源</h5>
<p>将静态文件打包copy到输出目录 ,<a href="#jump">一般不在开发环境中使用</a></p>
<p><code>yarn add copy-webpack-plugin --dev</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CopyWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CopyWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">patterns</span>: [</span><br><span class="line">        &#123;<span class="attr">from</span>: <span class="string">&#x27;public&#x27;</span>, <span class="attr">to</span>: <span class="string">&#x27;&#x27;</span>&#125; <span class="comment">//从那个文件到输出文件夹</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自定义插件"><a class="markdownIt-Anchor" href="#自定义插件"></a> 自定义插件</h5>
<p>Plugin通过钩子机制实现</p>
<p>一个具有 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>apply</code></a> 方法的 JavaScript 对象</p>
<p>通过在生命周期的钩子挂载函数实现扩展</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于处理删除打包bundle.js 的前面的注释</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span>()&#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compliler</span>)&#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function"><span class="params">conpilation</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// compilation 此次打包的上下文</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">const</span> file <span class="keyword">in</span> compilation.<span class="property">assets</span>)&#123;</span><br><span class="line">        <span class="comment">//console.log(filename) //打包目录的某个文件</span></span><br><span class="line">        <span class="keyword">if</span>(file.<span class="title function_">endsWith</span>(<span class="string">&#x27;.js&#x27;</span>))&#123;</span><br><span class="line">          <span class="keyword">const</span> content = compilation.<span class="property">assets</span>[file].<span class="title function_">source</span>() <span class="comment">//某个文件内容</span></span><br><span class="line">          <span class="keyword">const</span> withoutComments = contents.<span class="title function_">replace</span>(<span class="regexp">/\/\*\*+\*\//g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">          compliation.<span class="property">assets</span>[file] = &#123; <span class="comment">//覆盖一下里面的方法</span></span><br><span class="line">            <span class="attr">source</span>: <span class="function">()=&gt;</span> withoutComments,</span><br><span class="line">         		<span class="attr">size</span>: <span class="function">()=&gt;</span> withoutComments.<span class="property">length</span></span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="增强开发体验"><a class="markdownIt-Anchor" href="#增强开发体验"></a> 增强开发体验</h4>
<p>手动启动服务，过于原始</p>
<img src="https://s2.loli.net/2023/05/08/NvyFanxBXjJAkKE.png" alt="image-20230504205435077" style="zoom:35%;" />
<blockquote>
<p><strong>需求</strong></p>
<p>http server启动（接近）</p>
<p>自动编译+自动刷新</p>
<p>source map支持</p>
</blockquote>
<h5 id="自动编译刷新"><a class="markdownIt-Anchor" href="#自动编译刷新"></a> 自动编译+刷新</h5>
<ul>
<li><u><code>watch</code>工作模式</u> 监听文件变化，自动重新打包</li>
</ul>
<p>​	专注编码</p>
<p>​	<code>yarn webpack --watch</code></p>
<ul>
<li>编译后自动刷新浏览器</li>
</ul>
<p>​	<a href="https://browsersync.bootcss.com/#install"><code>BrowserSync</code></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g browser-sync</span><br><span class="line">browser-sync start --server --files &quot;css/*.css&quot; //一个基本用途是，监听某个 css 文件</span><br><span class="line">//&quot;**/*&quot; //监听所有文件的变化</span><br></pre></td></tr></table></figure>
<p><strong><code>browser-sync 文件夹名 --files &quot;**/*&quot; </code></strong></p>
<blockquote>
<p><em><strong>watch 与 browser-sync结合麻烦，效率低</strong></em></p>
</blockquote>
<h5 id="webpack-dev-server"><a class="markdownIt-Anchor" href="#webpack-dev-server"></a> <mark><code>webpack-dev-server</code></mark></h5>
<p><mark>对开发者提供一个良好的服务器</mark></p>
<p>自动编译+刷新</p>
<p><code>yarn add webpack-dev-server --dev</code></p>
<p><code>yarn webpack-dev-server</code> 启动</p>
<p>添加 <code>--open</code> 自动打开浏览器窗口</p>
<p><em>将打包结果写入内存，并没有生成dist目录，不需要<strong>读写磁盘</strong>，提高效率</em></p>
<h5 id="webpack-dev-server静态资源访问"><a class="markdownIt-Anchor" href="#webpack-dev-server静态资源访问"></a> <code>webpack-dev-server</code>静态资源访问</h5>
<p>Dev-server默认只会serve打包输出文件</p>
<p>只要是通过webpack打包输出的文件都能被访问到</p>
<p><span id='jump' style="visibility:none;"></span></p>
<blockquote>
<p>之前通过clean-webpack-plugin插件实现将静态资源打包到输出文件夹，</p>
<p>但是在开发环境一般不要使用插件，</p>
<p>因为我们频繁修改代码，拷贝静态文件，将影响开发</p>
<p>所以一般是在上线的阶段前，使用一次这个插件</p>
</blockquote>
<p><a href="https://www.webpackjs.com/configuration/dev-server/#devserverstatic">webpack.devServer.static</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">//contentBase: &#x27;./public&#x27;, //wepack5已经移除</span></span><br><span class="line">    <span class="attr">static</span>: &#123;</span><br><span class="line">            <span class="attr">directory</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;public&#x27;</span>) <span class="comment">//指定当前项目静态资源文件夹</span></span><br><span class="line">        &#125;<span class="comment">//可以托管多个静态文件夹</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="webpack-dev-server-代理api服务"><a class="markdownIt-Anchor" href="#webpack-dev-server-代理api服务"></a> <code>webpack-dev-server </code>代理API服务</h5>
<blockquote>
<p>CORS 跨域资源共享，服务端开启</p>
<p>并不是任何情况服务端都必须支持CORS，</p>
<p>前后端同源部署，没必要开启CORS</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">代理API服务</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://s2.loli.net/2023/05/08/yVghdvRLlaZ39ES.png" alt="image-20230505135331738 " style="zoom:33%;" /></td>
</tr>
</tbody>
</table>
<p><strong>代理 <a href="https://api.github.com">https://api.github.com</a></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">static</span>: &#123;</span><br><span class="line">            <span class="attr">directory</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;public&#x27;</span>) <span class="comment">//指定当前项目静态资源文件夹</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;,</span><br><span class="line">  	<span class="comment">// !!!代理</span></span><br><span class="line">  	<span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="comment">// 对当前`/api/users`的请求 --会代理到--&gt; `https://api.github.com/api/users`</span></span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;https://api.github.com&#x27;</span>,</span><br><span class="line">                <span class="comment">// 如果不希望传递/api，则需要重写路径 </span></span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;, <span class="comment">//`/api/users`的请求 --会代理到--&gt; `https://api.github.com/users`</span></span><br><span class="line">                <span class="comment">// 不能使用localhost:8080 作为请求GitHub的主机名</span></span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                    服务器有多个网站，服务器通过主机名判断该请求那个网站 </span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="comment">// 代理请求`https://api.github.com/users`</span></span><br><span class="line"><span class="comment">//http://localhost:8080/api/users 同源请求，不用担心跨域问题</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/users&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>res.<span class="title function_">json</span>()).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="sourcemap"><a class="markdownIt-Anchor" href="#sourcemap"></a> sourceMap</h5>
<p>运行代码与源代码不同</p>
<p>需要调试应用，定位错误</p>
<p><strong>调试和报错都是基于转换后的代码运行的</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">sourceMap映射源代码与转换后代码的关系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://s2.loli.net/2023/05/08/MOTNu8KoedPZj7v.png" alt="image-20230505151251462" style="zoom:25%;" /></td>
</tr>
<tr>
<td style="text-align:center"><img src="https://s2.loli.net/2023/05/08/nb23756hNwTodgZ.png" alt="image-20230505151353861" style="zoom:24%;" /></td>
</tr>
</tbody>
</table>
<p><em>sourceMap解决了源代码和运行代码不一致所产生的问题</em></p>
<blockquote>
<p>拿jquery距举例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入的是压缩后的jq包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;jquery.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="comment">// 使用</span></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> $body = $(<span class="variable language_">document</span>.<span class="property">body</span>)</span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">console</span>.<span class="title function_">log</span>($body)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jquery.min.js</span></span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line"><span class="comment">//# sourceMappingURL=jquery.min.map </span></span><br><span class="line"><span class="comment">//浏览器会自动识别，用于在浏览器开发工具中调试和定位代码时提供源文件的映射关系</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jquery.js //js没被压缩的源文件</span></span><br><span class="line">xxxxxxxxxxx</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jquery.min.map //sourceMap文件</span></span><br><span class="line">xxxxxxxx</span><br></pre></td></tr></table></figure>
<p>之后在浏览器调试，虽然文件引入使用的是压缩后的体积，但是因为有sourcemap文件就能直接定位到源文件</p>
</blockquote>
<h5 id="webpack配置sourcemap"><a class="markdownIt-Anchor" href="#webpack配置sourcemap"></a> webpack配置sourceMap</h5>
<h6 id="source-map模式"><a class="markdownIt-Anchor" href="#source-map模式"></a> <code>source-map</code>模式</h6>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>yarn webpack</code> 在dist目录生成sourcemap文件</p>
<p>webpack支持多种soucemap方式，每种方式的效率和效果都不相同</p>
<h6 id="eval模式"><a class="markdownIt-Anchor" href="#eval模式"></a> <code>eval</code>模式</h6>
<ul>
<li>映射到转换后的代码</li>
<li>速度fastest</li>
</ul>
<p>将模块打包后的代码放入eval函数执行，配合 <code>#sourceURL=路径</code>方式说明对应文件路径，浏览器执行就到源代码是哪个文件，从而定位文件</p>
<p>并没有生成sourceMap文件</p>
<blockquote>
<p><font color=red>打包过后的模块代码</font></p>
<p>定位文件信息，而不知道行列（）</p>
</blockquote>
<h6 id="模式对比"><a class="markdownIt-Anchor" href="#模式对比"></a> 模式对比</h6>
<p><code>eval</code> 使用eval函数+sourceURL执行模块，只有行信息</p>
<p><code>cheap</code> 只有行信息，没有具体列信息</p>
<p>带有<code>module</code>，没有经过loader es转换（例如babel-loader）的信息</p>
<p><img src="https://s2.loli.net/2023/05/08/DC6gvoAi9TqN2mn.png" alt="image-20230505165912024" /></p>
<p><code>Inline</code> sourceMap以dataURl模式嵌入到转换后的模块中</p>
<p><code>hidden</code> 生成了sourcemap文件，但是并没有注释引入到文件中，（第三方包，）</p>
<p><code>nosources</code> 调试工具看不到源代码，但是提供了行列信息。生产环境保护源代码，不会被暴露</p>
<h5 id="选择sourcemap"><a class="markdownIt-Anchor" href="#选择sourcemap"></a> 选择sourcemap</h5>
<p>开发环境 <code>cheap-module-eval-source-map</code></p>
<img src="https://s2.loli.net/2023/05/08/jLxybh6wuodRqc8.png" alt="image-20230505170647622" style="zoom:25%;" />
<p>生产环境 <code>none</code></p>
<img src="https://s2.loli.net/2023/05/08/YoQROVGhfbacKMp.png" alt="image-20230505170741601" style="zoom: 25%;" />
<p><em><strong>调试是开发阶段的问题</strong></em>，没有信息选择nosources-source-map</p>
<h4 id="hmr-hot-module-replacement模块热更新"><a class="markdownIt-Anchor" href="#hmr-hot-module-replacement模块热更新"></a> HMR (hot module replacement)模块热更新</h4>
<blockquote>
<p>自动刷新页面任何操作状态都会丢失</p>
<ol>
<li>提前写死编辑器内容</li>
<li>额外代码实现刷新前保存，刷新后读取</li>
</ol>
<p><strong>最好：页面不刷新，模块可以更新代码模块</strong></p>
</blockquote>
<p>应用执行过程中，实时替换某个模块，应用运行状态不改变</p>
<p>最强大的功能之一，极大提高了工作效率</p>
<p>集成在webpack-dev-server</p>
<h5 id="开启hmr-hot"><a class="markdownIt-Anchor" href="#开启hmr-hot"></a> 开启hmr <code>hot</code></h5>
<p><code>yarn webpack-dev-server --hot</code></p>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color=red>webpack的HMR并不能开箱即用</font></p>
<p>样式文件可以的原因是，经过loader处理，style-loader处理了样式文件热更新</p>
<p>使用框架开发vue react，每种文件有规律，有通用的替换办法，脚手架创建的项目都继承了HMR方案</p>
<p><font color=red>但是webpack的HMR需要手动处理模块热替换逻辑 </font></p>
</blockquote>
<p><em>更新被我们<strong>手动处理</strong>了，就<strong>不会触发自动刷新</strong>，反之就会刷新页面</em></p>
<h5 id="js模块hmr"><a class="markdownIt-Anchor" href="#js模块hmr"></a> js模块hmr</h5>
<p>不同的js模块有不同的逻辑，所以需要自定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js 打包入口js文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CreateEditor</span> <span class="keyword">from</span> <span class="string">&#x27;./editor.js&#x27;</span> <span class="comment">//为一个创建编辑器的模块</span></span><br><span class="line"><span class="keyword">const</span> editor = <span class="title function_">createEditor</span>()</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(editor)</span><br><span class="line"></span><br><span class="line"><span class="comment">//##########处理hmr，与上面业务代码无关，并且下面代码并不会被打包############</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">module</span>.<span class="property">hot</span>)&#123; <span class="comment">//module.hot 由插件webpack.HotModuleReplacementPlugin()带来，原生module并不存在</span></span><br><span class="line"> 		 <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //注册某个模块更新过后的处理函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; &#x27;./editor.js&#x27; - 监视模块依赖路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">callback</span>&#125;  - 处理更新的逻辑回调函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">let</span> lastEditor = editor</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./editor.js&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = lastEditor.<span class="property">innerHTML</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> newEditor = <span class="title function_">createEditor</span>()</span><br><span class="line">    newEditor.<span class="property">innerHTML</span> = value</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newEditor)</span><br><span class="line">    </span><br><span class="line">    lastEditor = newEditor</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="图片hmr"><a class="markdownIt-Anchor" href="#图片hmr"></a> 图片hmr</h5>
<p>直接在<code>module.hot.accept</code>更新图片路径就行</p>
<h5 id="hotonly"><a class="markdownIt-Anchor" href="#hotonly"></a> <code>hotonly</code></h5>
<p>假如说hmr处理逻辑有误，就会导致页面自动刷新，看不到报错信息</p>
<p>那就最好使用<code>hotonly</code>，维持原状，不会自动刷新页面</p>
<p><code>yarn webpack-dev-server --hot only</code></p>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">//hotOnly: true, webpack5废弃</span></span><br><span class="line">    <span class="attr">hot</span>: <span class="string">&#x27;only&#x27;</span></span><br><span class="line">  &#125;，</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">  	<span class="keyword">new</span> webpack.<span class="title function_">hmrp</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>module.hot</code> 是<code>webpack.HotModuleReplacementPlugin()</code> 插件带来的，</p>
<p><font color=red>处理热更新的逻辑也不会被打包</font></p>
<h4 id="生产环境优化"><a class="markdownIt-Anchor" href="#生产环境优化"></a> 生产环境优化</h4>
<p>生产环境跟开发环境差异大，<u>生产环境注重运行效率，</u>开发环境注重开发效率</p>
<p>不同的<code>mode</code> 配置：none, production, development</p>
<p>为不同的环境创建不同的配置</p>
<h4 id="不同的环境的配置"><a class="markdownIt-Anchor" href="#不同的环境的配置"></a> 不同的环境的配置</h4>
<ol>
<li>配置文件根据环境不同导出不同配置</li>
<li>一个环境对应一个配置文件</li>
</ol>
<h5 id="环境变量参数配置"><a class="markdownIt-Anchor" href="#环境变量参数配置"></a> 环境变量参数配置</h5>
<p><code>webpack-config.js</code> 导出模块<code>module.exports</code>可以导出一个函数</p>
<blockquote>
<p>参数 env 代表cli传递的环境变量</p>
<p>参数 argv 代表cli传递的所有参数</p>
<p>​	比如：<code>yarn webpack-dev-server --env production</code> 此时env.prodution === true</p>
<p>返回 一个配置</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...等其他开发阶段的配置</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 此时环境为生产环境</span></span><br><span class="line">  <span class="keyword">if</span>(env.<span class="property">production</span>) &#123;</span><br><span class="line">    config.<span class="property">mode</span> = <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    config.<span class="property">devtool</span> = <span class="string">&#x27;nosources-source-map&#x27;</span>,</span><br><span class="line">    config.<span class="property">plugins</span> = [</span><br><span class="line">      ...config.<span class="property">plugins</span>,</span><br><span class="line">    	<span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">CopyWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">patterns</span>: [</span><br><span class="line">									&#123; <span class="attr">from</span>: <span class="string">&quot;public&quot;</span>, <span class="attr">to</span>: <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">              ],</span><br><span class="line">    &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不同环境对应不同配置"><a class="markdownIt-Anchor" href="#不同环境对应不同配置"></a> 不同环境对应不同配置</h5>
<p>三个配置（开发、生产、公共）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.common.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;<span class="comment">//xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>yarn add webpack-merge --dev</code>  专门用于合并导出配置项的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.prod.js 生产环境的webapck配置</span></span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>) <span class="comment">// 合并配置项函数</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(common, &#123;</span><br><span class="line">  <span class="attr">mode</span>:<span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  <span class="comment">// xxxx</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.dev.js 开发环境的webpack配置 （与prod差不多）</span></span><br></pre></td></tr></table></figure>
<p>执行不同开发环境的webpack配置，加上<code>--config</code>参数</p>
<p><code>yarn webpack --config webpack.prod.js</code> 执行<strong>开发环境</strong>的webpack配置</p>
<p>或</p>
<p>在<code>package.json</code>，写入npm 脚本</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;webpack --config webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;webpack --config webpack.prod.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="webpack自带的优化"><a class="markdownIt-Anchor" href="#webpack自带的优化"></a> webpack自带的优化</h4>
<h5 id="defineplugin"><a class="markdownIt-Anchor" href="#defineplugin"></a> DefinePlugin</h5>
<p>为代码注入全局成员</p>
<p>默认启用，<font color=gray>代码注入一个<code>process.env.NODE_ENV</code>常量，判断当前运行环境</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">      <span class="comment">/*注入一个API_BASE_URL常量*/</span></span><br><span class="line">      <span class="comment">// API_BASE_URL: &#x27;&quot;http://example.com&quot;&#x27; //js代码片段</span></span><br><span class="line">      <span class="attr">API_BASE_URL</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;http://example.com&#x27;</span>) <span class="comment">//或者用这个方式</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">API_BASE_URL</span>) <span class="comment">//直接调用</span></span><br></pre></td></tr></table></figure>
<h5 id="tree-shaking"><a class="markdownIt-Anchor" href="#tree-shaking"></a> Tree Shaking</h5>
<p>shake掉代码中未引用的部分，『 未引用代码dead-code 』</p>
<p><strong>生产模式</strong>自动开启 <code>yarn webpack--mode production</code></p>
<blockquote>
<p>treeshaking 并不是webpack某一个配置选项</p>
<p>是一组功能搭配使用的效果</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack-cofig.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">usedExports</span>: <span class="literal">true</span>, <span class="comment">//只导出使用了的模块</span></span><br><span class="line">    <span class="attr">minimize</span>: <span class="literal">true</span> <span class="comment">//压缩代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="合并模块函数"><a class="markdownIt-Anchor" href="#合并模块函数"></a> 合并模块函数</h5>
<p>也是<code>optimization</code>的一个属性</p>
<p><strong><code>concatenateModules</code></strong>，将所有的模块合并输出到一个<font color=red>函数</font>中（<u><em>scope hoisting 作用域提升</em></u>）</p>
<blockquote>
<p>默认在生产环境启用，其他环境禁用</p>
</blockquote>
<p>treeshaking 前提是使用ESM组织代码，由webpack打包的代码使用ESM</p>
<p>为了转换代码新特性，使用babel-loader，<u><strong>有可能</strong>会将ESM-&gt;CJS（取决于是否使用了esm转换插件）</u></p>
<p>@babel/preset-env 插件集合带有了esm转换插件</p>
<p><strong>但是</strong>在最新的babel-loader中，使用preset-env插件会自动<code>auto</code>识别当前环境的模块化方式，不会强制转换esm</p>
<p>想要强制转换为commojs</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/.js$/</span>,</span><br><span class="line">                <span class="attr">use</span>: &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">presets</span>: [</span><br><span class="line">                            [<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123; <span class="attr">modules</span>: <span class="string">&#x27;commonjs&#x27;</span> &#125;]</span><br><span class="line">                     				<span class="comment">//[&#x27;@babel/preset-env&#x27;, &#123; modules: false&#125;] //不会转换模块</span></span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="sideeffects-副作用"><a class="markdownIt-Anchor" href="#sideeffects-副作用"></a> sideEffects 副作用</h5>
<p>通过配置表示代码是否有副作用，更好的帮助treeshaking</p>
<p>模块执行的时候，除了导出成员，做出其他的事情</p>
<blockquote>
<p>一般用于NPM模块包标记是否有副作用</p>
<p>这个包是否会对包以外的对象产生影响，比如是否修改了 window 上的属性，是否复写了原生对象 Array, Object 方法。</p>
</blockquote>
<p><strong>使用前提：确保代码没有副作用</strong></p>
<p>开启sideEffects</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sideEffects&quot;</span> : <span class="literal">false</span> <span class="comment">//标记表示这个包没有副作用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sideEffects&quot;</span> : [</span><br><span class="line">    <span class="string">&quot;./src/components/extends.js&quot;</span>, <span class="comment">//标记哪个文件有副作用</span></span><br><span class="line">    <span class="string">&quot;*.css&quot;</span>  <span class="comment">//css模块也有副作用</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">sideEffects</span>: <span class="literal">true</span>  <span class="comment">//开启sideEffects优化功能</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分包代码分割coding-splitting"><a class="markdownIt-Anchor" href="#分包代码分割coding-splitting"></a> 分包/代码分割Coding Splitting</h5>
<p>打包到同一个bundle文件太大了，并不是每个模块都是在启动时必要的</p>
<p>分包，按需加载</p>
<blockquote>
<p>HTTP1.1 并不能对同一个域名下发起很多并行请求</p>
<p>每次请求有延迟</p>
<p>请求Header浪费带宽流量</p>
</blockquote>
<ul>
<li>
<p><mark>多打包入口 multi entry</mark></p>
<ul>
<li>多页应用程序
<ul>
<li>一个页面对应一个打包入口，公共部分单独提取</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123; <span class="comment">//两个打包入口，对象形式</span></span><br><span class="line">    <span class="attr">home</span>: <span class="string">&#x27;./src/homepage/home.js&#x27;</span>,</span><br><span class="line">    <span class="attr">info</span>: <span class="string">&#x27;./src/info/info.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>:&#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.js&#x27;</span>  <span class="comment">//[name]占位符，匹配entry的键，进而有几个entry就有几个output</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span> <span class="comment">//将所有模块的公共部分再提取出来</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;homepage&#x27;</span>,</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;home.html&#x27;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/homepage/home.html&#x27;</span>,</span><br><span class="line">      <span class="attr">chunks</span>: [<span class="string">&#x27;home&#x27;</span>] <span class="comment">//指定哪个打包的模块才能插入到这个html页面中</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;info&#x27;</span>,</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;info.html&#x27;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/info/info.html&#x27;</span>,</span><br><span class="line">      <span class="attr">chunks</span>: [<span class="string">&#x27;info&#x27;</span>] <span class="comment">//指定哪个打包的模块才能插入到这个html页面中</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=gray>HtmlWebpackPlugin默认将所有的打包文件都插入到html使用，要使用chunks配置项制定单独的js打包模块</font></p>
</li>
<li>
<h6 id="动态导入-dynamic-import"><a class="markdownIt-Anchor" href="#动态导入-dynamic-import"></a> <mark>动态导入 Dynamic Import</mark></h6>
<ul>
<li>
<p>所有动态导入的模块会<strong style="color:red;">自动分包</strong></p>
<ul>
<li>
<pre class="highlight"><code class="js"><span class="keyword">import</span>(<span class="string">&#x27;./xx.js&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">module</span>=&gt;</span>&#123;
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>)
&#125;)
<span class="keyword">import</span>(<span class="string">&#x27;./yy.js&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">module</span>=&gt;</span>&#123;
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>)
&#125;)

<span class="comment">//自动分成两个包</span>
&lt;!--code￼<span class="number">48</span>--&gt;

&lt;!--code￼<span class="number">49</span>--&gt;





</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="提取css文件"><a class="markdownIt-Anchor" href="#提取css文件"></a> 提取css文件</h5>
<p>之前都是直接将css文件打包在同一个bundle中，</p>
<p>通过插件<code>MiniCssExtractPlugin</code> ,提取css文件，实现按需加载</p>
<blockquote>
<p>之前是通过<code>css-loader</code>解析模块化css文件，再使用<code>style-loader</code>通过style标签注入到页面中</p>
<p>现在通过<code>MiniCssExtactPlugin.loader</code>配合<code>css-loader</code>将css文件**<font color=red><code>link</code></font>**引入</p>
</blockquote>
<p><code>yarn add mini-css-webpack-plugin --dev</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: &#123;</span><br><span class="line">          <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>超过150KB的css文件就最好不要提取出来，</p>
<p>避免过多的请求</p>
</blockquote>
<h5 id="压缩css文件"><a class="markdownIt-Anchor" href="#压缩css文件"></a> 压缩css文件</h5>
<blockquote>
<p>在开启生产环境模式时，webpack会自动开启代码压缩，</p>
<p>而webpack本身只能压缩js文件</p>
</blockquote>
<p>使用**<code>OptimizeCssAssetsWebpackPlugin</code>**压缩css文件</p>
<p><code>yarn add optimize-css-assets-webpack-plugin --dev</code></p>
<blockquote>
<p>如果将这个插件配置在plugins属性中，那么在任何情况都会工作</p>
<p>配置在<code>minimizer</code>配置，那么只在压缩的过程中才启用这个插件，</p>
<p>在生产环境，这时候需要配置额外的<code>terser-webpack-plugin</code> 压缩打包js代码</p>
</blockquote>
<p><em>webpack希望我们将压缩相关插件写在optimization.minimizer属性中</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>) <span class="comment">//提取css代码</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OptimizeCssAssetsWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimiztion</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">OptimizeCssWebpackPlugin</span>(),<span class="comment">//压缩css代码</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserWebpackPlugin</span>() <span class="comment">//压缩js代码</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>()<span class="comment">//提取css文件</span></span><br><span class="line">  ]</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出文件名hash"><a class="markdownIt-Anchor" href="#输出文件名hash"></a> 输出文件名Hash</h4>
<p>Substitutions</p>
<blockquote>
<p>在部署前端资源文件是，启用服务器的静态资源缓存</p>
<p>对于用户的浏览器而言，可以缓存住应用当中的静态文件</p>
<p>后续就不足要请求服务器获取资源</p>
</blockquote>
<blockquote>
<p>假如说将文件过期时间设置较长，在过程中应用发生了更新，重新部署后，没有及时更新客户端</p>
</blockquote>
<p>生产环境下，文件名用添加Hash值</p>
<p>资源文件发生改变，文件名也跟着改变，</p>
<p>对于客户端，全新的文件名就是全新的请求，没有缓存的问题</p>
<p><code>filename: '[name].[hash].bundle.css'</code></p>
<p>三种模式：</p>
<p>hash 项目级别，所有的打包文件共用一个hash。一个文件修改，所有文件的hash都变</p>
<p>trunkhash 一个entry对应一个hash</p>
<p>contenthash 单文件级别的hash</p>
<blockquote>
<p>所依赖的文件改变，文件也会改变相对应hash改变。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>一键速通菲区Spotify</title>
    <url>/posts/%E4%B8%80%E9%94%AE%E9%80%9F%E9%80%9A%E8%8F%B2%E5%8C%BASpotify/</url>
    <content><![CDATA[<h3 id="prerequisite"><a class="markdownIt-Anchor" href="#prerequisite"></a> prerequisite</h3>
<p>菲区电话卡、菲区梯子🪜</p>
<h3 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h3>
<ol start="0">
<li>
<p>Spotify换区（挂上🇵🇭🪜）</p>
</li>
<li>
<p>某宝下单菲律宾电话卡（推荐Globe卡￥20+）</p>
</li>
<li>
<p>话费充值（推荐易付宝， Google Play下载）</p>
</li>
<li>
<p>登录进入<strong>手机端Spotify</strong>，选择套餐通过<strong>话费充值</strong></p>
</li>
</ol>
<h3 id="切记"><a class="markdownIt-Anchor" href="#切记"></a> 切记💡</h3>
<ul>
<li><strong>第三步</strong>，必须在手机端中操作，账号登录成功后不要挂任何🪜，网络直连就行</li>
</ul>
<h3 id="other"><a class="markdownIt-Anchor" href="#other"></a> Other</h3>
<p>也可以试试<code>GCash</code>支付，需要实名。</p>
<p>应填写真实的信息（护照等），不然一个月之内检测被封。（谷歌搜有相应的教程）</p>
]]></content>
      <tags>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title>博客网站搭建</title>
    <url>/posts/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><s>一个前端开发者没有一个博客像什么话呢？</s></p>
<p>因为这个网上搜寻了一番，如何搭建一个博客。</p>
<p>虽然也没什么好写的，而且分享的东西也只不过是别人嘴里吐出来的话罢了。（管他的， im just a 菜鸡🤡</p>
<p>大部分人用的<code>hexo</code>这个静态站点生成器，而且也有很多现成的模版</p>
<p>嘻嘻，最终被我发现了<code>Frame</code>这个主题。虽然开箱即用的功能没其他主题多，胜在这完美的UI，简约高级！！！</p>
<p>加了一些新功能</p>
<ul>
<li>国际化（虽然也just用在了主页</li>
<li>评论 disqus</li>
<li>文章TOC</li>
<li>还有一些小修改。。。</li>
</ul>
<p>最后也跟着网上的步骤直接部署在github page上，后也在用vercel一键部署，但是vercel被大陆block了，并且url也带着<code>.vercel</code>，真的有点丑</p>
<p>后面又想着自己弄一个域名</p>
<p><strong>秉持着能白嫖就白嫖的理念</strong>🤣</p>
<p>​	域名平台肯定是想用：久闻盛名的免费域名平台<code>freenom</code>，好景不长，早已关闭了申请通道</p>
<p>​	最后搜到了<code>namesoli</code>这个平台。第一年，在使用了优惠🐴后<code>.top</code>域名首年只要人民币7块</p>
<p>​	在加个cdn就完美了</p>
<p>​		  提到cdn肯定就想到某慈善家<code>cloudflare</code> ，直接选择free plan加速我想部署的vercel项目，利用边缘服务器，直接在大陆也可访问咯，但是感觉速度还是不如githubpage</p>
<p><font size=5><strong>归根来说就是直接 <code>hexo github vercel namesoli cloudflare</code> 一把子梭哈，时刻羡慕米国人可以直接用上这么好的技术。。。。😇</strong> </font></p>
<p>参考网站 <a href="https://blog.naibabiji.com/tutorial/namesilo-yu-ming-jie-xi-geng-huan-dns-jiao-cheng.html">NameSilo域名解析和DNS服务器修改教程</a></p>
]]></content>
      <tags>
        <tag>blog</tag>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title>杂项</title>
    <url>/posts/%E6%9D%82%E9%A1%B9/</url>
    <content><![CDATA[<p><mark>highlight</mark><br />
​🈂️​</p>
<h4 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>滑动验证</title>
    <url>/posts/%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>最近在写一个注册表单的需要一个滑动验证模块。</p>
<p>👨‍💻网上搜寻一番，发现了一个组件比较好用<a href="https://github.com/javaLuo/vue-puzzle-vcode"><code>vue3-puzzle-vcode</code></a></p>
<hr />
<ul>
<li>
<h3 id="配合element-plus-dialog-和-form-组件使用"><a class="markdownIt-Anchor" href="#配合element-plus-dialog-和-form-组件使用"></a> 配合<code>ELement-Plus</code>:  dialog 和 form 组件使用</h3>
</li>
</ul>
<h4 id="login组件控制register表单组件显示"><a class="markdownIt-Anchor" href="#login组件控制register表单组件显示"></a> Login组件控制Register表单组件显示</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//login.vue</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import Register from &#x27;@/components/Register.vue&#x27;</span><br><span class="line">const registerDiaVisible = ref(false)</span><br><span class="line">const openRegisterDia = () =&gt; &#123;</span><br><span class="line">	registerDiaVisible.value = true</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">...</span><br><span class="line">&lt;Register v-model:registerDiaVisible=&quot;registerDiaVisible&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="register组件"><a class="markdownIt-Anchor" href="#register组件"></a> Register组件</h4>
<p>（表单校验成功后，打开滑动验证组件，再次成功调用onSuccess）</p>
<blockquote>
<p>注意调整滑动验证组件的<code>z-index</code>，默认<code>el-dialog</code>组件层级高于<code>Vcode</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; formPost &#125; from &#x27;@/api/request&#x27;</span><br><span class="line">import &#123; ElMessage, FormInstance &#125; from &#x27;element-plus&#x27;</span><br><span class="line">import &#123; reactive, ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import &#123; RegisterForm &#125; from &#x27;@/ts/interfaces/login.interface&#x27;</span><br><span class="line">import Vcode from &#x27;vue3-puzzle-vcode&#x27;</span><br><span class="line">const props = defineProps&lt;&#123;</span><br><span class="line">	registerDiaVisible: boolean</span><br><span class="line">&#125;&gt;()</span><br><span class="line"></span><br><span class="line">const emit = defineEmits&lt;&#123;</span><br><span class="line">	&#x27;update:registerDiaVisible&#x27;: [registerDiaVisible: boolean]</span><br><span class="line">&#125;&gt;()</span><br><span class="line"></span><br><span class="line">const handleCancel = () =&gt; &#123;</span><br><span class="line">	emit(&#x27;update:registerDiaVisible&#x27;, false)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//表单绑定的响应式对象</span><br><span class="line">const formData = reactive(&#123;</span><br><span class="line">	nickName: &#x27;&#x27;,</span><br><span class="line">	realName: &#x27;&#x27;,</span><br><span class="line">	pwd: &#x27;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 表单的引用对象</span><br><span class="line">const formRef = ref()</span><br><span class="line">// 表单校验</span><br><span class="line">const rules = reactive(&#123;</span><br><span class="line">	nickName: [</span><br><span class="line">		&#123; required: true, message: &#x27;请输入昵称&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">		&#123; min: 3, max: 10, message: &#x27;请输入3-10位昵称&#x27;, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">	],</span><br><span class="line">	realName: [</span><br><span class="line">		&#123; required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">		&#123; min: 3, max: 10, message: &#x27;请输入3-10位用户名&#x27;, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">	],</span><br><span class="line">	pwd: [</span><br><span class="line">		&#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">		&#123; min: 3, max: 10, message: &#x27;请输入3-10位密码&#x27;, trigger: &#x27;blur&#x27; &#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const onClose = () =&gt; &#123;</span><br><span class="line">	isShow.value = !isShow.value</span><br><span class="line">&#125;</span><br><span class="line">const onSuccess = () =&gt; &#123;</span><br><span class="line">	// 滑动验证成功, 发送请求</span><br><span class="line">	formPost&lt;RegisterForm, string&gt;(&#123;</span><br><span class="line">		url: &#x27;/user/register&#x27;,</span><br><span class="line">		data: &#123; ...formData &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">		.then(res =&gt; &#123;</span><br><span class="line">			isShow.value = !isShow.value</span><br><span class="line">			ElMessage.success(res.data)</span><br><span class="line">		&#125;)</span><br><span class="line">		.catch(err =&gt; &#123;</span><br><span class="line">			isShow.value = !isShow.value</span><br><span class="line">			ElMessage.error(err.msg)</span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const onSubmit = async (formEl: FormInstance | undefined) =&gt; &#123;</span><br><span class="line">	if (!formEl) return</span><br><span class="line">	formEl.validate((valid, fields) =&gt; &#123;</span><br><span class="line">		if (valid) &#123;</span><br><span class="line">			isShow.value = !isShow.value</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			console.log(&#x27;error submit!&#x27;, fields)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isShow = ref(false)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;el-dialog</span><br><span class="line">		title=&quot;用户注册&quot;</span><br><span class="line">		v-model=&quot;props.registerDiaVisible&quot;</span><br><span class="line">		:before-close=&quot;handleCancel&quot;</span><br><span class="line">	&gt;</span><br><span class="line">		&lt;el-form :rules=&quot;rules&quot; :model=&quot;formData&quot; ref=&quot;formRef&quot;&gt;</span><br><span class="line">			&lt;el-form-item label=&quot;昵称:&quot; label-width=&quot;120&quot; prop=&quot;nickName&quot;&gt;</span><br><span class="line">				&lt;el-input v-model=&quot;formData.nickName&quot; /&gt;</span><br><span class="line">			&lt;/el-form-item&gt;</span><br><span class="line">			&lt;el-form-item label=&quot;姓名:&quot; label-width=&quot;120&quot; prop=&quot;realName&quot;&gt;</span><br><span class="line">				&lt;el-input v-model=&quot;formData.realName&quot; /&gt;</span><br><span class="line">			&lt;/el-form-item&gt;</span><br><span class="line">			&lt;el-form-item label=&quot;密码:&quot; label-width=&quot;120&quot; prop=&quot;pwd&quot;&gt;</span><br><span class="line">				&lt;el-input v-model=&quot;formData.pwd&quot; show-password /&gt;</span><br><span class="line">			&lt;/el-form-item&gt;</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;el-button @click=&quot;handleCancel&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class="line">				&lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit(formRef)&quot;&gt;</span><br><span class="line">					确 定</span><br><span class="line">				&lt;/el-button&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		&lt;/el-form&gt;</span><br><span class="line">	&lt;/el-dialog&gt;</span><br><span class="line">	&lt;Vcode :show=&quot;isShow&quot; @success=&quot;onSuccess&quot; @close=&quot;onClose&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">:global(.vue-puzzle-vcode) &#123;</span><br><span class="line">	z-index: 10000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="final"><a class="markdownIt-Anchor" href="#final"></a> final</h3>
<p><img src="https://s2.loli.net/2023/08/07/NnqX4AMTyiCYkuJ.gif" alt="滑动验证" /></p>
]]></content>
      <tags>
        <tag>vue3</tag>
        <tag>enhanced</tag>
      </tags>
  </entry>
  <entry>
    <title>简单实现Toast组件</title>
    <url>/posts/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0Toast%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>一个模版文件Toast.vue</li>
<li>一个渲染挂载导出方法文件index.ts
<ul>
<li>通过Toast.success(‘xxxx’) 调用</li>
</ul>
</li>
</ul>
</blockquote>
<p>这里UI使用<code>Flowbite</code>的<a href="https://flowbite.com/docs/components/toast/#colors">Toast</a>组件（需要配合tailwindcss）</p>
<p><img src="https://s2.loli.net/2023/08/17/hrfHPm5M8LAZcv4.png" alt="image-20230817102433189.png" /></p>
<h2 id="供给渲染的模板"><a class="markdownIt-Anchor" href="#供给渲染的模板"></a> 供给渲染的模板</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">interface Props &#123;</span><br><span class="line">	visible: boolean</span><br><span class="line">	type: string</span><br><span class="line">	message: string</span><br><span class="line">&#125;</span><br><span class="line">const props = withDefaults(defineProps&lt;Props&gt;(), &#123;</span><br><span class="line">	visible: false,</span><br><span class="line">	type: &#x27;&#x27;,</span><br><span class="line">	message: &#x27;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const status = props.type === &#x27;success&#x27; ? &#x27;success&#x27; : &#x27;danger&#x27;</span><br><span class="line">const toast = ref&lt;HTMLDivElement&gt;()</span><br><span class="line">const handleClose = () =&gt; &#123;</span><br><span class="line">	toast.value!.style.display = &#x27;none&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;Transition</span><br><span class="line">		name=&quot;toast&quot;</span><br><span class="line">		enter-active-class=&quot;transition ease-out duration-300&quot;</span><br><span class="line">		leave-active-class=&quot;transition ease-in duration-300&quot;</span><br><span class="line">	&gt;</span><br><span class="line">		&lt;div class=&quot;fixed inset-0 h-0&quot; v-if=&quot;props.visible&quot;&gt;</span><br><span class="line">			&lt;div</span><br><span class="line">				:id=&quot;`toast-$&#123;status&#125;`&quot;</span><br><span class="line">				class=&quot;absolute top-5 left-1/2 -translate-x-1/2 flex items-center w-full max-w-xs p-4 mb-4 text-gray-500 bg-white rounded-lg shadow dark:text-gray-400 dark:bg-gray-800&quot;</span><br><span class="line">				role=&quot;alert&quot;</span><br><span class="line">				ref=&quot;toast&quot;</span><br><span class="line">			&gt;</span><br><span class="line">				&lt;div</span><br><span class="line">					v-if=&quot;props.type === &#x27;success&#x27;&quot;</span><br><span class="line">					class=&quot;inline-flex items-center justify-center flex-shrink-0 w-8 h-8 text-green-500 bg-green-100 rounded-lg dark:bg-green-800 dark:text-green-200&quot;</span><br><span class="line">				&gt;</span><br><span class="line">					&lt;svg</span><br><span class="line">						class=&quot;w-5 h-5&quot;</span><br><span class="line">						aria-hidden=&quot;true&quot;</span><br><span class="line">						xmlns=&quot;http://www.w3.org/2000/svg&quot;</span><br><span class="line">						fill=&quot;currentColor&quot;</span><br><span class="line">						viewBox=&quot;0 0 20 20&quot;</span><br><span class="line">					&gt;</span><br><span class="line">						&lt;path</span><br><span class="line">							d=&quot;M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5Zm3.707 8.207-4 4a1 1 0 0 1-1.414 0l-2-2a1 1 0 0 1 1.414-1.414L9 10.586l3.293-3.293a1 1 0 0 1 1.414 1.414Z&quot;</span><br><span class="line">						/&gt;</span><br><span class="line">					&lt;/svg&gt;</span><br><span class="line">					&lt;span class=&quot;sr-only&quot;&gt; Check icon &lt;/span&gt;</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">				&lt;div</span><br><span class="line">					v-else-if=&quot;props.type === &#x27;error&#x27;&quot;</span><br><span class="line">					class=&quot;inline-flex items-center justify-center flex-shrink-0 w-8 h-8 text-red-500 bg-red-100 rounded-lg dark:bg-red-800 dark:text-red-200&quot;</span><br><span class="line">				&gt;</span><br><span class="line">					&lt;svg</span><br><span class="line">						class=&quot;w-5 h-5&quot;</span><br><span class="line">						aria-hidden=&quot;true&quot;</span><br><span class="line">						xmlns=&quot;http://www.w3.org/2000/svg&quot;</span><br><span class="line">						fill=&quot;currentColor&quot;</span><br><span class="line">						viewBox=&quot;0 0 20 20&quot;</span><br><span class="line">					&gt;</span><br><span class="line">						&lt;path</span><br><span class="line">							d=&quot;M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5Zm3.707 11.793a1 1 0 1 1-1.414 1.414L10 11.414l-2.293 2.293a1 1 0 0 1-1.414-1.414L8.586 10 6.293 7.707a1 1 0 0 1 1.414-1.414L10 8.586l2.293-2.293a1 1 0 0 1 1.414 1.414L11.414 10l2.293 2.293Z&quot;</span><br><span class="line">						/&gt;</span><br><span class="line">					&lt;/svg&gt;</span><br><span class="line">					&lt;span class=&quot;sr-only&quot;&gt; Error icon &lt;/span&gt;</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line">				&lt;div class=&quot;ml-3 text-sm font-normal&quot;&gt;</span><br><span class="line">					&lt;!-- &#123;/* 不同 */&#125;  --&gt;</span><br><span class="line">					&#123;&#123; props.message &#125;&#125;</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line">				&lt;button</span><br><span class="line">					type=&quot;button&quot;</span><br><span class="line">					class=&quot;ml-auto -mx-1.5 -my-1.5 bg-white text-gray-400 hover:text-gray-900 rounded-lg focus:ring-2 focus:ring-gray-300 p-1.5 hover:bg-gray-100 inline-flex items-center justify-center h-8 w-8 dark:text-gray-500 dark:hover:text-white dark:bg-gray-800 dark:hover:bg-gray-700&quot;</span><br><span class="line">					data-dismiss-target=&quot;#toast-success&quot;</span><br><span class="line">					aria-label=&quot;Close&quot;</span><br><span class="line">					@click=&quot;handleClose&quot;</span><br><span class="line">				&gt;</span><br><span class="line">					&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">					&lt;svg</span><br><span class="line">						class=&quot;w-3 h-3&quot;</span><br><span class="line">						aria-hidden=&quot;true&quot;</span><br><span class="line">						xmlns=&quot;http://www.w3.org/2000/svg&quot;</span><br><span class="line">						fill=&quot;none&quot;</span><br><span class="line">						viewBox=&quot;0 0 14 14&quot;</span><br><span class="line">					&gt;</span><br><span class="line">						&lt;path</span><br><span class="line">							stroke=&quot;currentColor&quot;</span><br><span class="line">							stroke-linecap=&quot;round&quot;</span><br><span class="line">							stroke-linejoin=&quot;round&quot;</span><br><span class="line">							stroke-width=&quot;2&quot;</span><br><span class="line">							d=&quot;m1 1 6 6m0 0 6 6M7 7l6-6M7 7l-6 6&quot;</span><br><span class="line">						/&gt;</span><br><span class="line">					&lt;/svg&gt;</span><br><span class="line">				&lt;/button&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/Transition&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.toast-enter-from,</span><br><span class="line">.toast-leave-to &#123;</span><br><span class="line">	opacity: 0;</span><br><span class="line">	transform: translateY(-30px);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="导出toast方法提供给vue进行挂载"><a class="markdownIt-Anchor" href="#导出toast方法提供给vue进行挂载"></a> 导出toast方法，提供给Vue进行挂载</h2>
<p>index.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ts-nocheck</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp, h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ToastComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./template/Toast.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ToastProps</span> &#123;</span><br><span class="line">	<span class="attr">visible</span>: <span class="built_in">boolean</span></span><br><span class="line">	<span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span> | <span class="string">&#x27;error&#x27;</span></span><br><span class="line">	<span class="attr">message</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ToastContainer</span> = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">	<span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">ToastComponent</span>, <span class="variable language_">this</span>.<span class="property">toastProps</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">toastProps</span>: &#123;</span><br><span class="line">				<span class="attr">visible</span>: <span class="literal">false</span>,</span><br><span class="line">				<span class="attr">type</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">				<span class="attr">message</span>: <span class="string">&#x27;&#x27;</span> </span><br><span class="line">			&#125; <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="title class_">ToastProps</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toast = <span class="title class_">ToastContainer</span>.<span class="title function_">mount</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(toast.<span class="property">$el</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Toast</span> = &#123;</span><br><span class="line">	<span class="title function_">success</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		toast.<span class="property">toastProps</span> = &#123;</span><br><span class="line">			<span class="attr">visible</span>: <span class="literal">true</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">			message</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			toast.<span class="property">toastProps</span>.<span class="property">visible</span> = <span class="literal">false</span></span><br><span class="line">		&#125;, <span class="number">3000</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		toast.<span class="property">toastProps</span> = &#123;</span><br><span class="line">			<span class="attr">visible</span>: <span class="literal">true</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">			message</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			toast.<span class="property">toastProps</span>.<span class="property">visible</span> = <span class="literal">false</span></span><br><span class="line">		&#125;, <span class="number">3000</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Toast</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 👨‍💻使用</h2>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Toast</span>.<span class="title function_">success</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="title class_">Toast</span>.<span class="title function_">error</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/08/17/ewqEhulLyJmUCKH.gif" alt="toast.gif" /></p>
]]></content>
      <tags>
        <tag>enhanced</tag>
      </tags>
  </entry>
  <entry>
    <title>表格导出为excel</title>
    <url>/posts/%E8%A1%A8%E6%A0%BC%E5%AF%BC%E5%87%BA%E4%B8%BAexcel/</url>
    <content><![CDATA[<p><strong>配合xlsx模块 + fileSaver模块</strong></p>
<h2 id="️-下载"><a class="markdownIt-Anchor" href="#️-下载"></a> ⚙️ 下载</h2>
<p><code>yarn add xlsx file-saver</code></p>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 🔦 使用</h2>
<blockquote>
<p>​	tableData格式  [ { 	xxx: yyy 	},  …]</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">XLSX</span> <span class="keyword">from</span> <span class="string">&#x27;xlsx&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FileSaver</span> <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> excelTable = tableData.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line"> 	 <span class="comment">//格式化一下表格数据</span></span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="string">&#x27;系统编号&#x27;</span>: item.<span class="property">id</span>,</span><br><span class="line">			<span class="string">&#x27;账单时间&#x27;</span>: item.<span class="property">billTime</span>,</span><br><span class="line">			<span class="string">&#x27;类型&#x27;</span>: item.<span class="property">natureName</span>=== <span class="string">&#x27;收入&#x27;</span>?<span class="string">&#x27;收入&#x27;</span>:<span class="string">&#x27;支出&#x27;</span>,</span><br><span class="line">			<span class="string">&#x27;金额&#x27;</span>: item.<span class="property">natureName</span>=== <span class="string">&#x27;收入&#x27;</span>?item.<span class="property">amountMoney</span>:-item.<span class="property">amountMoney</span>,</span><br><span class="line">			<span class="string">&#x27;备注&#x27;</span>: item.<span class="property">remarks</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">const</span> worksheet = <span class="variable constant_">XLSX</span>.<span class="property">utils</span>.<span class="title function_">json_to_sheet</span>(excelTable)</span><br><span class="line">	<span class="keyword">const</span> workbook = <span class="variable constant_">XLSX</span>.<span class="property">utils</span>.<span class="title function_">book_new</span>()</span><br><span class="line">	<span class="variable constant_">XLSX</span>.<span class="property">utils</span>.<span class="title function_">book_append_sheet</span>(workbook, worksheet, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">	<span class="keyword">const</span> excelBuffer = <span class="variable constant_">XLSX</span>.<span class="title function_">write</span>(workbook, &#123;</span><br><span class="line">		<span class="attr">bookType</span>: <span class="string">&#x27;xlsx&#x27;</span>,</span><br><span class="line">		<span class="attr">type</span>: <span class="string">&#x27;array&#x27;</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([excelBuffer], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/vnd.ms-excel&#x27;</span> &#125;)</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="title class_">FileSaver</span>.<span class="title function_">saveAs</span>(blob, <span class="string">&#x27;账单&#x27;</span>) <span class="comment">// 下载文件 文件名</span></span><br><span class="line">	&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本来是想利用WebWorker在另一线程中处理数据，<s>在vite中还没配置好，on the way</s>~</p>
</blockquote>
]]></content>
      <tags>
        <tag>enhanced</tag>
      </tags>
  </entry>
  <entry>
    <title>面试1</title>
    <url>/posts/%E9%9D%A2%E8%AF%951/</url>
    <content><![CDATA[<p>主要围绕简历展开</p>
<h2 id="自我介绍"><a class="markdownIt-Anchor" href="#自我介绍"></a> 自我介绍</h2>
<blockquote>
<p>​	从未准备过，每次都是“面试官你好，我是来自xx学校xx学院的学生，学习前端xx年了”，然后就戛然而止。。。</p>
</blockquote>
<h2 id="项目"><a class="markdownIt-Anchor" href="#项目"></a> 项目</h2>
<ul>
<li>
<p>实习项目简介</p>
</li>
<li>
<p>实习负责板块介绍</p>
</li>
<li>
<p>难点，遇到什么问题</p>
</li>
<li>
<p>对于技术上手快吗</p>
</li>
</ul>
<h2 id="计网"><a class="markdownIt-Anchor" href="#计网"></a> 计网</h2>
<ul>
<li>Ajax 工作方式</li>
<li>http请求响应过程</li>
</ul>
<h2 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项</h2>
<ul>
<li>JWT
<ul>
<li>前端axios拦截 后端加密解密~</li>
</ul>
</li>
<li>vue react 区别</li>
<li>会不会后端（❓</li>
<li>是否接受加班</li>
</ul>
<h2 id="反问"><a class="markdownIt-Anchor" href="#反问"></a> 反问</h2>
<ul>
<li>公司产品（自研？</li>
<li>工作地点 &amp; 加班</li>
<li>。。。</li>
</ul>
]]></content>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>乐山</title>
    <url>/posts/gallery-%E4%B9%90%E5%B1%B1/</url>
    <content><![CDATA[<p>寒假终于有机会出游（<strong>蹭的</strong>）（特别感谢我哥和我嫂子）🫰</p>
<p>三天两晚，乐山城区、苏稽古镇、金口河</p>
<p>（不得不说来乐山旅游的人真的太多多多了，城区每家店子人都爆满</p>
<br />
<p>吃的<code>板眼儿</code>多得<code>遭不住</code>  🆘​</p>
<table>
<thead>
<tr>
<th>炸串（排队排队）</th>
<th>咔饼</th>
<th>豆腐脑（不能接受勾了芡的食品）</th>
<th>甜皮鸭</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://images.weserv.nl/?url=https://i.imgur.com/yRpOtF2.jpg" alt="油炸" /></td>
<td><img src="https://images.weserv.nl/?url=https://i.imgur.com/sSO8Tub.jpg" alt="20230202_144544" /></td>
<td><img src="https://images.weserv.nl/?url=https://i.imgur.com/xSqXXIP.jpg" alt="20230202_143741" /></td>
<td>404忘记拍照了…</td>
</tr>
</tbody>
</table>
<p><code>苏稽翘脚牛肉</code>单拎出来，太好吃了 favorito~</p>
<p><img src="https://images.weserv.nl/?url=https://i.imgur.com/YsVMSwR.jpg" alt="20230203_122113" /></p>
<p>坐船看了乐山大佛，逛了苏稽古镇，当然最<strong>impressive</strong>的还是金口河大峡谷。。。</p>
<blockquote>
<p>人类真的特别特别渺小</p>
</blockquote>
<table>
<thead>
<tr>
<th><img src="https://images.weserv.nl/?url=https://i.imgur.com/i0uR66t.jpg" alt="20230203_160746" /></th>
<th><img src="https://images.weserv.nl/?url=https://i.imgur.com/C3Wh8C3.jpg" alt="20230203_150035" /></th>
<th><img src="https://images.weserv.nl/?url=https://i.imgur.com/3ROlK0A.jpg" alt="20230203_155615" /></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://images.weserv.nl/?url=https://i.imgur.com/Hp34XzF.jpg" alt="20230203_150324" /></td>
<td><img src="https://images.weserv.nl/?url=https://i.imgur.com/r4QpbWh.jpg" alt="20230203_144629" /></td>
<td><img src="https://images.weserv.nl/?url=https://i.imgur.com/63nBWhM.jpg" alt="20230203_150313" /></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
  </entry>
  <entry>
    <title>新加坡</title>
    <url>/posts/gallery-%E6%96%B0%E5%8A%A0%E5%9D%A1/</url>
    <content><![CDATA[<p>去新加坡看了泰勒斯威夫特时代巡回演唱会哦！！</p>
<p><img src="https://s2.loli.net/2024/04/28/p1PBMcQqO9JUFzl.jpg" alt="20240307_125216" /></p>
<p><img src="https://s2.loli.net/2024/04/28/G6Xfk3haBNny8As.jpg" alt="20240307_132647" /></p>
<p><img src="https://s2.loli.net/2024/04/28/G6Xfk3haBNny8As.jpg" alt="20240307_132847" /></p>
<p><img src="https://s2.loli.net/2024/04/28/5XHpciW1g2uBbRZ.jpg" alt="20240307_154607" /></p>
<p><img src="https://s2.loli.net/2024/04/28/TrtfdPS2ujeLHWw.jpg" alt="20240307_183520" /></p>
<p><img src="https://s2.loli.net/2024/04/28/lszSimFCpHT85aJ.jpg" alt="20240307_184135" /></p>
<p><img src="https://s2.loli.net/2024/04/28/Oj9fTA4q36CRsHn.jpg" alt="20240307_193513" /></p>
<p><img src="https://s2.loli.net/2024/04/28/utQDbC5hWknLZvN.jpg" alt="20240308_125909" /></p>
<p><img src="https://s2.loli.net/2024/04/28/yPhlzF2nRCEsJMK.jpg" alt="20240308_130431" /></p>
<p><img src="./%E6%96%B0%E5%8A%A0%E5%9D%A1.assets/20240308_171138.jpg" alt="20240308_171138" /></p>
<p><img src="https://s2.loli.net/2024/04/28/HzFJ7sOcb2189yi.jpg" alt="20240308_185549" /></p>
<p><img src="https://s2.loli.net/2024/04/28/TeVwEFWglMIjumn.jpg" alt="20240309_102654" /></p>
<p><img src="https://s2.loli.net/2024/04/28/ZFLuMhgjoty1PTK.jpg" alt="20240309_181543" /></p>
<p><img src="../../Downloads/QuickShare_2404281527/20240310_111740.jpg" alt="20240310_111740" /></p>
<p><img src="https://s2.loli.net/2024/04/28/Zg23qK1f9SUoBWn.jpg" alt="VideoCapture_20240309-162949" /></p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
  </entry>
  <entry>
    <title>大理</title>
    <url>/posts/gallery-%E5%A4%A7%E7%90%86/</url>
    <content><![CDATA[<hr />
<p style="font-style: italic; font-size: 20px; font-weight:bold;">
永远怀念那一个自由的夏天
</p>
<hr />
<br />
<h2 id="洱海傍晚"><a class="markdownIt-Anchor" href="#洱海傍晚"></a> 洱海傍晚</h2>
<div style='text-align='center''>
<img src='https://images.weserv.nl/?url=https://i.imgur.com/YVNCcZb.jpg' alt='洱海傍晚' style="display: block;" />
<p style='font-size: 0.8em;'>我最好的一张摄影作品🫣（just shot on the mobile device）</p>
</div>
<h2 id="喜洲稻田"><a class="markdownIt-Anchor" href="#喜洲稻田"></a> 喜洲稻田</h2>
<img src='https://images.weserv.nl/?url=https://i.imgur.com/QGuARFO.jpg' alt='喜洲稻田'/>
<h2 id="洱海午后"><a class="markdownIt-Anchor" href="#洱海午后"></a> 洱海午后</h2>
<img src='https://images.weserv.nl/?url=https://i.imgur.com/HBOvej0.jpg' alt='洱海午后'/>
<h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2>
<table>
<thead>
<tr>
<th><img src="https://images.weserv.nl/?url=https://i.imgur.com/nC3dGRX.jpg" alt="栓q" style="zoom:50%;" /></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://images.weserv.nl/?url=https://i.imgur.com/KfS295U.jpg" alt="cat-🍮" style="zoom:50%;" /></td>
</tr>
<tr>
<td><img src="https://images.weserv.nl/?url=https://i.imgur.com/6FZtChd.jpg" alt="sip" style="zoom: 50%;" /></td>
</tr>
</tbody>
</table>
<blockquote>
<p>I think this is the life, but <strong>august</strong> always slipped away into moment in time 🎯</p>
</blockquote>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
  </entry>
  <entry>
    <title>&#39;tag&#39;</title>
    <url>/posts/zh-CN-tag-index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>NEW START</title>
    <url>/posts/NEW-STARTR/</url>
    <content><![CDATA[<ul>
<li>迷茫是自由产生的旋涡</li>
<li>顺其自然，随意地飘去吧</li>
<li>…</li>
</ul>
]]></content>
      <tags>
        <tag>insights</tag>
      </tags>
  </entry>
</search>
